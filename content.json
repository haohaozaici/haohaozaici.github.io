{"meta":{"title":"浩浩的被窝","subtitle":null,"description":null,"author":"haohaozaici","url":"https://haohaozaici.github.io"},"pages":[{"title":"Categories","date":"2017-12-13T06:40:48.054Z","updated":"2017-12-13T06:40:48.054Z","comments":true,"path":"categories/index.html","permalink":"https://haohaozaici.github.io/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2017-12-13T06:40:48.053Z","updated":"2017-12-13T06:40:48.053Z","comments":true,"path":"about/index.html","permalink":"https://haohaozaici.github.io/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-12-13T06:40:48.055Z","updated":"2017-12-13T06:40:48.055Z","comments":true,"path":"tags/index.html","permalink":"https://haohaozaici.github.io/tags/index.html","excerpt":"","text":""},{"title":"2017年终总结","date":"2018-01-13T18:20:23.000Z","updated":"2018-04-20T02:04:57.000Z","comments":true,"path":"生活/2017-summary.html","permalink":"https://haohaozaici.github.io/生活/2017-summary.html","excerpt":"","text":"没想到还是要写年终总结了。。。此刻正在我的小桌子上，用键盘和mac写下这篇年终总结。。\b时间: 2018-01-14 00:24:09 第一次写年终总结\b有点懵。。。不过刚刚看了一集生活大爆炸中的内容感触很深，Sheldon被问及最近在研究什么的时候，不知道怎么回答，只能用愤怒来掩饰。 掩饰什么呢？懈怠了吗？\b 肯定不是啦，\bSheldon怎么会是懒惰的人呢。原来是因为开始研究暗物质，但最近一无所获，有点迷失。经过这么\b一问，\b加上penny的「倾听」和「配合」，Sheldon突然发现自己\u001b最喜欢的还是\b弦理论，研究暗物质可能只是因大家都在讨论，看起来很cool而已。 是啊，很多喊得热火朝天，趋之若鹜的东西，最终反而会迷失了自己。 Leonard和amy\b在回忆小时候的科学实验，\b\b找到共同话题，开心的不得了；Howard和rajesh又一起组建了乐队，berni\b发现Howard是真的喜欢之后也\b\b默默同意，虽然最后唱的悲剧了\b。。。hahaSheldon也在弦理论中找到\b新的思路 他们都在做自己喜欢的事，热爱的\b东西。无论结果好坏，\b却愿意付出真正的行动与热情。 这一切，让我想起了还在东一食堂的时候，高中学习累的不行，周末下午在家里\b躺在床上睡着了，快吃饭的\b时候，妈妈喊我也不想起来，突然电视里在放虚拟现实的内容，他们开始讨论这个，隐约听见有人问我。。。然后我就感觉到大脑异常的兴奋\b，开始向他们介绍和解释\bVR，\b但\b当时还是迷糊状态。。。眼睛都睁不开。或许这就是热情，喜欢吧。（现在已经没那么感兴趣了。。。zz） 以上也是我现在的困惑，工作中找不到重心，也找不到成就感。 有点跑偏了。。。\b回归正题，一年都干了些什么呢 年初的目标大概就是「工作」、「想买的xxx」、「礼物」、加上某个不存在的东西…哈哈。 想买的电子产品都买啦~ Mac、耳机、键盘。最满意的\b\b是「键盘」，使用率最高，也符合\b预期。今年应该会考虑换个手机 +「\bAirPods」。 礼物的话，\b爸爸的眼镜、\b「mi note3」，哥哥的iPad的支援了一半，还差两个不知道送啥。。。 工作基本上是满足的，学习状态、同事关系、\b部门活动\b都很不错。 不存在的就不说了。。。 学习上的成长开发经验的积累，开始注意理财 开发经验今年真是写了几个大bug，造成了\b一些比较严重的后果。。。最大的感受应该是思路的严谨，对于所有预期的\b异常情况都需要处理，喜欢drakeet的比喻「绝不会让咖啡洒在Mac上」。知道水会造成严重的伤害，就绝不会让它靠近。不考虑异常是不负责任。 意识到：学习一门新的语言或者是接触新的领域 = 语言基础（语言特性） + API + 实践经验（踩坑） 今年的技术积累大概就是这张图了吧。。。都在书签里了 也不知道该总结什么。。。\b虽然感觉学习了很多，但有太多的不足。 12345678Java基础数据结构和算法网络Android View相关Android架构webserver 不过经过了生产环境的实践，已经逐渐意识到不足的\b部分，也开始有计划的学习。 感觉2017年学习的知识很多，甚至有些杂乱，其中主要的原因应该是没有总结、积累，实践也稍显不足。利用保存书签来记录看来是有些幼稚了。。。 \b已经意识到「临时工作区」、「灵感」、「\b实践记录」、「阶段性总结」、「文章」的区别。"},{"title":"","date":"2018-06-25T01:25:05.373Z","updated":"2018-06-25T01:25:05.373Z","comments":true,"path":"生活/对时间的思考.html","permalink":"https://haohaozaici.github.io/生活/对时间的思考.html","excerpt":"","text":"我总以为在工作之余的闲暇时间里，能更好的休息，放松紧绷的神经，能让身体回血。可是从大学时期开始，一切的「闲暇」时间好像都不一样了。为什么呢，好像从那时候开始，可以自我支配的时间都潜意识里被用来满足精神和身体上的欲望了。游戏、社交、网络、购物。。。所有的一切都在欲望的支配下进行着，欲望也分高低，积极的欲望，让我付出努力、获得认可，劣等的欲望却让我在休息的时间沉沦，丧失思考，丧失自我控制力。可笑的是，在工作时间，我还总是期待能在休息时间做「重要的事」。 不知道什么时候开始，我开始对各种事情划分价值，货币是时间，觉得有价值的事就会付出时间，好像很理性，很正确。结果呢，除了工作，其他所有的事我都觉得没意思，没「价值」。所以在工作之外的时间，我几乎都沉沦在精神和身体的欲望之中。这样的结果太可怕了，而且已经持续了很久，因此我打算改变对休息时间的看法，彻底取消「价值制度」，将一些规律的事情安排在周末"},{"title":"2018求职的痛苦经历","date":"2018-05-12T07:40:01.000Z","updated":"2018-05-12T07:56:45.571Z","comments":true,"path":"生活/2018求职的痛苦经历.html","permalink":"https://haohaozaici.github.io/生活/2018求职的痛苦经历.html","excerpt":"","text":"来北京快一个月了，刚开始每个周末都很忙，找房子、体检、回家、公司出游，没想到今天（2018-05-12）居然是第一天闲下来回忆、思考、记录的时候。 刚到北京，因为对于未知的城市心怀忐忑，所以提前做了些功课，住房上几乎没带来任何困扰，加上地图软件，出行也很顺利。似乎一切都很顺利，刚到第一天就确定了工作，在小东的陪伴下，一起游玩了颐和园，遇到了活历史老爷爷（现在很后悔当时不够亲切和尊敬），正常上班，不错的工作环境，有发展前景的互联网工作内容，北京这座陌生的城市给我带来了无限的新鲜感。 但是，我的心理却一直充满了焦虑、担忧、不自信，好像这一切都会很容易失去，这导致我直到现在内心都无法完全安定下来。今天主要想说说从离职以来的心路历程，之前已经写过一次了，主要是叙事，主观思想和情绪很重，不幸因为刷机没备份，丢失了。这一次，将从内心出发，还原心路历程，好的坏的想法，尽量还原。 事情从在利楚林总找我谈话开始，快年末了，我还在每天机械的维护POS项目，那天晚上下班后在公司学习，林总找我聊天，当时我毫无准备，也没有认真思考过将来的计划与发展。他说了很多很多他的经历、想法，我感受到了真诚，也因此对他充满了尊敬和理解，我非常喜欢他，带我们聚餐、旅游、运动，没有架子，对技术很重视，没有办公室政治，唯一的缺点就是他为工作几乎付出了所有精力，所以后端的加班情况非常恐怖，这也是我离职的主要原因。我提出了想做全栈的想法（程序员应该都想吧），因此开始接触了后端的任务，我心怀期待，但并没有喜欢的情绪，应该是视野有限，在利楚后端比移动端更受重视，所以也觉得后端比现在的好。很顺利，我模仿的很快，虽然各种工具用的不一样，他们的相对落后，但是很快能理解基础的逻辑，再加上对sql略微熟悉，所以数据库也能基本使用。一切在一天加班到深夜的晚上发生了变化，我等到了接近3点大家才一起下班，林总11点走了之后，办公室里开始充斥着抱怨，抱怨公司，抱怨现在的工作，我也在抱怨，好像很喜欢讨论这个话题，仿佛被洗脑了，感觉这样下去公司一刻也呆不了了。之后他们，似乎所有人都觉得我出去闯荡一下更好，我自己也把这句话挂在嘴边，虽然现在看来结果是对的，但当时的我，根本没有自己的思想，没有思考过为什么，要得到什么，要怎么做。我不知道上海、杭州、北京、深圳…他们到底有什么区别，他们肯定比现在要好吧。 就这样年后我火速离职了，曾经觉得一天都离不开的工作，没了我一样在正常运转。去更好的地方是我一开始的目标，在武汉投递简历基本石沉大海，虽然面试的几家都很顺利的通过，但工资、公司环境和我期待的都相去甚远。就这样时间一天天流逝，投递到上海、北京、杭州的简历回应袅袅，在家中无所事事的时候，面对金三银四的招聘信息，面对同事不断的刺激，焦虑在我的内心一节节攀升。 机会总算来了，在小一届的校友内推下，我通过小作业进入了扇贝的面试阶段，扇贝位于南京的一处软件园，我满怀着期待，坐上开往南京的动车（车票很便宜160），还没到面试约定时间，我沿着干净的柏油路，参观了旁边的苏宁总部，途牛等等好多公司，正值午饭期间，路上年轻人来来往往，我似乎感受到了这种氛围，他们多好啊，薪酬丰富，说不定也像我一样来自五湖四海，在这里做着喜欢的事情，想加入他们的强烈渴望充斥我的脑海。路上还看到了一处高档别墅里面盛开的樱花，这些印象到现在都很深刻。开始面试了，前台姐姐好像因为刚刚下午的原因看起来有点疲惫，带我到楼上的会议室里，贴心的送上了一瓶矿泉水，非常非常感谢，我边填资料，边等待面试官。资料单上需要填写很多详细资料，在之前的面试中，涉及到家庭信息和隐私的，我一律不填，但这一次，我很渴望加入，每一处空格我都认真填上。填写资料的时候，窗外传来隐约的笑声，透过窗户看到他们的员工正在楼顶上户外活动，真好。面试官来了，两位，年轻，礼貌，一位拿着记事本记录，一位端着一台15寸的最新Mac，感受到了尊重。面试表现非常一般，很多基础知识掌握的都不好，基本上都是书上的，我也看过一遍，可能是因为我接触的点还比较多，他们问了很多简历上一些有趣的细节，就这样经历了两轮技术，一轮HR面，HR亲切的将我送下楼。至此，我内心里充满了期待，感觉有机会加入。 当天下午我怀着愉快的心情回到了武汉，开始等待结果。等待的几天里我越来越焦虑，三天是期限，第三天下午的时候，我到南湖帮助处理交换机和网络问题，解决完问题后就接到了HR的电话，通过了！！！8k、15薪、六险一金、体检、每天7点之前下班，问我什么时候可以入职，那天已经是周四，我便约定下周一，她告诉我offer还要等待最后的审批，让我等待邮件。经过一个月求职的折磨，我已经急切的想要和家人朋友分享这个信息。这个工资相当于之前的两倍了，我告诉了室友、爸爸妈妈、哥哥姐姐、同事，他们都很高兴，妈妈已经开始帮我准备行李了，所有的焦虑好像在这一刻化为乌有。但是，我从天堂跌到了地狱，第二天下午HR打电话给我，告知还要审核…我非常非常失望，愤怒。是的不知道是愤怒还是恼怒，这一次扇贝的面试，从内推简历通过小作业开始，到最后告诉我没通过，花费了接近20天，期间拒绝了武汉的offer，没有投递外地的简历。我异常的失落和愤怒了，感觉他们效率低下，每一个阶段的流程都要等到最后一天才告知我结果，甚至是我主动联系。而我，失去了这次宝贵的机会，失去了20天的时间，积攒了20天的焦虑和不安。 距离离职时间（2.29）已经过去快一个月了，马上又是清明节，在亲人，朋友面前我开始感到羞愧，过节明明有时间，也不想回老家去。接下来的一周里，我投遍了武汉的公司，收到面试机会的公司也越来越垃圾，好像失去了目标。没有办法，我只能被迫开始投递外地的公司，收到的回应开始多了起来，北京的居多，但我心里明白，必须要到北京参加面试才行。不断的刷着别人北漂的经历，我终于鼓起勇气了。我知道最差的情况，就是承担一周的房租+来回车票，大约2000元。就这样我怀着忐忑的心情来到了北京，之后的事情没想到却异常顺利。 最不想回忆、思考的部分是，自从扇贝的拒绝之后，我开始不信任招聘里所有的承诺，来到北京之后，快速发放的offer我一直都不敢完全接受，我的内心里好像一直在告诫自己，不要高兴的太早，这一切你随时都有可能失去。所以，我租房的时候小心翼翼，联系家里寄送东西的时候小心翼翼，花钱的时候更小心翼翼，甚至身份证上那张跟现在完全不像的照片都让我怀疑自己，上班的时候，我全力集中精神，害怕工作能力不被认可。还好家人的支持、同事的友好，让现在十分顺利。 一天天认真的工作，我慢慢踏实下来，明白了工作能力，技术水平才是竞争力的核心，可能是刚刚工作不久，求职的结果高低起伏差距甚大，但我相信，一步步踩下的脚印会让我收获应得的结果。"},{"title":"Android自定义锁屏页","date":"2017-12-13T12:24:07.000Z","updated":"2018-06-23T09:55:13.403Z","comments":true,"path":"未完成/custom-lock-screen.html","permalink":"https://haohaozaici.github.io/未完成/custom-lock-screen.html","excerpt":"","text":"自定义锁屏页类似于QQ音乐在锁屏、亮屏后显示完全自定义的锁屏内容。简单来说就是在锁屏之后收到锁屏广播，启动自定义锁屏Activity，同时取消系统锁屏（有密码时无法关闭），模拟滑动解锁，不是系统级的行为。"},{"title":"ARouter","date":"2018-04-23T06:09:25.000Z","updated":"2018-06-23T09:55:13.402Z","comments":true,"path":"未完成/ARouter.html","permalink":"https://haohaozaici.github.io/未完成/ARouter.html","excerpt":"","text":"ARouter典型应用 从外部URL映射到内部页面，以及参数传递与解析 跨模块页面跳转，模块间解耦 拦截跳转过程，处理登陆、埋点等逻辑 跨模块API调用，通过控制反转来做组件解耦 ARouter拦截器面向切面编程面向切面编程（AOP是Aspect Oriented Program的首字母缩写） ，我们知道，面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用。 但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来。 也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。 一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。"},{"title":"Java Servlet","date":"2017-12-19T07:12:41.000Z","updated":"2018-06-23T09:55:13.403Z","comments":true,"path":"未完成/java_servlet.html","permalink":"https://haohaozaici.github.io/未完成/java_servlet.html","excerpt":"","text":"Java Servlet Http Servlet处理http请求 会话管理 URL重写 隐藏域 Cookies HttpSession对象 JSP (JavaServer Page)JSP 标签、listener、Filters异步处理、异步监听区分耗时任务与异步处理 安全声明性安全 对称加密 RSA非对称加密 通过HTTPS和安全证书构建安全通道，SSL再通过对称加密高速传输信息，MD5校验数据准确性和完整性。"}],"posts":[{"title":"「播放器」Android视频开发介绍","slug":"Android-video-player","date":"2018-08-01T10:05:07.000Z","updated":"2018-08-01T11:55:04.941Z","comments":true,"path":"2018/08/01/Android-video-player/","link":"","permalink":"https://haohaozaici.github.io/2018/08/01/Android-video-player/","excerpt":"","text":"移动端流媒体随着各种视频app的火爆，以及移动流量的升级逐渐占据人们大量宝贵的时间。但是从开发小白的角度来看，这一直是个很有难度的开发领域，真正深度接触视频业务的app也不多，恰好有了浅度的需求，往往又会花费大量的时间了解、踩坑。「播放器」系列文章的目的，就是想完成一个「还可以的」实践，读完文章也能达到实践的程度。基于ijkplayer这篇文章更多的是总体的介绍，会随着理解加深不断更新。 0 播放器基本原理首先简单了解一下播放器的基本原理和结构。 主要包含以下几个步骤： 数据接收(数据获取、解协议) 解封装(demux) 解码 音视频同步（图中没有） 输出 解封装：将多个轨道的数据分解出来，比如一个mp4格式的文件解封装后输出H.264编码的视频流、aac编码的音频流解码：将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据 结合上面的结构来看，客户端的视频开发主要包含了：视频源、播放器、业务场景几个部分，下面逐个进行分析。 1 视频源视频源决定了传输协议、封装格式、编码类型，影响着播放器内核的选择、支持格式的拓展，以及加解密。一般来说播放器开发时视频源都是已经确定了的，我目前使用的视频源主要是HLS（m3u8 + ts），部分使用MP4封装，H.264 AAC编码，ijkplayer和ExoPlayer都支持良好。 传输协议：hls，crypto加密 封装格式：ts切片 编码类型：H.264 AAC M3U8视频源的加解密视频源的加解密环节也相当重要，项目中m3u8文件和hxk key都进行了加密，需要通过接口获取并解密，标准的hls协议并不支持，其中m3u8文件经过解密后可直接使用，但hxk文件是在播放器内部实现hls协议时处理的，如果不修改native代码的话，就需要自定义hxk文件获取的过程。加解密的过程会单独开文章分析。 视频源也可以叫DataSource、MediaSource，包含了众多的分类，如果想要详细了解可以参考exoplayer的实现。 2 播放器播放器要完成获取视频流、解码、输出到屏幕，最后还要提供丰富的功能，这一系列的操作主要由MediaPlayer、SurfaceView、Controller和相关功能模块组成，下面逐一介绍。 MediaPlayer：负责音视频流的获取、解码、输出、状态控制。 SurfaceView：负责解码后视频帧的显示（大小、比例、方向等）。如SurfaceView、TextureView、GLSurfaceView，项目中主要使用TextureView Controller：播放器相关的功能控制。进度条、手势操作、播放速度、画面显示比例、屏幕锁等 其他功能：如音频焦点、屏幕常亮、后台播放、旋转、状态栏控制等 MediaPlayer对于MediaPlayer来说，以下能力非常关键： 网络能力：支持各种预期的协议，如完整的支持hls各种特性，有良好的网络能力，如各种拉流的控制、容错 解码能力：能够支持预期的格式（点播时，视频格式通常都是确定的几种），不能（不适合）硬解时提供软解 兼容性：在各种设备上的解码能力和解码策略 功能特性：播放速度（变速不变调）、精准seek、max-fps、缓冲区大小（基于FFmpeg） 信息反馈：返回准确丰富的状态信息、错误信息 MediaPlayer的能力是播放器的基础，这个环节ijkplayer等都已经实现（网络功能直接集成在内部），我们主要是理解相关api的效果和如何使用。除此之外，通过接口，我们还可以使用不同的mp，不过不同的mp功能特性差别很大，实际项目中还是要使用综合考虑最优秀的。 Surface接下来是视频的显示，常用的主要是SurfaceView、TextureView两种，如果要添加特效、滤镜之类的则需要用到opengl。对于视频的显示来说，以下能力非常关键： 切换前后台的流畅度（在有些设备上Surface会被销毁重建） 对软硬解的兼容（比如软解+TextureView，重复使用TextureView会出现被锁住的情况） 旋转、缩放、平移综合来看大家最终都选择了TextureView，同样的也可以使用接口来使用不同的surface SurfaceView和TextureView的比较已经有了很丰富的资料，这里简单介绍下在视频播放中主要的差别： SurfaceView的实现是在屏幕上“挖洞”，在Android N以下版本界面移动时会有很严重的黑边 SurfaceView播放效率略高于TextureView TextureView可以使用view的各种方法，比如说matrix 到这里VideoView就诞生了，mediaplayer + surface组合成了VideoView核心部分，和音频播放不同，mediaplayer 和 surface之间既独立又充满联系，他们之间的配合和影响后面单独开文章分析。 Controller复习一下，Controller负责播放器相关的功能控制，如进度条、手势操作、播放速度、画面显示比例、屏幕锁、切换清晰度等。也就是这个画面。 针对视频播放，系统提供了MediaController类给我们使用，但是自定义性差，还非常丑。。。不过却提供了很好的与VideoView一起协作的示例，完全可以copy一份，然后根据需求修改。针对横屏和竖屏一般会有两套Controller，所以这里我们也使用接口，既满足和VideoView的交互，又可以随时替换不同的实现。 Controller已经是我们需要开发的核心部分了，比如手势控制、沉浸式下显示popup window等，可以单开一篇来介绍，这里就不细说，也可以在demo中查看效果和具体实现。 丰富的功能只使用VideoView进行播放的场景估计只有广告了^_^，所以除了基础的控制功能之外，我们还要提供丰富的功能来提升使用体验，比如音频焦点、屏幕常亮、后台播放、旋转、悬浮窗、网络状态切换、状态栏控制，这一部分大多数需要与播放器的状态关联，同时较少或者几乎没有涉及到业务逻辑，也是开发的核心部分。与上面一样，很多细节都可以单开一篇来介绍，后续会逐渐完善。 至此可以看到播放器的部分和业务的交集很小，很容易整理成lib，将与UI无关的部分抽象出来，与UI、业务依赖多的部分也可以提供默认的实现以供参考。 3 业务场景上面的内容好像将播放器几乎都涵盖了，但实际上缺少了非常重要的一个环节，业务场景。我非常认同这个的观点，我们要做懂技术，也懂行业、懂业务的人。 所以呢，这个部分我们会简单讨论一下当前热门的视频应用和他们实现的效果，然后我们进行仿写。业务范围： 单视频点播：参考APP：bilibili、爱奇艺，特点：弹幕、播放详情页面、后台播放、播放详情页面、播放列表 离线播放 feed流：参考APP：bilibili weibo 网易云音乐 短视频 小窗播放：参考APP：youtube，特点：小窗口view、画中画 直播：参考APP：bilibili，特点：直播、悬浮窗 此外还有一个特别重要部分：视频编辑（还包括直播推流、特效等），因为暂时没有接触，这部分不会涉及。 敬请期待~","categories":[{"name":"Android","slug":"Android","permalink":"https://haohaozaici.github.io/categories/Android/"}],"tags":[]},{"title":"ConstraintLayout「最全总结」","slug":"ConstraintLayout","date":"2018-07-11T06:14:50.000Z","updated":"2018-07-12T03:25:31.879Z","comments":true,"path":"2018/07/11/ConstraintLayout/","link":"","permalink":"https://haohaozaici.github.io/2018/07/11/ConstraintLayout/","excerpt":"","text":"现在大家几乎都使用过ConstraintLayout，但与经常使用的布局相比，可能会面临不熟悉CL的API或者是逐渐增加的新特性，还有可能因为对CL具体行为的理解模糊而导致误用，这篇文章的目的更多的是，全面总结ConstraintLayout的用法和实际行为特性，并不断更新 基于ConstraintLayout 1.1，当前2.0版本处于测试阶段参考文章：ConstraintLayout入门指南 为什么要引入ConstraintLayout 减少布局层级：常用的布局划分成了几个不同的类型，要组合不同的功能需要通过嵌套的形式实现，比如想要按比例布局就要使用layout_weight属性，想要使用layout_weight属性就要使用LinearLayout（以下简称LL）或者TableLayout，然后你在原先同级的每个布局外再嵌套一层布局以使用layout_weight。 更多的布局需求：要实现固定宽高比、百分比布局，灵活控制大小等更高阶的布局需求，原先的各类布局方式都不能很好的支持，可能需要通过Java代码，在运行中二次实现。 想要通过ConstraintLayout来 优化性能，可能并不明显 亦或者你只是想尝试下这款Andorid官方力推的新布局，看看它有什么新特性。 引入lib:1234//确保SDK Tools中已经下载了ConstraintLayout的支持库：dependencies &#123; implementation 'com.android.support.constraint:constraint-layout:1.1.2'&#125; 开始之前，我们应该意识到在布局文件中Layout主要职责是什么，控制widgets的位置和大小。下面将从这两个方向出发，看看ConstraintLayout是怎么做的。 1. 控制位置layout中的view都有四个方向left(start), right(end), top, bottom，通过这些方向在两个view之间建立约束来实现基础的位置控制，相对于RelativeLayout，RL中所有的属性CL中都有与之对应的项目，稍加熟悉即可完成转换： 相对于父布局的相对布局属性，CL的规则是：将父布局当做一个id=”parent”的对象来对待： 1.1 Margins设置普通的margin： 1.2 visibility 对约束的影响特殊的情况是：连接到visibility为GONE的view时的margin，在ConstraintLayout中，当widgets被设置View.GONE时进行了特殊处理。 根据布局的传递，设置为GONE的view相当于大小被设置为0(实际上是被设置成了一个点) 如果他们已经跟其他的组件产生了约束关系，约束关系还是会存在，但是所有的margin都会变成0 也可以使用goneMargin来保持预期的边距 这种特殊的处理，可以在你临时的把view设置为GONE时，不破坏布局结构。 1.3 居中和偏移居中的设置参考之前于RelativeLayout的对应关系，CL增加了偏移属性，使用偏移可以更好的处理屏幕大小改变时的情景。 布局中设置：123456&lt;android.support.constraint.ConstraintLayout ...&gt; &lt;Button android:id=\"@+id/button\" ... app:layout_constraintHorizontal_bias=\"0.3\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent/&gt;&lt;/&gt; 1.4 圆形的位置使用圆形约束，在创建圆形的菜单时非常有用 12345&lt;Button android:id=\"@+id/buttonA\" ... /&gt;&lt;Button android:id=\"@+id/buttonB\" ... app:layout_constraintCircle=\"@+id/buttonA\" app:layout_constraintCircleRadius=\"100dp\" app:layout_constraintCircleAngle=\"45\" /&gt; 2. 控制尺寸(大小)2.1 给ConstraintLayout自己添加大小限制当ConstraintLayout的大小设置为WRAP_CONTENT时，可以很方便的设置自己的最大宽高 2.2 Widgets的尺寸(大小)约束和我们在常用的布局中设置宽高一样，控制Widgets的宽度和高度一共有3种方式： 固定的大小，如123dp WRAP_CONTENT 自适应 0dp，等于MATCH_CONSTRAINT，类似于match_parent，会利用所有可用的空间。注意，不建议使用match_parent 2.3 WRAP_CONTENT 强制约束默认情况下，设置为WRAP_CONTENT的组件不会限制他们的大小，有时会导致超出约束条件的情况，如果需要强制他们满足约束条件的话，使用下面的强制约束12app:layout_constrainedWidth=&quot;true|false&quot;app:layout_constrainedHeight=&quot;true|false&quot; 2.4 MATCH_CONSTRAINT 大小控制默认情况下，MATCH_CONSTRAINT 会利用所有可用的空间，通过下面的设置，可以自定义具体的行为 layout_constraintWidth_min and layout_constraintHeight_min layout_constraintWidth_max and layout_constraintHeight_max layout_constraintWidth_percent and layout_constraintHeight_percent 使用百分比大小时，对应方向的大小必须设置为 MATCH_CONSTRAINT 2.5 使用比例使用比例有两种情况，而且必须至少有一条边被设置为0dp： 如果只有一条边被设置为0dp，设置比例时，将参考另外一条已经确定尺寸的边 如果两条边都被设置为0dp，那么会在满足比例的条件下，设置为最大尺寸 同样的支持直接设置layout_constraintWidth_percent和layout_constraintHeight_percent来使用百分比控制相对于parent的比例1234567891011121314&lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"0dp\" app:layout_constraintDimensionRatio=\"1.6\" /&gt;&lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"0dp\" app:layout_constraintDimensionRatio=\"1:1\" /&gt;&lt;Button android:layout_width=\"0dp\" android:layout_height=\"0dp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintDimensionRatio=\"H,16:9\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; 2.6 ChainsChains能自定义在同一轴线上view的位置和大小，首先我们来创建一条链，当widgets之间在同一个方向上相互连接(相互约束)时，链就形成了。 2.6.1 链的head水平方向chain最左边的控件和垂直方向chain最顶部的控件被成为head chain。通过对head chain添加chainStyle属性，可以设置该条chain在水平或垂直方向上的chainStyle 2.6.2 Chain Style12layout_constraintHorizontal_chainStylelayout_constraintVertical_chainStyle chainStyle属性一共有三种：spread、spread_inside、packed。再配合其他属性，最终可以组成五种chain style： 其他四种chain style的设置和效果都比较简单，重点介绍下Weighted Chain。 默认的spread模式，每个元素获得同样的空间，如果一个元素使用了0dp，将会占用剩下的所有可用空间 layout_constraintHorizontal_weight和layout_constraintVertical_weight可以用来控制同样设置为0dp的控件的比例 Weighted Chain中的控件也允许在chain方向上使用wrap_content自适应控件宽/高，且布局时优先满足设置为wrap_content的控件，相当于优先满足设置了指定宽高的控件 当设置了margin时，margin生效的同时weight的比例不变，链上的控件实际占有布局会被压缩 3. 不可见的辅助工具GuidelinebarrierGroup4. 用代码的方式操作ps. 选择优化类型Package Index:android.support.constraintandroid.support.constraint.helperandroid.support.constraint.motionandroid.support.constraint.utils","categories":[{"name":"Android","slug":"Android","permalink":"https://haohaozaici.github.io/categories/Android/"}],"tags":[]},{"title":"「播放器」处理界面旋转","slug":"player-orientation","date":"2018-06-11T11:49:06.000Z","updated":"2018-06-12T02:43:35.541Z","comments":true,"path":"2018/06/11/player-orientation/","link":"","permalink":"https://haohaozaici.github.io/2018/06/11/player-orientation/","excerpt":"","text":"屏幕旋转是开发播放器过程中大家都会实现的基础功能，简单的说，就是视频播放画面跟随手机的方向旋转，达到比较好的用户体验。但是细节往往决定成败┐(ﾟ～ﾟ)┌。我主动点击了全屏按钮屏幕会不会自己又转回来了？两个方向横屏的情况点击回到竖屏处理的是不是正确的？blablabla…今天就好好把这一切捋清楚&lt;(￣︶￣)&gt; 这篇文章的目的是：如果你对屏幕旋转逻辑不够清晰，还对屏幕旋转的功能细节不够满意的话，一起来将整个逻辑思考清楚吧。 基础回顾 通过activity.setRequestedOrientation(@ActivityInfo.ScreenOrientation)方法实现控制界面的方向 通过OrientationEventListener(activity)来监听屏幕方向(角度)的变化 就这么简单，就这一个方法和一个监听器。旁白君：这么简单还讲毛线哇 (⊙ˍ⊙)，散了散了…！！！大家慢走，的确就这两个东东，但还要组合4个方向，两个操作，两个状态，还有balabala… 旁白君：有人装神弄鬼啦，大家快走！。 哈哈，言归正传~这些状态和操作一开始组合起来真的把我弄晕了，不过冷静下来思考之后，回归了简单。 情景分析首先看看手机方向示意图： 为什么会弄晕我，大家来看看下面的细节，由浅入深： 屏幕跟着手机旋转 在竖直方向点击横屏后，屏幕方向保持横向，不会自动转回来（同时也适用于横向的情况） 反向横屏的时候，点击竖屏，应该回到正向竖屏。反向竖屏的时候，点击横屏应该回到”正向”横屏。（保证都能回到正向竖屏，同时保持协调） 在2和3的条件下，比如在竖直方向点击横屏后，屏幕方向保持横向，然后手机屏幕旋转到横向后，再旋转到竖向时，屏幕应该跟随手机旋转到竖向。（相当于旋转到期望状态后，限制就自动解除） 在以上逻辑的前提下，旋转屏幕，手机应正常保持跟随旋转。（只限制应该限制的方向） 没这么复杂啊，你是不是在糊弄我？。。。咳咳，真的不是我太纠结，追求完美是吧。那么这些逻辑哪里复杂了？哪些条件又存在冲突呢。 矛盾的点： 「横屏、反向横屏」，「竖屏、反向竖屏」时，点击恢复按钮都需要都需要恢复到”正向”状态，且旋转后不能立刻恢复。 限制条件启动后，除了限制旋转的方向外，手机应正常保持跟随旋转 限制条件启动后，在旋转到期望状态后，解除限制 这里横向的”正方向”不重要，顺时针和逆时针都行。矛盾的关键就是： 正向时点击产生的限制与手机应正常保持跟随旋转 反向时点击产生的限制与手机应正常保持跟随旋转 限制与解除限制 正确的思路为了保证不先把我自己弄晕，直接来看正确的思路。o(￣▽￣)ｄ 切记不能跟着条件一个个满足，这就会进入矛盾的漩涡，解决了这个对立的那个又不满足了。 处理旋转逻辑的思路： 准确的知道当前方向（当前方向不能作为标志保存，必须实时获取） 保存点击时的方向，提供限制 旋转到非限制方向时，解除限制 这就好办了，首先我们完成最基础的，跟随手机的角度旋转屏幕： 再加上点击后屏幕旋转到竖(横)向正方向的功能： 注意开启功能1orientationEventListener.enable(); 这个时候我们会发现问题，没有满足这个条件：1在竖直方向点击横屏后，屏幕方向保持横向，不会自动转回来（同时也适用于横向的情况） 记住原来的教训：不能跟着条件一个个满足。问题的根本是我们要提供限制，并且在旋转到非限制方向时，解除限制。限制是什么，是我们不能旋转回原来的方向，所以我们记录下了点击时的方向：1mOldScreenRotation = activity.getWindowManager().getDefaultDisplay().getRotation(); 那什么时候解除限制呢，旋转到非原始方向时就解除限制1234567891011121314151617181920212223242526272829303132333435363738394041424344mScreenRotation = activity.getWindowManager().getDefaultDisplay().getRotation();// 自动竖屏if (((rotation &gt;= 0) &amp;&amp; (rotation &lt;= 15)) || (rotation &gt;= 345)) &#123; if (mOldScreenRotation != Surface.ROTATION_0) &#123; //解除限制 mOldScreenRotation = -1; //-1不代表任何方向 &#125; if (mScreenRotation == Surface.ROTATION_0 || (mOldScreenRotation != -1)) &#123; //当前的角度和屏幕方向一致，不处理 //没有旋转到非原始方向，被限制 return; &#125; activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);&#125;// 自动反向横屏else if (rotation &gt; 75 &amp;&amp; rotation &lt; 105) &#123; if (mOldScreenRotation != Surface.ROTATION_270) &#123; mOldScreenRotation = -1; &#125; if (mScreenRotation == Surface.ROTATION_270 || (mOldScreenRotation != -1)) &#123; return; &#125; activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);&#125;// 自动反向竖屏else if (rotation &gt; 165 &amp;&amp; rotation &lt; 195) &#123; if (mOldScreenRotation != Surface.ROTATION_180) &#123; mOldScreenRotation = -1; &#125; if (mScreenRotation == Surface.ROTATION_180 || mOldScreenRotation != -1) &#123; return; &#125; activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);&#125;// 自动横屏else if (((rotation &gt;= 255) &amp;&amp; (rotation &lt;= 285))) &#123; if (mOldScreenRotation != Surface.ROTATION_90) &#123; mOldScreenRotation = -1; &#125; if (mScreenRotation == Surface.ROTATION_90 || (mOldScreenRotation != -1)) &#123; return; &#125; activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);&#125; 注意Surface.ROTATION_270和onOrientationChanged(int rotation)的角度正好是相反的","categories":[{"name":"播放器","slug":"播放器","permalink":"https://haohaozaici.github.io/categories/播放器/"}],"tags":[]},{"title":"「播放器」Mac上编译ijkplayer so支持HTTPS","slug":"build-ijkplayer","date":"2018-06-07T08:02:19.000Z","updated":"2018-07-11T12:29:44.559Z","comments":true,"path":"2018/06/07/build-ijkplayer/","link":"","permalink":"https://haohaozaici.github.io/2018/06/07/build-ijkplayer/","excerpt":"","text":"当项目中使用ijkplayer，而且还需要播放HTTPS链接的视频时，就比较蛋疼了 (￣.￣)，ijkplayer默认不支持HTTPS播放，但提供了编译OpenSSL的选项，可以自己编译so文件支持HTTPS播放。这篇文章的目的是引导不熟悉的人完成整个编译过程，提醒过程中的注意事项，还有各种选项的解释。 我的编译环境VMware + Ubuntu编译环境也可以参考，基本上只有命令不同，homebrew的安装这里不再赘述。非常不建议在Windows环境下编译！123456Mac 10.13.2iTerm2 + zshHomeBrewNDK r10eNDK + 编译所有so大概需要10GB空间 相关链接: Bilibili/ijkplayer IJKPlayer编译so支持HTTPS的踩坑历程 ijkplayer编译so库真没那么难 1. 准备工作安装Git与yasm12brew install gitbrew install yasm 配置SDK、NDKSDK都会有，NDK一般没有下载，建议去官网下载:https://developer.android.google.cn/ndk/downloads/older_releases 需要注意的是最好下载官方lib使用的NDK r10e，使用其他版本的将无法编译。具体原因可以参考这篇issue SDK、NDK和准备完成后，在.bash_profile, 或者是.zshrc中添加配置。(Command + shift + . 显示隐藏文件) 123456// 注意替换为自己的文件路径export ANDROID_SDK=/Users/haoyuan/Library/Android/sdkexport PATH=$ANDROID_SDK/platform-tools:$PATHexport PATH=$ANDROID_SDK/tools:$PATHexport ANDROID_NDK=/Users/haoyuan/Library/Android/android-ndk-r10eexport PATH=$ANDROID_NDK:$PATH 添加完成后，保存文件，然后source .bash_profile等相关文件，或者直接重启终端，通过 ndk-build -v 检查是否生效 clone ijkplayer源码123git clone https://github.com/Bilibili/ijkplayer.git ijkplayer-androidcd ijkplayer-androidgit checkout -B latest k0.8.8 2. 编译之前编译前选择你的配置选择自动化编译时的一些配置选项，比如支持的协议，音视频类型等，官方给我们提供了三个模板。 可以打开config/目录下config/module.sh看看，enable启用，disable禁用123module-default.shmodule-lite-hevc.shmodule-lite.sh 官方默认建议选择的是 module-lite.sh，可以根据自己的需求选择123cd configrm module.shln -s module-lite.sh module.sh 如果要选择module-default.sh的话，可能会编译失败，可以参考这篇issue123仔细阅读module-lite.h 原来在最下面有一行配置：export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --disable-linux-perf&quot;把这行复制到module-default.sh 的最后面就可以了 在编译配置中可以增减需要的模块，选择需要支持的封装格式、编解码类型、协议能有效减小so库的体积。可以参考CarGuo/GSYVideoPlayer DECODERS.md 3. 开始编译ヽ(｀⌒´)ﾉ执行初始化\b初始化会下载各种包，尽量选择在良好的网络环境下╮(￣▽￣)╭12cd .../init-android.sh 初始化OpenSSL1./init-android-openssl.sh 编译OpenSSL和FFmpeg首先清除一波123cd android/contrib./compile-openssl.sh clean./compile-ffmpeg.sh clean 编译OpenSSL：可以选择不同版本，全量编译耗时更长，但最好选择全量编译，编译完成后再根据需求选择要使用的包。1./compile-openssl.sh all 编译FFmpeg，同样的123./compile-ffmpeg.sh all// 如果要选择特定的架构: ./compile-ffmpeg.sh armv7a | armv5 最后编译ijkplayer1./compile-ijk.sh all 经过漫长的等待终于完成了以上编译过程\\（￣︶￣）/，在目录中生成了ijkplayer的工程 4. 导入项目原有的项目一般是这样配置的12implementation &apos;tv.danmaku.ijk.media:ijkplayer-java:&apos; + gradle.ijkplayer_javaimplementation &apos;tv.danmaku.ijk.media:ijkplayer-armv7a:&apos; + gradle.ijkplayer_java 如果只需要修改so库的话，删除掉第二行对so库的引用，将自己编译好的so文件复制到项目的libs文件夹中。 别忘了在gradle中配置，要不然会报错找不到so库 还可以在release包中设置abi过滤 最后大功告成啦\\(^o^)/ 尾巴… 如果项目中同时使用了HTTP和HTTPS的视频源的话，要注意如果视频源刚好是相同域名，会导致播放失败，这是由于dns缓存造成的，解决办法参考这篇issue初始化IjkMediaPlayer时，设置清除dns cache1234567IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;dns_cache_clear&quot;, 1//还要注意开启相关支持的协议IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;protocol_whitelist&quot;, &quot;async,cache,crypto,file,http,https,ijkhttphook,ijkinject,ijklivehook,ijklongurl,ijksegment,ijktcphook,pipe,rtp,tcp,tls,udp,ijkurlhook,data&quot;","categories":[{"name":"Android","slug":"Android","permalink":"https://haohaozaici.github.io/categories/Android/"}],"tags":[]},{"title":"「播放器」Android音频焦点","slug":"Android Sound overlap","date":"2018-04-24T11:22:02.000Z","updated":"2018-08-01T11:44:32.987Z","comments":true,"path":"2018/04/24/Android Sound overlap/","link":"","permalink":"https://haohaozaici.github.io/2018/04/24/Android Sound overlap/","excerpt":"","text":"音视频播放在手机日常使用中非常频繁，当我们听着音乐刷着微博时，看到有趣的视频点击开始播放，音乐自动暂停，退出视频时音乐又自动恢复了播放(如果没有自动恢复的话，比如QQ音乐就会提示是否设置中断后继续播放)。 这一系列流畅自然的操作不是理所应当的吗~当然如果处理不好的话就会出现声音重叠，音频焦点长期被占用的问题，下面我们来看看具体的功能逻辑。 音频焦点相关的讲解参考以下文章 Android音频焦点详解Managing Audio Focus Managing Audio Focus不同的APP可以同时播放音频，系统会将他们混合在一起，但为了避免同时播放，Android提供了audio focus机制来合理使用音频播放资源。同一时间只能有一个APP获取音频焦点，当需要播放音频时，应该立即请求音频焦点，同样的，在你的APP获取到音频焦点后，其他APP也可以抢占音频焦点，这时你的APP就需要暂停播放或降低声音。音频焦点是合作类型的，APP拥有完全自主的控制权，系统无法阻止，但应用应该遵守音频焦点的指导规则。 好的音频APP在播放时应该遵守以下规则： 开始播放后立即调用requestAudioFocus()方法，并验证返回值为AUDIOFOCUS_REQUEST_GRANTED 当其他app占用音频焦点时，暂停或停止播放，或者降低声音 当播放停止时，放弃音频焦点 在不同的Android版本下，需要使用不同的方法来处理音频焦点： API level 8以后，使用requestAudioFocus()和abandonAudioFocus()方法，并注册AudioManager.OnAudioFocusChangeListener接收回调。 API level 21以后，需要使用AudioAttributes来描述播放音频的类型。 API level 26以后，需要使用AudioFocusRequest参数，它携带了音频的context和相关功能，系统会根据这些自动管理音频焦点。 Android8.0以前参考官方文档获取焦点的方法如下： 123456// Request audio focus for playbackint result = am.requestAudioFocus(afChangeListener, // Use the music stream. AudioManager.STREAM_MUSIC, // Request permanent focus. AudioManager.AUDIOFOCUS_GAIN); 但在听音乐的时候播放音频或视频，依旧出现了重叠的声音，实际上有效的做法是这样的12345//下面两个常量参数试过很多 都无效，最终反编译了其他app才搞定，汗~ int requestFocusResult = mAudioManager.requestAudioFocus( mAudioFocusChangeListener, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN_TRANSIENT); 具体参考文章Android MediaPlayer音频焦点问题，抢占声道 最后在对应的播放状态下获取和释放音频焦点。 Android8.0之后和之前一样，Android8.0中也使用了requestAudioFocus()来请求音频焦点，不一样的是，使用abandonAudioFocusRequest()释放音频焦点，并且请求和释放都需要传入同一个AudioFocusRequest实例。使用AudioFocusRequest.Builder来创建，具体实现代码参考官方文档Audio focus in Android 8.0 and later。 123456789101112mAudioFocusRequest = new AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN) .setAudioAttributes(new AudioAttributes.Builder() .setUsage(AudioAttributes.USAGE_MEDIA) .setContentType(AudioAttributes.CONTENT_TYPE_MOVIE) .build()) .setAcceptsDelayedFocusGain(true) .setOnAudioFocusChangeListener(mAudioFocusChangeListener) .build();//请求音频焦点 requestFocusResult = mAudioManager.requestAudioFocus(mAudioFocusRequest);//释放音频焦点abandonFocusResult = mAudioManager.abandonAudioFocusRequest(mAudioFocusRequest); 注意事项： Android8.0中其他APP使用AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK参数获取焦点时，将不会回调本APP的onAudioFocusChange()方法。 焦点延迟获取，当焦点被其他APP“锁”住时，requestAudioFocus()会返回AUDIOFOCUS_REQUEST_FAILED，比如正在打电话时，焦点就会被锁住。如果使用了setAcceptsDelayedFocusGain(true)方法，请求将会返回AUDIOFOCUS_REQUEST_DELAYED，在锁解除后，系统会继续处理未完成的焦点请求，并回调onAudioFocusChange()方法。 处理音频焦点变化了解相应的请求、释放方法后，还需要进一步处理音频焦点变化问题，也就是优化跟其他APP或者是系统APP合作的过程。主要是处理onAudioFocusChange方法：12345678910111213141516171819202122232425262728293031323334private AudioManager.OnAudioFocusChangeListener mAudioFocusChange = new AudioManager.OnAudioFocusChangeListener() &#123; @Override public void onAudioFocusChange(int focusChange) &#123; switch (focusChange)&#123; case AudioManager.AUDIOFOCUS_GAIN: //当其他应用申请焦点之后又释放焦点会触发此回调 //可重新播放音乐 Log.d(TAG, \"AUDIOFOCUS_GAIN\"); start(); break; case AudioManager.AUDIOFOCUS_LOSS: //长时间丢失焦点,当其他应用申请的焦点为AUDIOFOCUS_GAIN时， //会触发此回调事件，例如播放QQ音乐，网易云音乐等 //通常需要暂停音乐播放，若没有暂停播放就会出现和其他音乐同时输出声音 Log.d(TAG, \"AUDIOFOCUS_LOSS\"); stop(); //释放焦点，该方法可根据需要来决定是否调用 //若焦点释放掉之后，将不会再自动获得 mAudioManager.abandonAudioFocus(mAudioFocusChange); break; case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT: //短暂性丢失焦点，当其他应用申请AUDIOFOCUS_GAIN_TRANSIENT或AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE时， //会触发此回调事件，例如播放短视频，拨打电话等。 //通常需要暂停音乐播放 stop(); Log.d(TAG, \"AUDIOFOCUS_LOSS_TRANSIENT\"); break; case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK: //短暂性丢失焦点并作降音处理 Log.d(TAG, \"AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK\"); break; &#125; &#125; &#125;; 最后音频相关的API常常让人疑惑，明明已经根据注释的描述和官方文档中的方法实现了，却达不到预期的效果。还有就是随着Android更新的推送速度越来越快，更新普及率也水涨船高，高版本API随时在发生变化，适配时需要注意这些细节，以及进行完善的测试。 工具类参见AudioFocusManager 未完成内容源码简单分析 在不同机型中进行测试","categories":[{"name":"Android","slug":"Android","permalink":"https://haohaozaici.github.io/categories/Android/"}],"tags":[]},{"title":"创建和销毁对象","slug":"create-and-destroy-objects","date":"2017-12-19T07:12:41.000Z","updated":"2017-12-29T15:17:35.184Z","comments":true,"path":"2017/12/19/create-and-destroy-objects/","link":"","permalink":"https://haohaozaici.github.io/2017/12/19/create-and-destroy-objects/","excerpt":"","text":"创建和销毁对象静态工厂方法代替构造器静态工厂方法与设计模式中的工厂方法不同。 优势 静态工厂方法有名称， 遇到多个构造器参数时，使用构建器-Builder模式1.使用构造方法创建对象重叠构造器 2.JavaBeans模式通过setter方法设置必要参数，拥有良好的可读性。缺点：构造过程中容易被改变，处于不一致的状态。 3.Builder模式通过公开的Builder内部类，私有的构造方法，构造必传参数和可选参数。Builder模式模拟了具名的可选参数，可以加强约束条件，在对象域中进行检验。可以在编译时进行异常检查。 缺点：特殊情况下额外的性能开销，冗长。适用情况：多个参数(大于4个)，需要比JavaBeans模式更加安全的情况。 参见 Notification 或 Alertdialog类。 用私有构造器或者枚举类型强化singleton属性为了防止反射调用私有构造方法、反序列化时创建新的实例，直接使用 包含单个元素的枚举类型. 12345public enum Elvis&#123; INSTANCE; ...&#125; 避免创建不必要的对象39条 应该创建新对象时，不要重用现有对象创建不必要的对象只会影响程序的风格和性能，没有实施保护性拷贝将会导致潜在的错误和安全漏洞。 消除过期的对象引用内存泄露","categories":[{"name":"Java","slug":"Java","permalink":"https://haohaozaici.github.io/categories/Java/"},{"name":"Effective Java","slug":"Java/Effective-Java","permalink":"https://haohaozaici.github.io/categories/Java/Effective-Java/"}],"tags":[]},{"title":"Mifare 1k S50卡","slug":"M1 card","date":"2017-12-13T08:41:43.000Z","updated":"2018-04-20T02:05:08.000Z","comments":true,"path":"2017/12/13/M1 card/","link":"","permalink":"https://haohaozaici.github.io/2017/12/13/M1 card/","excerpt":"","text":"背景：最近的项目中涉及到读写M1卡，之前完全没接触过一脸懵逼，却没意识到，生活中常用的公交卡、门禁卡、开水卡、会员卡等等大多数都是M1类的射频卡，如Mifare 1k S50系列。熟悉了相关知识后，发现原理如此简单，感谢开源也因此能做很多方便的事情了。记录一下，面对陌生的事物不要害怕，了解熟悉，探索乐趣。 基础知识M1卡M1卡结构 从上面可以看到，扇区0 块0固化了厂家代码，32位16进制数，一般作为ID使用。 每一个扇区的块3用于保存KEY A,存取控制,KEY B，除了扇区0的块0之外的其他的块0~块2都用于存储数据。KEY A不可读、可写，KEY B可读可写. 一般的门禁卡中，不存储任何数据，门禁系统只读取卡ID，学校里使用的开水卡，一般是离线使用，卡的余额或者使用次数是存储在卡中的，使用时进行读写。在武汉通中，存储了卡余额，储值、消费记录，具体的余额存储在服务器上。所以理论上可以模拟卡ID来模拟门禁卡，或者是读取修改水卡值来修改卡。 读写卡工具MIFARE Classic Tool, MifareClassicTool - GitHub 模拟卡工具NFC卡模拟 相关文章Mifare 1k S50 卡的简单探讨与破解","categories":[{"name":"生活","slug":"生活","permalink":"https://haohaozaici.github.io/categories/生活/"},{"name":"乱七八糟的技巧","slug":"生活/乱七八糟的技巧","permalink":"https://haohaozaici.github.io/categories/生活/乱七八糟的技巧/"}],"tags":[]}]}