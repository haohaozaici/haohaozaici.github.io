{"meta":{"title":"haohaozaici","subtitle":"haohaozaici的博客","description":"haohaozaici的博客","author":"haohaozaici","url":"https://haohaozaici.github.io"},"pages":[{"title":"分类","date":"2017-02-23T16:28:59.000Z","updated":"2017-02-23T16:29:57.757Z","comments":false,"path":"categories/index.html","permalink":"https://haohaozaici.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-02-23T16:16:55.000Z","updated":"2017-02-23T16:30:04.951Z","comments":false,"path":"tags/index.html","permalink":"https://haohaozaici.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"PermissionsDispatcher处理android 6.0+运行时权限","slug":"PermissionsDispatcher","date":"2017-03-03T02:50:28.000Z","updated":"2017-03-03T03:24:33.571Z","comments":true,"path":"2017/03/03/PermissionsDispatcher/","link":"","permalink":"https://haohaozaici.github.io/2017/03/03/PermissionsDispatcher/","excerpt":"","text":"Android 6.0+运行时权限 6.0之后都需要控制危险权限，本文使用PermissionsDispatcher来控制，记下此文，快速集成使用。 目录结构： 集成依赖库 基本使用 填坑，使用经验 集成依赖库访问 PermissionsDispatcher了解最新信息。 添加dependencies， latest.version 当前是 2.3.1 。1234dependencies &#123; compile 'com.github.hotchemi:permissionsdispatcher:$&#123;latest.version&#125;' annotationProcessor 'com.github.hotchemi:permissionsdispatcher-processor:$&#123;latest.version&#125;'&#125; 基本使用1.非危险权限直接在 manifest中添加。 2.在BaseActivity中控制危险权限。 危险权限以下注解为必须12345678910@RuntimePermissions //添加注解public class MainActivity extends AppCompatActivity &#123;//请求指定权限@NeedsPermission(Manifest.permission.CAMERA) void clickCamera() &#123; // TODO: 2017/2/21 handle onclick Snackbar.make(camera, \"相机授权成功\", Snackbar.LENGTH_LONG).show(); &#125;&#125; 人性化控制其他回调方法，人性化控制。 12345678910111213141516171819202122232425262728293031323334353637//请求权限前提示消息@OnShowRationale(Manifest.permission.CAMERA)void showRationaleForCamera(final PermissionRequest request) &#123; new AlertDialog.Builder(this) .setMessage(\"我们需要相机！\") .setPositiveButton(\"允许\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; request.proceed(); &#125; &#125;) .setNegativeButton(\"拒绝\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; request.cancel(); &#125; &#125;) .show();&#125;//权限被拒绝提醒@OnPermissionDenied(Manifest.permission.CAMERA)void showDeniedForCamera() &#123; Snackbar.make(camera, \"相机权限被拒绝\", Snackbar.LENGTH_LONG) .setAction(\"允许\", new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; MainActivityPermissionsDispatcher.clickCameraWithCheck(MainActivity.this); &#125; &#125;).show();&#125;//权限被永久拒绝提醒@OnNeverAskAgain(Manifest.permission.CAMERA)void showNeverAskForCamera() &#123; Toast.makeText(this, R.string.permission_camera_neverask, Toast.LENGTH_SHORT).show();&#125; 同时请求多个权限不建议直接请求多个权限，最好在功能需要时再请求。12//以此类推@NeedsPermission(&#123;Manifest.permission.READ_CONTACTS, Manifest.permission.WRITE_CONTACTS&#125;) 填坑，使用经验1.Android 6.0以下权限是在安装时全部申请，manifest中不能忘记添加权限申请，撤销权限的唯一方式是卸载应用。2.权限组：如果应用请求危险权限，在同一权限组中已经授予了另一项危险权限，系统会立即授予，无需与用户进行任何交互。 其他参考文章Android权限机制与适配经验 其他特殊使用详情访问官方usage","categories":[{"name":"Android","slug":"Android","permalink":"https://haohaozaici.github.io/categories/Android/"}],"tags":[{"name":"Permissions","slug":"Permissions","permalink":"https://haohaozaici.github.io/tags/Permissions/"}]},{"title":"ZXing扫码","slug":"ZXing扫码","date":"2017-03-03T01:06:55.000Z","updated":"2017-03-03T02:44:01.605Z","comments":true,"path":"2017/03/03/ZXing扫码/","link":"","permalink":"https://haohaozaici.github.io/2017/03/03/ZXing扫码/","excerpt":"","text":"ZXing扫码实践 项目中的一个核心功能就是扫码，生成二维码。因此学习google的ZXing库是不二选择。 核心内容： 集成ZXing依赖库 选择需要的功能 填坑，自定义需求 集成ZXing库集成方式： 官方提供JAR文件下载，复制到项目的libs文件夹下面，一定别忘了添加add as library。 在dependencies中搜索com.google.zxing，添加com.google.zxing:core:3.3.0和com.google.zxing:android-core:3.3.0，rebuild。 选择核心功能","categories":[{"name":"Android","slug":"Android","permalink":"https://haohaozaici.github.io/categories/Android/"}],"tags":[{"name":"二维码","slug":"二维码","permalink":"https://haohaozaici.github.io/tags/二维码/"}]},{"title":"TO-DO APP MVP架构学习","slug":"TO-DO APP MVP架构学习","date":"2017-03-01T08:28:28.000Z","updated":"2017-03-02T08:38:51.356Z","comments":true,"path":"2017/03/01/TO-DO APP MVP架构学习/","link":"","permalink":"https://haohaozaici.github.io/2017/03/01/TO-DO APP MVP架构学习/","excerpt":"","text":"TO-DO APP MVP架构学习 由于新的项目中引入了MVP架构，加上MVP作为基础的解耦model和View的框架，必须得学习，是通往高级开发的必经之路。这一次先学习入门的google samples中的TO-DO APP项目。 本文目录层次： 项目应用介绍。 目录结构分析。 MVP在项目中的应用。 Model层分析。 应用介绍TO-DO APP就是字面上的意思，记录待办事项的应用。首先我们来看看应用的主要功能截图。 APP主要包括了四个功能界面： 主页面列表页面 任务详情页面 添加编辑任务页面 统计数据页面 目录结构分析再来看看项目的目录结构： 运行着app的demo，再看项目源码就相当轻松了，而且项目的目录是按照功能来区分，这样的好处显而易见。其他的测试类暂时不看。 MVP的应用在所有界面中，统计界面的功能最少，以此作为切入点。目录中，每个界面的包下都包含了4个文件，Activity，Fragment，Presenter，Contract。接下来阅读源码，在statistics目录中： 12345678910111213141516171819202122232425262728//Activity继承AppCompatActivity。public class StatisticsActivity extends AppCompatActivity&#123;&#125;//Fragment继承Fragment，实现了StatisticsContract.View接口。public class StatisticsFragment extends Fragment implements StatisticsContract.View &#123;&#125;//Presenter实现了StatisticsContract.Presenter接口。public class StatisticsPresenter implements StatisticsContract.Presenter &#123;&#125;//契约类中定义了View和Presenter的接口。public interface StatisticsContract &#123; interface View extends BaseView&lt;Presenter&gt; &#123; ... &#125; interface Presenter extends BasePresenter &#123; &#125;&#125;//两个Base接口类中public interface BaseView&lt;T&gt; &#123; // 规定View必须要实现setPresenter方法，则View中保持对Presenter的引用。 void setPresenter(T presenter);&#125;public interface BasePresenter &#123; // 规定Presenter必须要实现start方法。 void start();&#125; 先忽略接口类中的具体方法，看看每个部分的具体职责。 Activity托管了fragment，创建了presenter的实例。 Fragment通过mPresenter.start();拿到了StatisticsContract.Presenter的引用，然后实现了StatisticsContract.View接口中的所有方法。 Presenter通过mStatisticsView.setPresenter(this);方法拿到了StatisticsContract.View引用，因为在这个页面中没有交互，所以只实现了StatisticsContract.Presenter中的start()方法。 StatisticsContract定义了View和Presenter的接口。 熟悉了每个部分的行为，那Fragment和Presenter是怎么联系起来的呢，先看看Activity中创建presenter的方法：12new StatisticsPresenter( Injection.provideTasksRepository(getApplicationContext()), statisticsFragment); 在presenter的构造方法中传入了fragment的引用，调用了mStatisticsView.setPresenter(this);。在fragment的onResume()方法中调用了mPresenter.start();方法，以此建立了联系。 所以就这样V和P建立了完整的联系，M层和V层之间被presenter隔离开。 Model层分析 待完成。 理解了V层和P层之间的关系，现在可以看看项目的结构。","categories":[{"name":"Android","slug":"Android","permalink":"https://haohaozaici.github.io/categories/Android/"}],"tags":[{"name":"MVP","slug":"MVP","permalink":"https://haohaozaici.github.io/tags/MVP/"}]},{"title":"lcswAPP分析","slug":"lcswAPP分析","date":"2017-02-28T08:57:49.000Z","updated":"2017-02-28T10:00:00.000Z","comments":true,"path":"2017/02/28/lcswAPP分析/","link":"","permalink":"https://haohaozaici.github.io/2017/02/28/lcswAPP分析/","excerpt":"","text":"lcpay项目分析 项目重构了，基础架构更加明确，分析功能模块，逐个击破。 内容包括： 友盟推送 ZXing 扫码 友盟推送 添加依赖 manifest设置 配置Application manifest设置配置权限，设置android:name=&quot;Application Name&quot;，UMENG_APPKEY 在Application中处理 initUmengPush();注册保存静态常量，配置完全自定义推送服务。 在PushIntentService.class类中，取得消息体，读取消息到自定义类当中，序列化创建的对象bundle.putParcelable(&quot;msg&quot;, pushMessage);。 启动服务NotificationService.class设置了PendingIntent.FLAG_UPDATE_CURRENT参数更新旧消息的extras。 语音合成AppApplication.mTts.startSpeaking(msg.text, null); NotificationService通知配置： 获取extras，读取消息内容，处理推送，设置标题，内容，跳转Activity。","categories":[{"name":"Android","slug":"Android","permalink":"https://haohaozaici.github.io/categories/Android/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://haohaozaici.github.io/tags/笔记/"}]},{"title":"腾讯Bugly使用初体验","slug":"腾讯Bugly使用初体验","date":"2017-02-23T15:38:00.000Z","updated":"2017-02-23T16:02:13.587Z","comments":true,"path":"2017/02/23/腾讯Bugly使用初体验/","link":"","permalink":"https://haohaozaici.github.io/2017/02/23/腾讯Bugly使用初体验/","excerpt":"","text":"腾讯Bugly使用初体验 在拥有了自己的app之后，总是希望别人能够喜欢、下载、传播自己的app，如何追踪app的状态就十分重要了，包含了用户分析，设备分析==，当然信息越全面越好了。bugly帮我解决了用户分析和异常追踪的需求。 初体验里当然只包含了很少的内容，算是入门介绍把，总结提醒自己。 核心内容 Android SDK集成：使用指南，提示。 异常上报：在各种异常状态下上报异常信息，发生异常的环境==。 高级功能：拓展功能介绍。 基础概念 崩溃：闪退 卡顿：默认卡顿5s以上，可以自定义 ANR：无响应 错误：主动上报Exception，Error 发生次数==查看完整列表 Bugly基础使用添加依赖1compile 'com.tencent.bugly:crashreport:2.4.0' 参数设置12345&lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\" /&gt;&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" /&gt;&lt;uses-permission android:name=\"android.permission.READ_LOGS\" /&gt; 最简单的初始化添加Application类，@override onCreate方法1CrashReport.initCrashReport(getApplicationContext(), APP_ID, true); 第三个参数为SDK调试模式开关，调试模式的行为特性如下:输出详细的Bugly SDK的Log；每一条Crash都会被立即上报；自定义日志将会在Logcat中输出。建议在测试阶段建议设置成true，发布时设置为false。不要在异步线程初始化Bugly。 或者在 AndroidManifest.xml 中配置APP信息 上报进程控制防止多进程重复启用bugly服务。 测试在初始化Bugly的之后，调用Bugly测Java Crash接口。1CrashReport.testJavaCrash(); 最后观察logcat。","categories":[{"name":"Android","slug":"Android","permalink":"https://haohaozaici.github.io/categories/Android/"}],"tags":[{"name":"Bugly","slug":"Bugly","permalink":"https://haohaozaici.github.io/tags/Bugly/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-02-21T07:42:47.210Z","updated":"2017-02-23T08:59:30.634Z","comments":true,"path":"2017/02/21/hello-world/","link":"","permalink":"https://haohaozaici.github.io/2017/02/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment ##END","categories":[],"tags":[]}]}