<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「播放器」初识ExoPlayer]]></title>
    <url>%2F2019%2F07%2F15%2Fexoplayer_1%2F</url>
    <content type="text"><![CDATA[这只是一篇记录 又爱又恨的ijkplayer刚开始准备改造视频播放器的时候，对比了ijkplayer和ExoPlayer，我们的用例是HLS源点播，因为ijkplayer中文资料更多，支持更多的格式，而且b站这么多的用户，”兼容性”应该更好，所以毫不犹豫选择了ijkplayer。实际使用起来也并不复杂，简单封装修改了IjkVideoView，根据需要修改编译配置，编译so库，API使用非常方便。但是在使用了大半年ijkplayer后，被几个问题一直困扰，导致现在不得不考虑更换。 遇到的问题： 经常出现加载失败，一直在加载 错误状态不清晰，比较难定位问题 IjkMediaPlayer不保证复用安全 在某些4.4机型上频繁创建IjkMediaPlayer会崩溃 加载失败的问题最严重，虽然用户量不算大，但经常收到反馈，出现的情况比如播放时频繁加载、播放一段时间就卡住了，一直显示在加载，由于IjkMediaPlayer不保证复用安全，只能重新创建MediaPlayer。起初我以为只是用户的网络问题，或者是视频服务、CDN问题。但随着类似的反馈越来越多，问题肯定出在播放器上，我也尝试过各种设置，修改了各种参数，还有类似ijkhttphook等等，都无法解决。加载慢还带来了seek慢问题，seek之后需要等待很长时间才生效，当然这和视频源也有很大的关系，但在iOS、web端都正常。 错误状态不清晰也让我逐渐对她失去信心，视频源、播放设备都可能会出现问题，因为无法定位问题，浪费了很多时间联系用户，错误内容也没有直观的信息，每次收到出错日志都慌的一匹。 其他的如在某些4.4机型上频繁创建IjkMediaPlayer会崩溃，不断累积的native异常等，可靠性也不算好。不能确定是否是硬解软解与显示surface的问题，在Profiler里观察到播放效率(耗电量)明显偏高，内存占用也不少。 我并不擅长FFmpeg和c语言，没有信心在ijkplayer的基础上修改好，再加上一些安全性问题，需要修改之前的自定义协议方式，综合以上，在前段时间开始准备迁移到ExoPlayer。 迁移到ExoPlayer首先想好做什么目标很清晰，替换IjkMediaPlayer -&gt; Player、IjkVideoView -&gt; PlayerView，因为并不打算继续使用ijkplayer，而且两个播放器API差异不算小，所以没有使用接口抽象继续兼容ijkplayer，播放器与业务相关的API改动不大，只需要替换player即可。除此之外我还需要加入部分解密算法，实现自定义协议、支持解密，native代码混淆。 研究原理ExoPlayer资料非常丰富详细，包含官方文档、google io视频、丰富的github issue。通过这些方法解决了我遇到的所有问题，并且让我了解了很多相关知识，后面会介绍我涉及到的部分。解密的部分可以通过OpenSSL配合自定义DataSource实现，native代码混淆可以使用ollvm，他们的用法资料也非常多。 选择方案得益于ExoPlayer清晰灵活的结构，很明确，ExoPlayer自定义数据源 + OpenSSL解密数据源 + ollvm native代码混淆。 初步实现生产环境的大项目可不适合试错，打开配置好的模板demo，编写简单可播放sample的示例，自定义数据源参考ExoPlayer OkHttp extension 1234567// 创建数据源HttpDataSourceHttpDataSourceFactory// 修改数据加载方法，处理请求和响应，满足自定义协议@Overridepublic long open(DataSpec dataSpec) throws HttpDataSourceException &#123;&#125; OpenSSL解密数据源，配置native开发环境，编译OpenSSL动态(静态)链接库，导入头文件，参考官方demo实现AES解密的相关jni方法 12345678910111213141516171819202122232425262728jbyte *key = (*env)-&gt;GetByteArrayElements(env, decryptKey, JNI_FALSE);jbyte *iv = (*env)-&gt;GetByteArrayElements(env, encryptionIv, JNI_FALSE);EVP_CIPHER_CTX *ctx;/* Create and initialise the context */if (!(ctx = EVP_CIPHER_CTX_new())) &#123; LOGE("initialise context failed -1"); return -1;&#125;/* * Initialise the decryption operation. IMPORTANT - ensure you use a key * and IV size appropriate for your cipher * In this example we are using 256 bit AES (i.e. a 256 bit key). The * IV size for *most* modes is the same as the block size. For AES this * is 128 bits */if (1 != EVP_DecryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, (const unsigned char *) key, (const unsigned char *) iv)) &#123; LOGE("DecryptInit failed -2"); return -2;&#125;(*env)-&gt;ReleaseByteArrayElements(env, decryptKey, key, JNI_FALSE);(*env)-&gt;ReleaseByteArrayElements(env, encryptionIv, iv, JNI_FALSE);return (jlong) ctx; 使用FFmpeg准备好加密的HLS源，验证sample正确播放 1234ffmpeg -i 0_blv.mp4 \-c copy -bsf:v h264_mp4toannexb -hls_time 5 -hls_list_size 0 \-hls_key_info_file key.info \encryptionM3U8/output.m3u8 ollvm native代码混淆，编译支持混淆的llvm，修改ndk toolchain，配置支持混淆的ndk路径，因为native代码并不多，支持的混淆方式都加上了，最后用IDA Pro查看是否混淆成功，一行简单的return代码被加上了几十层循环。 123456externalNativeBuild &#123; cmake &#123; // 添加各种混淆方式 cFlags "-mllvm -sub -mllvm -bcf -mllvm -fla -mllvm -sobf" &#125;&#125; 优化细节在应用到项目之前，可以尝试优化一些细节，比如在线播放的时候加上CacheDataSource作为临时缓存，能极大提升拖动进度条的体验，减少流量消耗 1SimpleCache(downloadContentDirectory, LeastRecentlyUsedCacheEvictor(CACHE_MAX_SIZE)) 提前尝试好各种参数配置，如loadControl，LoadErrorHandlingPolicy，整理好一些工具、辅助类方便处理MediaSession、PlayerNotification、截图、状态栏等等。清晰的错误报告这次不会错过了，处理好方法的异常，返回值，关键点日志，API，注释，混淆配置。 应用到项目最后就需要耐心的接入到项目中了，发布SDK到maven仓库，细心的修改不同功能模块，细粒度的对比检查、提交代码。经过几周的测试，生产环境试用，最终优雅的解决了之前自定义协议带来的问题，网络加载问题得到了极大的改善，内存消耗减少，性能也显著提升。 通过使用ijkplayer了解到很多视频播放相关的知识，但每当我想一窥究竟的时候，里面的内容却是不熟悉的c代码。亲切的Java代码，加上ExoPlayer清晰的结构，把里面复杂的模块拆分展现出来，终于认识到我写的一串newSimpleInstance代码到底是什么了。 参考资料： exoplayer.dev google-exoplayer blog openssl Decrypting the Message OLLVM代码混淆移植与使用]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ConstraintLayout「最全总结」]]></title>
    <url>%2F2018%2F07%2F11%2FConstraintLayout%2F</url>
    <content type="text"><![CDATA[现在大家几乎都使用过ConstraintLayout，但与经常使用的布局相比，可能会面临不熟悉CL的API或者是逐渐增加的新特性，还有可能因为对CL具体行为的理解模糊而导致误用，这篇文章的目的更多的是，全面总结ConstraintLayout的用法和实际行为特性，并不断更新 基于ConstraintLayout 1.1，当前2.0版本处于测试阶段参考文章：ConstraintLayout入门指南 为什么要引入ConstraintLayout 减少布局层级：常用的布局划分成了几个不同的类型，要组合不同的功能需要通过嵌套的形式实现，比如想要按比例布局就要使用layout_weight属性，想要使用layout_weight属性就要使用LinearLayout（以下简称LL）或者TableLayout，然后你在原先同级的每个布局外再嵌套一层布局以使用layout_weight。 更多的布局需求：要实现固定宽高比、百分比布局，灵活控制大小等更高阶的布局需求，原先的各类布局方式都不能很好的支持，可能需要通过Java代码，在运行中二次实现。 想要通过ConstraintLayout来 优化性能，可能并不明显 亦或者你只是想尝试下这款Andorid官方力推的新布局，看看它有什么新特性。 引入lib:1234//确保SDK Tools中已经下载了ConstraintLayout的支持库：dependencies &#123; implementation 'com.android.support.constraint:constraint-layout:1.1.2'&#125; 开始之前，我们应该意识到在布局文件中Layout主要职责是什么，控制widgets的位置和大小。下面将从这两个方向出发，看看ConstraintLayout是怎么做的。 1. 控制位置layout中的view都有四个方向left(start), right(end), top, bottom，通过这些方向在两个view之间建立约束来实现基础的位置控制，相对于RelativeLayout，RL中所有的属性CL中都有与之对应的项目，稍加熟悉即可完成转换： 相对于父布局的相对布局属性，CL的规则是：将父布局当做一个id=”parent”的对象来对待： 1.1 Margins设置普通的margin： 1.2 visibility 对约束的影响特殊的情况是：连接到visibility为GONE的view时的margin，在ConstraintLayout中，当widgets被设置View.GONE时进行了特殊处理。 根据布局的传递，设置为GONE的view相当于大小被设置为0(实际上是被设置成了一个点) 如果他们已经跟其他的组件产生了约束关系，约束关系还是会存在，但是所有的margin都会变成0 也可以使用goneMargin来保持预期的边距 这种特殊的处理，可以在你临时的把view设置为GONE时，不破坏布局结构。 1.3 居中和偏移居中的设置参考之前于RelativeLayout的对应关系，CL增加了偏移属性，使用偏移可以更好的处理屏幕大小改变时的情景。 布局中设置：123456&lt;android.support.constraint.ConstraintLayout ...&gt; &lt;Button android:id="@+id/button" ... app:layout_constraintHorizontal_bias="0.3" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent/&gt;&lt;/&gt; 1.4 圆形的位置使用圆形约束，在创建圆形的菜单时非常有用 12345&lt;Button android:id="@+id/buttonA" ... /&gt;&lt;Button android:id="@+id/buttonB" ... app:layout_constraintCircle="@+id/buttonA" app:layout_constraintCircleRadius="100dp" app:layout_constraintCircleAngle="45" /&gt; 2. 控制尺寸(大小)2.1 给ConstraintLayout自己添加大小限制当ConstraintLayout的大小设置为WRAP_CONTENT时，可以很方便的设置自己的最大宽高 2.2 Widgets的尺寸(大小)约束和我们在常用的布局中设置宽高一样，控制Widgets的宽度和高度一共有3种方式： 固定的大小，如123dp WRAP_CONTENT 自适应 0dp，等于MATCH_CONSTRAINT，类似于match_parent，会利用所有可用的空间。注意，不建议使用match_parent 2.3 WRAP_CONTENT 强制约束默认情况下，设置为WRAP_CONTENT的组件不会限制他们的大小，有时会导致超出约束条件的情况，如果需要强制他们满足约束条件的话，使用下面的强制约束12app:layout_constrainedWidth=&quot;true|false&quot;app:layout_constrainedHeight=&quot;true|false&quot; 2.4 MATCH_CONSTRAINT 大小控制默认情况下，MATCH_CONSTRAINT 会利用所有可用的空间，通过下面的设置，可以自定义具体的行为 layout_constraintWidth_min and layout_constraintHeight_min layout_constraintWidth_max and layout_constraintHeight_max layout_constraintWidth_percent and layout_constraintHeight_percent 使用百分比大小时，对应方向的大小必须设置为 MATCH_CONSTRAINT 2.5 使用比例使用比例有两种情况，而且必须至少有一条边被设置为0dp： 如果只有一条边被设置为0dp，设置比例时，将参考另外一条已经确定尺寸的边 如果两条边都被设置为0dp，那么会在满足比例的条件下，设置为最大尺寸 同样的支持直接设置layout_constraintWidth_percent和layout_constraintHeight_percent来使用百分比控制相对于parent的比例1234567891011121314&lt;Button android:layout_width="wrap_content" android:layout_height="0dp" app:layout_constraintDimensionRatio="1.6" /&gt;&lt;Button android:layout_width="wrap_content" android:layout_height="0dp" app:layout_constraintDimensionRatio="1:1" /&gt;&lt;Button android:layout_width="0dp" android:layout_height="0dp" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintDimensionRatio="H,16:9" app:layout_constraintTop_toTopOf="parent" /&gt; 2.6 ChainsChains能自定义在同一轴线上view的位置和大小，首先我们来创建一条链，当widgets之间在同一个方向上相互连接(相互约束)时，链就形成了。 2.6.1 链的head水平方向chain最左边的控件和垂直方向chain最顶部的控件被成为head chain。通过对head chain添加chainStyle属性，可以设置该条chain在水平或垂直方向上的chainStyle 2.6.2 Chain Style12layout_constraintHorizontal_chainStylelayout_constraintVertical_chainStyle chainStyle属性一共有三种：spread、spread_inside、packed。再配合其他属性，最终可以组成五种chain style： 其他四种chain style的设置和效果都比较简单，重点介绍下Weighted Chain。 默认的spread模式，每个元素获得同样的空间，如果一个元素使用了0dp，将会占用剩下的所有可用空间 layout_constraintHorizontal_weight和layout_constraintVertical_weight可以用来控制同样设置为0dp的控件的比例 Weighted Chain中的控件也允许在chain方向上使用wrap_content自适应控件宽/高，且布局时优先满足设置为wrap_content的控件，相当于优先满足设置了指定宽高的控件 当设置了margin时，margin生效的同时weight的比例不变，链上的控件实际占有布局会被压缩 3. 不可见的辅助工具GuidelinebarrierGroup4. 用代码的方式操作ps. 选择优化类型Package Index:android.support.constraintandroid.support.constraint.helperandroid.support.constraint.motionandroid.support.constraint.utils]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「播放器」Mac上编译ijkplayer so支持HTTPS]]></title>
    <url>%2F2018%2F06%2F07%2Fbuild-ijkplayer%2F</url>
    <content type="text"><![CDATA[当项目中使用ijkplayer，而且还需要播放HTTPS链接的视频时，就比较蛋疼了 (￣.￣)，ijkplayer默认不支持HTTPS播放，但提供了编译OpenSSL的选项，可以自己编译so文件支持HTTPS播放。这篇文章的目的是引导不熟悉的人完成整个编译过程，提醒过程中的注意事项，还有各种选项的解释。 我的编译环境VMware + Ubuntu编译环境也可以参考，基本上只有命令不同，homebrew的安装这里不再赘述。非常不建议在Windows环境下编译！123456Mac 10.13.2iTerm2 + zshHomeBrewNDK r10eNDK + 编译所有so大概需要10GB空间 相关链接: Bilibili/ijkplayer IJKPlayer编译so支持HTTPS的踩坑历程 ijkplayer编译so库真没那么难 1. 准备工作安装Git与yasm12brew install gitbrew install yasm 配置SDK、NDKSDK都会有，NDK一般没有下载，建议去官网下载:https://developer.android.google.cn/ndk/downloads/older_releases 需要注意的是最好下载官方lib使用的NDK r10e，使用其他版本的将无法编译。具体原因可以参考这篇issue SDK、NDK和准备完成后，在.bash_profile, 或者是.zshrc中添加配置。(Command + shift + . 显示隐藏文件) 123456// 注意替换为自己的文件路径export ANDROID_SDK=/Users/haoyuan/Library/Android/sdkexport PATH=$ANDROID_SDK/platform-tools:$PATHexport PATH=$ANDROID_SDK/tools:$PATHexport ANDROID_NDK=/Users/haoyuan/Library/Android/android-ndk-r10eexport PATH=$ANDROID_NDK:$PATH 添加完成后，保存文件，然后source .bash_profile等相关文件，或者直接重启终端，通过 ndk-build -v 检查是否生效 clone ijkplayer源码123git clone https://github.com/Bilibili/ijkplayer.git ijkplayer-androidcd ijkplayer-androidgit checkout -B latest k0.8.8 2. 编译之前编译前选择你的配置选择自动化编译时的一些配置选项，比如支持的协议，音视频类型等，官方给我们提供了三个模板。 可以打开config/目录下config/module.sh看看，enable启用，disable禁用123module-default.shmodule-lite-hevc.shmodule-lite.sh 官方默认建议选择的是 module-lite.sh，可以根据自己的需求选择123cd configrm module.shln -s module-lite.sh module.sh 如果要选择module-default.sh的话，可能会编译失败，可以参考这篇issue123仔细阅读module-lite.h 原来在最下面有一行配置：export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --disable-linux-perf&quot;把这行复制到module-default.sh 的最后面就可以了 在编译配置中可以增减需要的模块，选择需要支持的封装格式、编解码类型、协议能有效减小so库的体积。可以参考CarGuo/GSYVideoPlayer DECODERS.md 3. 开始编译ヽ(｀⌒´)ﾉ执行初始化初始化会下载各种包，尽量选择在良好的网络环境下╮(￣▽￣)╭12cd .../init-android.sh 初始化OpenSSL1./init-android-openssl.sh 编译OpenSSL和FFmpeg首先清除一波123cd android/contrib./compile-openssl.sh clean./compile-ffmpeg.sh clean 编译OpenSSL：可以选择不同版本，全量编译耗时更长，但最好选择全量编译，编译完成后再根据需求选择要使用的包。1./compile-openssl.sh all 编译FFmpeg，同样的123./compile-ffmpeg.sh all// 如果要选择特定的架构: ./compile-ffmpeg.sh armv7a | armv5 最后编译ijkplayer1./compile-ijk.sh all 经过漫长的等待终于完成了以上编译过程\（￣︶￣）/，在目录中生成了ijkplayer的工程 4. 导入项目原有的项目一般是这样配置的12implementation &apos;tv.danmaku.ijk.media:ijkplayer-java:&apos; + gradle.ijkplayer_javaimplementation &apos;tv.danmaku.ijk.media:ijkplayer-armv7a:&apos; + gradle.ijkplayer_java 如果只需要修改so库的话，删除掉第二行对so库的引用，将自己编译好的so文件复制到项目的libs文件夹中。 别忘了在gradle中配置，要不然会报错找不到so库 还可以在release包中设置abi过滤 最后大功告成啦\(^o^)/ 尾巴… 如果项目中同时使用了HTTP和HTTPS的视频源的话，要注意如果视频源刚好是相同域名，会导致播放失败，这是由于dns缓存造成的，解决办法参考这篇issue初始化IjkMediaPlayer时，设置清除dns cache1234567IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;dns_cache_clear&quot;, 1//还要注意开启相关支持的协议IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;protocol_whitelist&quot;, &quot;async,cache,crypto,file,http,https,ijkhttphook,ijkinject,ijklivehook,ijklongurl,ijksegment,ijktcphook,pipe,rtp,tcp,tls,udp,ijkurlhook,data&quot;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「播放器」Android音频焦点]]></title>
    <url>%2F2018%2F04%2F24%2FAndroid%20Sound%20overlap%2F</url>
    <content type="text"><![CDATA[音视频播放在手机日常使用中非常频繁，当我们听着音乐刷着微博时，看到有趣的视频点击开始播放，音乐自动暂停，退出视频时音乐又自动恢复了播放(如果没有自动恢复的话，比如QQ音乐就会提示是否设置中断后继续播放)。 这一系列流畅自然的操作不是理所应当的吗~当然如果处理不好的话就会出现声音重叠，音频焦点长期被占用的问题，下面我们来看看具体的功能逻辑。 音频焦点相关的讲解参考以下文章 Android音频焦点详解Managing Audio Focus Managing Audio Focus不同的APP可以同时播放音频，系统会将他们混合在一起，但为了避免同时播放，Android提供了audio focus机制来合理使用音频播放资源。同一时间只能有一个APP获取音频焦点，当需要播放音频时，应该立即请求音频焦点，同样的，在你的APP获取到音频焦点后，其他APP也可以抢占音频焦点，这时你的APP就需要暂停播放或降低声音。音频焦点是合作类型的，APP拥有完全自主的控制权，系统无法阻止，但应用应该遵守音频焦点的指导规则。 好的音频APP在播放时应该遵守以下规则： 开始播放后立即调用requestAudioFocus()方法，并验证返回值为AUDIOFOCUS_REQUEST_GRANTED 当其他app占用音频焦点时，暂停或停止播放，或者降低声音 当播放停止时，放弃音频焦点 在不同的Android版本下，需要使用不同的方法来处理音频焦点： API level 8以后，使用requestAudioFocus()和abandonAudioFocus()方法，并注册AudioManager.OnAudioFocusChangeListener接收回调。 API level 21以后，需要使用AudioAttributes来描述播放音频的类型。 API level 26以后，需要使用AudioFocusRequest参数，它携带了音频的context和相关功能，系统会根据这些自动管理音频焦点。 Android8.0以前参考官方文档获取焦点的方法如下： 123456// Request audio focus for playbackint result = am.requestAudioFocus(afChangeListener, // Use the music stream. AudioManager.STREAM_MUSIC, // Request permanent focus. AudioManager.AUDIOFOCUS_GAIN); 但在听音乐的时候播放音频或视频，依旧出现了重叠的声音，实际上有效的做法是这样的12345//下面两个常量参数试过很多 都无效，最终反编译了其他app才搞定，汗~ int requestFocusResult = mAudioManager.requestAudioFocus( mAudioFocusChangeListener, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN_TRANSIENT); 具体参考文章Android MediaPlayer音频焦点问题，抢占声道 最后在对应的播放状态下获取和释放音频焦点。 Android8.0之后和之前一样，Android8.0中也使用了requestAudioFocus()来请求音频焦点，不一样的是，使用abandonAudioFocusRequest()释放音频焦点，并且请求和释放都需要传入同一个AudioFocusRequest实例。使用AudioFocusRequest.Builder来创建，具体实现代码参考官方文档Audio focus in Android 8.0 and later。 123456789101112mAudioFocusRequest = new AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN) .setAudioAttributes(new AudioAttributes.Builder() .setUsage(AudioAttributes.USAGE_MEDIA) .setContentType(AudioAttributes.CONTENT_TYPE_MOVIE) .build()) .setAcceptsDelayedFocusGain(true) .setOnAudioFocusChangeListener(mAudioFocusChangeListener) .build();//请求音频焦点 requestFocusResult = mAudioManager.requestAudioFocus(mAudioFocusRequest);//释放音频焦点abandonFocusResult = mAudioManager.abandonAudioFocusRequest(mAudioFocusRequest); 注意事项： Android8.0中其他APP使用AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK参数获取焦点时，将不会回调本APP的onAudioFocusChange()方法。 焦点延迟获取，当焦点被其他APP“锁”住时，requestAudioFocus()会返回AUDIOFOCUS_REQUEST_FAILED，比如正在打电话时，焦点就会被锁住。如果使用了setAcceptsDelayedFocusGain(true)方法，请求将会返回AUDIOFOCUS_REQUEST_DELAYED，在锁解除后，系统会继续处理未完成的焦点请求，并回调onAudioFocusChange()方法。 处理音频焦点变化了解相应的请求、释放方法后，还需要进一步处理音频焦点变化问题，也就是优化跟其他APP或者是系统APP合作的过程。主要是处理onAudioFocusChange方法：12345678910111213141516171819202122232425262728293031323334private AudioManager.OnAudioFocusChangeListener mAudioFocusChange = new AudioManager.OnAudioFocusChangeListener() &#123; @Override public void onAudioFocusChange(int focusChange) &#123; switch (focusChange)&#123; case AudioManager.AUDIOFOCUS_GAIN: //当其他应用申请焦点之后又释放焦点会触发此回调 //可重新播放音乐 Log.d(TAG, "AUDIOFOCUS_GAIN"); start(); break; case AudioManager.AUDIOFOCUS_LOSS: //长时间丢失焦点,当其他应用申请的焦点为AUDIOFOCUS_GAIN时， //会触发此回调事件，例如播放QQ音乐，网易云音乐等 //通常需要暂停音乐播放，若没有暂停播放就会出现和其他音乐同时输出声音 Log.d(TAG, "AUDIOFOCUS_LOSS"); stop(); //释放焦点，该方法可根据需要来决定是否调用 //若焦点释放掉之后，将不会再自动获得 mAudioManager.abandonAudioFocus(mAudioFocusChange); break; case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT: //短暂性丢失焦点，当其他应用申请AUDIOFOCUS_GAIN_TRANSIENT或AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE时， //会触发此回调事件，例如播放短视频，拨打电话等。 //通常需要暂停音乐播放 stop(); Log.d(TAG, "AUDIOFOCUS_LOSS_TRANSIENT"); break; case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK: //短暂性丢失焦点并作降音处理 Log.d(TAG, "AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK"); break; &#125; &#125; &#125;; 最后音频相关的API常常让人疑惑，明明已经根据注释的描述和官方文档中的方法实现了，却达不到预期的效果。还有就是随着Android更新的推送速度越来越快，更新普及率也水涨船高，高版本API随时在发生变化，适配时需要注意这些细节，以及进行完善的测试。 工具类参见AudioFocusManager 未完成内容源码简单分析 在不同机型中进行测试]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[创建和销毁对象]]></title>
    <url>%2F2017%2F12%2F19%2Fcreate-and-destroy-objects%2F</url>
    <content type="text"><![CDATA[创建和销毁对象静态工厂方法代替构造器静态工厂方法与设计模式中的工厂方法不同。 优势 静态工厂方法有名称， 遇到多个构造器参数时，使用构建器-Builder模式1.使用构造方法创建对象重叠构造器 2.JavaBeans模式通过setter方法设置必要参数，拥有良好的可读性。缺点：构造过程中容易被改变，处于不一致的状态。 3.Builder模式通过公开的Builder内部类，私有的构造方法，构造必传参数和可选参数。Builder模式模拟了具名的可选参数，可以加强约束条件，在对象域中进行检验。可以在编译时进行异常检查。 缺点：特殊情况下额外的性能开销，冗长。适用情况：多个参数(大于4个)，需要比JavaBeans模式更加安全的情况。 参见 Notification 或 Alertdialog类。 用私有构造器或者枚举类型强化singleton属性为了防止反射调用私有构造方法、反序列化时创建新的实例，直接使用 包含单个元素的枚举类型. 12345public enum Elvis&#123; INSTANCE; ...&#125; 避免创建不必要的对象39条 应该创建新对象时，不要重用现有对象创建不必要的对象只会影响程序的风格和性能，没有实施保护性拷贝将会导致潜在的错误和安全漏洞。 消除过期的对象引用内存泄露]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mifare 1k S50卡]]></title>
    <url>%2F2017%2F12%2F13%2FM1%20card%2F</url>
    <content type="text"><![CDATA[背景：最近的项目中涉及到读写M1卡，之前完全没接触过一脸懵逼，却没意识到，生活中常用的公交卡、门禁卡、开水卡、会员卡等等大多数都是M1类的射频卡，如Mifare 1k S50系列。熟悉了相关知识后，发现原理如此简单，感谢开源也因此能做很多方便的事情了。记录一下，面对陌生的事物不要害怕，了解熟悉，探索乐趣。 基础知识M1卡M1卡结构 从上面可以看到，扇区0 块0固化了厂家代码，32位16进制数，一般作为ID使用。 每一个扇区的块3用于保存KEY A,存取控制,KEY B，除了扇区0的块0之外的其他的块0~块2都用于存储数据。KEY A不可读、可写，KEY B可读可写. 一般的门禁卡中，不存储任何数据，门禁系统只读取卡ID，学校里使用的开水卡，一般是离线使用，卡的余额或者使用次数是存储在卡中的，使用时进行读写。在武汉通中，存储了卡余额，储值、消费记录，具体的余额存储在服务器上。所以理论上可以模拟卡ID来模拟门禁卡，或者是读取修改水卡值来修改卡。 读写卡工具MIFARE Classic Tool, MifareClassicTool - GitHub 模拟卡工具NFC卡模拟 相关文章Mifare 1k S50 卡的简单探讨与破解]]></content>
      <categories>
        <category>生活</category>
        <category>乱七八糟的技巧</category>
      </categories>
  </entry>
</search>
