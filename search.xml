<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[拔智齿]]></title>
    <url>%2F2019%2F06%2F30%2F%E6%8B%94%E6%99%BA%E9%BD%BF%2F</url>
    <content type="text"><![CDATA[拔智齿 一、2019.6.28 几天前 马上又要去拔牙了，虽然上次拔牙过程很顺利，但心里还是有些忐忑。首先是拔一颗智齿花了接近1300，看到网上别人不到500心里会有些不平衡，不知道这次会花多少？一定要跟医生说选便宜的方式。其次多少还是有些痛苦的，刚打麻药时针刺的感觉，拔完牙吃饭的不便（第一天下午睡着了，口水夹杂着血水流了一枕头），不过医生姐姐的细心、温柔、专业把这些不快都冲淡了。日子一天天临近，想着28号早上还得早起，心里兴奋又紧张，这次会遇到什么样的医生呢。 二、2019.6.28 前往医院 早上6:30，急忙收拾好资料，钱包，带上眼镜，昨天晚上不小心放在外套口袋里被扔进洗衣机的耳机是指望不上了。6月的北京，天早已大亮，出了公寓门口，湿润的地面暗示今天可能又会比较闷热，街道上已经有不少人在疾行，今天是周五，城市在忙碌的运转着。掏出手机，在地图里确认了已经走过一遍的路线。每一次坐地铁我都会想起P5，里面每天都会出现的地铁场景让游戏突然变得很真实，贴近生活，好像小时候上学基本靠走路一样。 走出地铁站门口就是天坛公园，还需要穿过一段小巷才能到医院，上次走路的体验很不错，路面干净，比较窄只能过一辆车，行人不多不少。路过小卖铺，老板娘给我的映像特别深，店铺大概4平米，第一次进店我说话声音很大，阿姨的却回复非常温柔，轻声细语，让我有一种粗鲁的羞愧感，这一次我没有再犯错误，声音几乎是最轻了^_^。买完了水，离预约时间8:00很近了，我加快了脚步。距离上次拔牙只过了一个月，附近的建筑没有太大的变化，我的注意力转向了路上与我同行的人，几乎都是女生，大多数职业女性的装扮，我提着印着医院名称的塑料袋，是去医院看病的，她们呢？很快我就知道了答案。快到医院了，我的方向是从医院后方走到门口，她们在中间的位置就折向了后门，她们是医生，开始上班工作了，一路的同行突然让我有了一种参与感，就像平日里早晨同事们一起上楼一样。 轻车熟路，取号的时候错把武汉的社保卡插入机器，一直报错，不知道是头晕了，还是眼花了。爬楼梯到五楼7:40刚好，医生还没上班，只有窗口有一位医生，8点才开始分诊，楼道里坐着的人已经不少了，陆续还有人坐电梯上来，然后医生姐姐不停的被问：啥时候开始？挂号完了要咋办？我当然也参与了其中haha，现在真的开始理解她们的不耐烦了… 三、拔牙 8:00登记完就要开始等待了，我被分在了第一诊室（上次是第二诊室），这一层全都是拔牙的，病人陆续被分往各个诊室，每个诊室大概6个工位。来往的人，医生的呼喊，忙碌的护士，楼道比较窄，我靠在墙边上，开始观察旁边的人。大多数拔牙的都是年轻人，女生拔牙的基本都有人陪着，大多是带妈妈一起来的，有带男朋友的，还有跟爸爸一起的。我旁边的女生明显是一个人来的，小小的个子，跟数学老师豆豆有点像，好想问她是不是一个人来的，然后她很快就被叫进去了…有一对大概60多岁的爷爷奶奶，女的涂着精致的妆，男的成熟帅气，颇有些英雄迟暮的感觉，不经开始幻想他们年轻时的模样。大家都在门口等待着，有的焦躁，有的紧张。还有些年纪很大的人来拔牙，医生说是要连心电设备才能做，这个科室做不了。 终于叫到我了，医生姐姐拿着曲面断层片跟我说了一堆风险啥的，我基本没听进去，只能不停的点头，估计看我脸色不好，最后安慰我说一般几个月都会好的，然后就找老师去了。她的老师是个老师傅，身材高大，眉毛有点白了，亲切幽默的东北口音。我跟着过去，听到应该要做微创，先割开牙龈，磨一部分，再取出来，这部分手术费比较高，还没问能不能选便宜点的方案，直接被领着躺椅子上了，赶紧提了一句。医生开始准备麻药，不太熟练的用脚掌操作椅子的高度，检查，注射，因为手法有些不熟练，调整了几次，注射时有些胀通，慢慢开始失去知觉，开始准备第二针，金属的针筒，旋转固定有点像电影里的场景，这时老师路过提醒要在靠近骨头的地方注射，要不然不一定麻，我分不清肾上腺素和麻药的顺序。注射完毕，老师过来了，麻溜的升高椅子，让学生辅助，吸收口水和血水，磨牙时喷水，老师力量特别大，下面的智齿用了几次力都没出来，“怎么这么不愿意出来”，说话的语气很幽默，磨了几下很快就拔出来了，我也跟着笑了起来，上面的智齿长得比较整齐，感觉几秒钟就完事了，剩下就是冲洗和缝针，老师提醒学生注意拿刀的姿势，不能对着患者，老师用刀绕线的姿势感觉像武林高手，学生认真又带点笨拙的节奏我觉得特别可爱。 清理的时候，老师去拿缝线，我没忍住笑意，口胡着对学生说：“感觉你比我还紧张~”，医生姐姐顿时笑了起来，她带着口罩，我只能看到她的眼角。 结束了，缴费787，自费40，其他都是自付一，拿上冰袋在诊室门口等待，有个带女儿来的阿姨想让位置给我，我面带笑容急忙摇头拒绝了，看着不断进出的人们，感觉心里好温暖。也不是所有人拔完牙都面带笑容，有个女生从来的时候，到拔完牙一直都是闷闷不乐，我看着特别想笑。拿完假条，看着医生又开始下一轮注射麻药，我得离开了。到了时间点，吐了棉球，走在回家的路上，心里有些失落。 四、美好的情感 回家的路上我为什么会感到失落，一天的经历下来，我突然感到自己离美好的人，美好的事在越来越远，痛苦趁虚而入，占据了我的脑海。我开始觉得人的一生都在受苦，拔牙是身体上的痛苦，追求美好的事物是求之不得苦。麻药消退后不断加剧的疼痛，让我更加难以保持清醒。 我在大镖客2里找到一份慰藉，周末有了拔牙的借口，可以认真的玩玩游戏了，之前没认真了解过大镖客2，简单玩过只知道节奏很慢，这一次重新开始玩我总是害怕错过一些内容，我开始变的急躁，不断寻找攻略、秘籍，可它告诉我，不要着急，不要着急，慢慢来，不要害怕错过，这个世界很精彩，有无数种可能。 痛苦的经历不值得感到沮丧，而是变为故事，就像现在这样可以被简单的记录下来，美好的事物在这片土地孕育，我爱上了在北京的这段时光。 2019.6.30 北京 公寓]]></content>
      <categories>
        <category>生活</category>
        <category>情感</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[白蛇 缘起]]></title>
    <url>%2F2019%2F01%2F26%2F%E7%99%BD%E8%9B%87%20%E7%BC%98%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[画面8分比较精致的电影，制作优良，画面细节不错，衣服、头发的纹理真实，唯美的场景。类似修仙小说里的招魂幡让人眼前一亮，还有不少比较性感的场景，表现不错haha。总结：部分场景非常好，但几个比较大的场景和总体的细节一般，所以略有遗憾，但唯美的画风加分不少。 剧情6分剧情节奏比较紧凑，把俗套的故事演绎的不错，但实在没啥亮点。 音乐7分整体的音效及格，几个重要的旋律还不错，还有个幽默的小插曲，但是除此之外，没有突出的bgm，考虑到情怀还是加一分。 人物7分把大家如此熟悉的人物，演绎出了许宣-白蛇恋、白蛇-小青恋、单身狗，让不同的人都能找到自己的定位，haha，导演有点坏，不过也因此加分不少。 这一次是和小东一起看的。。别人都是成双成对，难受哦。。不过是一部值得以后再翻出来看的电影]]></content>
      <categories>
        <category>生活</category>
        <category>电影</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android CodeStyle]]></title>
    <url>%2F2019%2F01%2F11%2Fandroid%20code%20style%2F</url>
    <content type="text"><![CDATA[1 代码格式化由于大家不同的习惯，有的没有格式化就提交了，这样导致在阅读其他人的代码时造成很大不便，速度减慢，有的甚至会理解错误。所以非常有必要统一格式化风格，并且必须要格式化后才能提交。 要求 使用统一的Java/Kotlin/xml文件格式化模板 全部使用IDE默认模板，在IDE中以下路径设置，如图。123java: Preferences | Editor | Code Style | Javakotlin: Preferences | Editor | Code Style | KotlinXML: Preferences | Editor | Code Style | XML 其中kotlin的格式还需要指定style 提供CheckStyle模板，提交前可以快速扫描 常见特殊场景： 2 注释规则注释规则主要是为了提供统一的注释模板，常见的需要注释的场景，在需要写注释的时候可以参考，保持统一的风格。 模板示例: Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * 注释内容 * * @author haoyuan * @date 2019/1/16 */public abstract class ExampleJavaClass &#123; /** * 类属性需要安装Javadoc方式注释，public属性必须注释 */ public String param; /** * 类方法需要安装Javadoc方式注释，public方法必须注释 */ public void fun() &#123; // 方法内部单行注释，在被注释语句上方另起一行 doSomething(); /* 方法内部多行注释 使用\/* *\/注释，注意与代码对齐。 */ doSomething(); &#125; /** * 所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、 * 异常说明外，还必须指出该方法做什么事情，实现什么功能。 * * @param param1 参数1 * @return 返回值说明 * @throws Exception 异常说明 */ abstract Object abstractFun(Object param1) throws Exception; /** * 接口说明 * * @author haoyuan * @date 2019/1/16 */ interface InterfaceExample &#123; /** * 与抽象方法相同 */ void interfaceFun(); &#125; void doSomething() &#123; // TODO: haoyuan 2019/1/16 待办事宜，表示需要实现，但目前还未实现的功能 // FIXME: haoyuan 2019/1/16 错误，不能工作，在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况 &#125; /** * 枚举类注释 * * @author haoyuan * @date 2019/1/16 */ public enum EnumExample &#123; /** * 所有的枚举类型字段必须要有注释，说明每个数据项的用途。 */ A &#125; /** * 注解类注释 */ @Documented @Retention(RetentionPolicy.SOURCE) @IntDef(&#123;ANNOTATION_1&#125;) public @interface AnnotationInterface &#123; &#125; /** * 注解类字段必须有注释 */ public static final int ANNOTATION_1 = 0; &#125; 模板示例: Kotlin123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 一组*成员*。 * * 这个类没有有用的逻辑; 它只是一个文档示例。 * * @param T 这个组中的成员的类型。 * @property name 这个组的名称。 * @constructor 创建一个空组。 */class Group&lt;T&gt;(val name: String) &#123; /** * 将 [member] 添加到这个组。 * @return 这个组的新大小。 */ fun add(member: T): Int &#123; return 0 &#125;&#125;/** * An [EpoxyController] that can work with a [PagedList]. * * @param T The type of the items in the [PagedList]. */abstract class PagedListEpoxyController&lt;T&gt;( /** * The handler to use for building models. By default this uses the main thread, but you can use * [EpoxyAsyncUtil.getAsyncBackgroundHandler] to do model building in the background. * * The notify thread of your PagedList (from setNotifyExecutor in the PagedList Builder) must be * the same as this thread. Otherwise Epoxy will crash. */ modelBuildingHandler: Handler = EpoxyController.defaultModelBuildingHandler, /** * The handler to use when calculating the diff between built model lists. * By default this uses the main thread, but you can use * [EpoxyAsyncUtil.getAsyncBackgroundHandler] to do diffing in the background. */ diffingHandler: Handler = EpoxyController.defaultDiffingHandler, /** * [PagedListEpoxyController] uses an [DiffUtil.ItemCallback] to detect changes between * [PagedList]s. By default, it relies on simple object equality but you can provide a custom * one if you don't use all fields in the object in your models. */ itemDiffCallback: DiffUtil.ItemCallback&lt;T&gt; = DEFAULT_ITEM_DIFF_CALLBACK as DiffUtil.ItemCallback&lt;T&gt;) : EpoxyController(modelBuildingHandler, diffingHandler) &#123;&#125; kotlin中除了块标签与与Java有不同外，写注释时要通过内联标记来链接到元素，可以参考上面模板的注释方式。 Live Templates为了方便使用相关规范，我们使用统一的Live Templates模板来快速输入。 点击下载最新版本模板 更新历史：v1.0 增加了todo, fixme的使用范围，在kotlin中也能使用，并且增加了user信息 使用doc, 语法来快速创建类注释 参考资料： aliJava手册 编写 Kotlin 代码文档 3 开发要求]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[鸣鸣小喵日记]]></title>
    <url>%2F2018%2F12%2F13%2F%E9%B8%A3%E9%B8%A3%E5%B0%8F%E5%96%B5%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[上了一上午的课，鸣鸣非常疲惫，回到寝室看着干净、温暖的床铺，迫不及待要把自己狠狠地摔在柔软的床垫上，贪婪的呼吸因为刚刚晒过而散发清香的被子，然而，这令人心动到心脏砰砰直跳的幻想被身上几天没洗的衣服拉回了现实。 “唉，还是先吃饭吧。” 说完鸣鸣放下手中从没翻开的课本，不怀好意的告诉斜对面的张越今天老师又点名了。 “呵呵呵！” 突然，旁边传来一阵机智的笑声打断了鸣鸣的表演，原来他用了无数次的小把戏早已被人识破。 “其实没点名，啊哈哈哈” 匆忙解释了一句，鸣鸣赶紧用哈哈大笑来「自鸣得意」，大家也跟着笑了起来，空气中顿时充满了皮气。 … 鸣鸣摸了摸吃撑的肚子，因为大脑供血不足开始有些头晕眼花，想着下午还要上课愈加的烦躁，扭过头，鸣鸣贪婪的看了一眼整洁的床，又看了一眼正在战斗的小东，心里下定决心再不能让他们在自己的床上胡作飞为了。 双手趴在冰冷、坚硬、粗糙的书桌上，不时调整姿势缓解手臂的僵硬，天气渐渐转凉了，鸣鸣身上竟然只简单套了件蓝色卫衣，就睡的死气沉沉了，真让大家为他担心啊。 书桌下方的抽屉里，几只老鼠的幼崽正在瑟瑟发抖，好像在抱怨今年的寒冬来的太早了些，唉，小傻瓜们，他们可比趴在桌上睡觉的鸣鸣幸福多了啊。 没过多久，常来215做客的中华田园喵跳上了那个干净的床铺。呵，柔软、温暖的被窝，让小猫都慵懒起来，张开了时刻防备着的喵爪，撑开了四肢，伸了个大大的懒腰。为他们抓了这么久的老鼠，也该休息一下了吧~想着想着就这样小喵也和鸣鸣一起进入了梦乡。 … “啊！！！”，“喵呜~~~” 到底发生了什么？！突然传来一阵仿佛要撕裂世界的怒吼！]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「播放器」使用MediaPlayer]]></title>
    <url>%2F2018%2F08%2F02%2Fmedia-player%2F</url>
    <content type="text"><![CDATA[demo展示了 离线播放、详情页、悬浮窗等几种常见使用情况，可以参考不同的实现页面。 完整使用下面一步步介绍引入视频module步骤，完整demo查看VideoItemActivity.kt 在build.gradle中添加依赖：12implementation 'cn.com.open.mooc:ijkplayer-core:1.0.2.9-SNAPSHOT'implementation 'cn.com.open.mooc:ijkplayer-custom:1.0.2.9-SNAPSHOT' 最新版本请在setting.gradle中查看 在Activity布局文件加入Container：1234567891011121314151617181920212223242526&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;FrameLayout android:id="@+id/videoContainer" android:layout_width="0dp" android:layout_height="0dp" app:layout_constraintDimensionRatio="H,16:9" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent"&gt; &lt;!--video layer--&gt; &lt;!--cover layer--&gt; &lt;/FrameLayout&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolBar" ... &gt; &lt;/android.support.v7.widget.Toolbar&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 初始化IjkVideoView12345678// init video viewval videoViewRoot = layoutInflater.inflate(R.layout.ijkplayer_custom_player_layout, null).apply &#123; // 将整个播放器视图（包含视频、手势、控制器等）添加到container中， // 如果container添加了cover层，注意视图的层级 videoContainer.addView(this) // 初始化 mIjkVideoView = findViewById(R.id.ijkVideoView)&#125; 初始化IjkMediaPlayer配置详细内容查看MediaPlayerConfig类1234567// init media player configMediaPlayerConfig().apply &#123; mediaCodec = DecoderCompatManager.getInstance(this@VideoItemActivity).mediacodec() clearDnsCache = true startOnPrepared = false mIjkVideoView.config = this&#125; 初始化控制器12345678910111213141516171819202122// init controller// 旋转工具mOrientationUtils = OrientationUtils(this, mIjkVideoView).apply &#123; // 允许旋转到竖屏，在离线播放，或者不允许自动旋转到竖屏设置为false enablePortrait(true) // 跟随系统设置自动旋转 setRotateWithSystem(true) // 横屏时无视系统设置强制旋转 setForceRotateLand(true)&#125;// 控制器containerval controllerContainer = videoViewRoot.findViewById&lt;ViewGroup&gt;(R.id.controllerContainer)// 横屏控制器mControllerLandscape = MediaControllerLandscape(this, controllerContainer, mOrientationUtils).apply &#123; makeControllerView() ivBack.setOnClickListener &#123; onBackPressed() &#125; mBackPressedListener = backPressedListener&#125;// 竖屏控制器mControllerPortrait = MediaControllerPortrait(this, controllerContainer, mOrientationUtils, null).apply &#123; mIjkVideoView.mediaController = this&#125; 初始化手势操作层12345678// init gesture viewvideoViewRoot.findViewById&lt;GestureView&gt;(R.id.gestureView).apply &#123; attachController(mIjkVideoView) // 记录一个小时内调节过的亮度，作为初始亮度 useSaveBrightness(true) // 手势缩放监听 setScaleListener &#123; mControllerLandscape.showResetMatrix(this) &#125;&#125; 初始化功能插件123456789101112131415// init plugin// 自动旋转功能OrientationPlugin.connectPlugin(mIjkVideoView, mOrientationUtils)// 缓冲动画，可以自己传入合适的View，插件只负责在合适的时机显示、隐藏BufferingPlugin.connectPlugin(mIjkVideoView, videoViewRoot.findViewById&lt;View&gt;(R.id.lottieView))// 状态栏控制StatusBarPlugin.connectPlugin(this, mIjkVideoView)// 屏幕常亮ScreenOnWhilePlayingPlugin.connectPlugin(mIjkVideoView, true)// 音频焦点控制，每次调用ijkVideoView.start()方法都会请求音频焦点AudioManagePlugin.connectPlugin(mIjkVideoView)// 后台播放功能，结合前台服务、media session，下面有详细说明mSessionPlugin = MediaSessionPlugin.connectPlugin(mIjkVideoView).apply &#123; bindService(CustomIjkService::class.java)&#125; 开始播放：12345678910// set data// 每次播放之前，为通知栏、MediaSession设置最新的数据mSessionPlugin.setNotificationModel(model)val videoPath = "http://v3.mukewang.com/jiuyeban/5b0fa866e520e502098b4575/H.mp4"mIjkVideoView.run &#123; setVideoPath(videoPath) // 建议关闭startOnPrepared功能，每次主动调用start()方法以使各种插件生效 start()&#125; 释放资源123456override fun onDestroy() &#123; // MediaSessionPlugin一定要释放 mSessionPlugin.release() mIjkVideoView.release(true) super.onDestroy()&#125; 处理横竖屏切换视频播放过程中，横竖屏切换时，我们需要修改VideoView的大小、切换mediaController、调整状态栏12345678910111213141516171819202122232425262728// 注意在manifest中声明自己处理配置更改，在分屏模式下也保证activity不被重建android:configChanges="keyboard|keyboardHidden|orientation|screenSize|screenLayout|smallestScreenSize|uiMode"override fun onConfigurationChanged(newConfig: Configuration?) &#123; super.onConfigurationChanged(newConfig) val orientation = resources.configuration.orientation val lp = videoContainer.layoutParams if (lp is ConstraintLayout.LayoutParams) &#123; lp.apply &#123; // 调整约束属性，ConstraintLayout 2.0版本后可以使用 ConstraintProperties if (orientation == Configuration.ORIENTATION_LANDSCAPE) &#123; // handle constrain bottomToBottom = ConstraintLayout.LayoutParams.PARENT_ID dimensionRatio = null &#125; else &#123; bottomToBottom = ConstraintLayout.LayoutParams.UNSET dimensionRatio = "H,16:9" &#125; &#125; &#125; if (orientation == Configuration.ORIENTATION_LANDSCAPE) &#123; mIjkVideoView.mediaController = mControllerLandscape PlayerUtil.fullScreen(this) &#125; else &#123; mIjkVideoView.mediaController = mControllerPortrait PlayerUtil.transparentStatusBar(this, false) &#125;&#125; 旋转工具优化切换到后台时，用户可能旋转过手机，此时旋转工具还在生效，切换回前台时会触发错误的旋转动画，通过下面的方法优化此问题12345678override fun onStop() &#123; super.onStop() mOrientationUtils.disable()&#125;override fun onStart() &#123; super.onStart() mOrientationUtils.enable()&#125; 后台播放后台播放功能一般需要实现几个功能 开启前台服务，保证视频相关Activity不被销毁 前台服务需要绑定通知栏，需要实现自定义通知栏和系统通知栏两种样式，并提供控制 设置MediaSession来结合系统API 最终还要结合视频播放的特点，如及时更新移除通知栏、与现有VideoView播放状态兼容 插件中这些功能都已默认实现，只需要下面几步补充自定义控制即可： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 1. 继承AbstractIjkService类，实现createNotification方法来选择使用什么样式的通知栏public class CustomIjkService extends AbstractIjkService &#123; @NonNull @Override public PlayingNotification createNotification() &#123; PlayingNotification playingNotification; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N &amp;&amp; !PreferenceUtil.getInstance(this).classicNotification()) &#123; playingNotification = new PlayingNotificationImpl24(); &#125; else &#123; playingNotification = new PlayingNotificationImpl(); &#125; return playingNotification; &#125;&#125;// 2. 继承AbstractPlayingNotificationImpl类，实现bindAction方法，为通知提供点击的actionpublic class PlayingNotificationImpl extends AbstractPlayingNotificationImpl &#123; public static final int TYPE_PRACTICE_ITEM = 10; @NonNull @Override public Intent bindAction(int type) &#123; return getIntent(type, service); &#125; @NonNull protected static Intent getIntent(int type, AbstractIjkService service) &#123; Intent action; if (type == TYPE_DETAIL) &#123; action = new Intent(service, VideoDetailActivity.class); &#125; else if (type == TYPE_DOWNLOAD) &#123; action = new Intent(service, VideoDownloadActivity.class); &#125; else if (type == TYPE_SERVICE) &#123; action = new Intent(service, FeedActivity.class); &#125; else if (type == TYPE_PRACTICE_ITEM) &#123; action = new Intent(service, VideoItemActivity.class); &#125;else &#123; action = new Intent(service, MainActivity.class); &#125; return action; &#125; @NonNull @Override public int getSmallIcon() &#123; return R.mipmap.ic_launcher_round; &#125;&#125;// 3. 初始化插件mSessionPlugin = MediaSessionPlugin.connectPlugin(mIjkVideoView).apply &#123; // 必须要调用此方法 bindService(CustomIjkService::class.java)&#125;// 4. 每次播放新的视频时必须设置（更新）数据mSessionPlugin.setNotificationModel()// 5. 退出视频播放页时释放插件mSessionPlugin.release() 注意事项： AbstractIjkService中不包含任何MediaPlayer信息，仅作为数据展示和简单的播放控制。由MediaActionListener回调播放/暂停操作，实际播放控制都由IjkVideoView完成。 设置各种监听1234mIjkVideoView.addOnErrorListener &#123; _, _ -&gt; false&#125; 视图相关功能所有视图布局部分都只提供了默认实现，可以根据需求copy一份，替换为自己的文件 更新日志v1.0.2.2-SNAPSHOT 解码基本正常 *添加media session plugin 修改播放本地文件错误 修改网络切换处理 优化屏幕常亮 OrientationUtils添加横屏强制旋转方法 v1.0.1.13-SNAPSHOT 添加播放中切换网络连接处理 v1.0.1 调整项目结构，移除core非播放器功能，custom增加基础功能 补充其他平台so库]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「播放器」Android视频开发介绍]]></title>
    <url>%2F2018%2F08%2F01%2FAndroid-video-player%2F</url>
    <content type="text"><![CDATA[移动端流媒体随着各种视频app的火爆，以及移动流量的升级逐渐占据人们大量宝贵的时间。但是从开发小白的角度来看，这一直是个很有难度的开发领域，真正深度接触视频业务的app也不多，恰好有了浅度的需求，往往又会花费大量的时间了解、踩坑。「播放器」系列文章的目的，就是想完成一个「还可以的」实践，读完文章也能达到实践的程度。基于ijkplayer这篇文章更多的是总体的介绍，会随着理解加深不断更新。 0 播放器基本原理首先简单了解一下播放器的基本原理和结构。 主要包含以下几个步骤： 数据接收(数据获取、解协议) 解封装(demux) 解码 音视频同步（图中没有） 输出 解封装：将多个轨道的数据分解出来，比如一个mp4格式的文件解封装后输出H.264编码的视频流、aac编码的音频流解码：将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据 结合上面的结构来看，客户端的视频开发主要包含了：视频源、播放器、业务场景几个部分，下面逐个进行分析。 1 视频源视频源决定了传输协议、封装格式、编码类型，影响着播放器内核的选择、支持格式的拓展，以及加解密。一般来说播放器开发时视频源都是已经确定了的，我目前使用的视频源主要是HLS（m3u8 + ts），部分使用MP4封装，H.264 AAC编码，ijkplayer和ExoPlayer都支持良好。 传输协议：hls，crypto加密 封装格式：ts切片 编码类型：H.264 AAC M3U8视频源的加解密视频源的加解密环节也相当重要，项目中m3u8文件和hxk key都进行了加密，需要通过接口获取并解密，标准的hls协议并不支持，其中m3u8文件经过解密后可直接使用，但hxk文件是在播放器内部实现hls协议时处理的，如果不修改native代码的话，就需要自定义hxk文件获取的过程。加解密的过程会单独开文章分析。 视频源也可以叫DataSource、MediaSource，包含了众多的分类，如果想要详细了解可以参考exoplayer的实现。 2 播放器播放器要完成获取视频流、解码、输出到屏幕，最后还要提供丰富的功能，这一系列的操作主要由MediaPlayer、SurfaceView、Controller和相关功能模块组成，下面逐一介绍。 MediaPlayer：负责音视频流的获取、解码、输出、状态控制。 SurfaceView：负责解码后视频帧的显示（大小、比例、方向等）。如SurfaceView、TextureView、GLSurfaceView，项目中主要使用TextureView Controller：播放器相关的功能控制。进度条、手势操作、播放速度、画面显示比例、屏幕锁等 其他功能：如音频焦点、屏幕常亮、后台播放、旋转、状态栏控制等 MediaPlayer对于MediaPlayer来说，以下能力非常关键： 网络能力：支持各种预期的协议，如完整的支持hls各种特性，有良好的网络能力，如各种拉流的控制、容错 解码能力：能够支持预期的格式（点播时，视频格式通常都是确定的几种），不能（不适合）硬解时提供软解 兼容性：在各种设备上的解码能力和解码策略 功能特性：播放速度（变速不变调）、精准seek、max-fps、缓冲区大小（基于FFmpeg） 信息反馈：返回准确丰富的状态信息、错误信息 MediaPlayer的能力是播放器的基础，这个环节ijkplayer等都已经实现（网络功能直接集成在内部），我们主要是理解相关api的效果和如何使用。除此之外，通过接口，我们还可以使用不同的mp，不过不同的mp功能特性差别很大，实际项目中还是要使用综合考虑最优秀的。 Surface接下来是视频的显示，常用的主要是SurfaceView、TextureView两种，如果要添加特效、滤镜之类的则需要用到opengl。对于视频的显示来说，以下能力非常关键： 切换前后台的流畅度（在有些设备上Surface会被销毁重建） 对软硬解的兼容（比如软解+TextureView，重复使用TextureView会出现被锁住的情况） 旋转、缩放、平移综合来看大家最终都选择了TextureView，同样的也可以使用接口来使用不同的surface SurfaceView和TextureView的比较已经有了很丰富的资料，这里简单介绍下在视频播放中主要的差别： SurfaceView的实现是在屏幕上“挖洞”，在Android N以下版本界面移动时会有很严重的黑边 SurfaceView播放效率略高于TextureView TextureView可以使用view的各种方法，比如说matrix 到这里VideoView就诞生了，mediaplayer + surface组合成了VideoView核心部分，和音频播放不同，mediaplayer 和 surface之间既独立又充满联系，他们之间的配合和影响后面单独开文章分析。 Controller复习一下，Controller负责播放器相关的功能控制，如进度条、手势操作、播放速度、画面显示比例、屏幕锁、切换清晰度等。也就是这个画面。 针对视频播放，系统提供了MediaController类给我们使用，但是自定义性差，还非常丑。。。不过却提供了很好的与VideoView一起协作的示例，完全可以copy一份，然后根据需求修改。针对横屏和竖屏一般会有两套Controller，所以这里我们也使用接口，既满足和VideoView的交互，又可以随时替换不同的实现。 Controller已经是我们需要开发的核心部分了，比如手势控制、沉浸式下显示popup window等，可以单开一篇来介绍，这里就不细说，也可以在demo中查看效果和具体实现。 丰富的功能只使用VideoView进行播放的场景估计只有广告了^_^，所以除了基础的控制功能之外，我们还要提供丰富的功能来提升使用体验，比如音频焦点、屏幕常亮、后台播放、旋转、悬浮窗、网络状态切换、状态栏控制，这一部分大多数需要与播放器的状态关联，同时较少或者几乎没有涉及到业务逻辑，也是开发的核心部分。与上面一样，很多细节都可以单开一篇来介绍，后续会逐渐完善。 至此可以看到播放器的部分和业务的交集很小，很容易整理成lib，将与UI无关的部分抽象出来，与UI、业务依赖多的部分也可以提供默认的实现以供参考。 3 业务场景上面的内容好像将播放器几乎都涵盖了，但实际上缺少了非常重要的一个环节，业务场景。我非常认同这个的观点，我们要做懂技术，也懂行业、懂业务的人。 所以呢，这个部分我们会简单讨论一下当前热门的视频应用和他们实现的效果，然后我们进行仿写。业务范围： 单视频点播：参考APP：bilibili、爱奇艺，特点：弹幕、播放详情页面、后台播放、播放详情页面、播放列表 离线播放 feed流：参考APP：bilibili weibo 网易云音乐 短视频 小窗播放：参考APP：youtube，特点：小窗口view、画中画 直播：参考APP：bilibili，特点：直播、悬浮窗 此外还有一个特别重要部分：视频编辑（还包括直播推流、特效等），因为暂时没有接触，这部分不会涉及。 敬请期待~ 及时更新的版本可以在我的blog看到.]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ConstraintLayout「最全总结」]]></title>
    <url>%2F2018%2F07%2F11%2FConstraintLayout%2F</url>
    <content type="text"><![CDATA[现在大家几乎都使用过ConstraintLayout，但与经常使用的布局相比，可能会面临不熟悉CL的API或者是逐渐增加的新特性，还有可能因为对CL具体行为的理解模糊而导致误用，这篇文章的目的更多的是，全面总结ConstraintLayout的用法和实际行为特性，并不断更新 基于ConstraintLayout 1.1，当前2.0版本处于测试阶段参考文章：ConstraintLayout入门指南 为什么要引入ConstraintLayout 减少布局层级：常用的布局划分成了几个不同的类型，要组合不同的功能需要通过嵌套的形式实现，比如想要按比例布局就要使用layout_weight属性，想要使用layout_weight属性就要使用LinearLayout（以下简称LL）或者TableLayout，然后你在原先同级的每个布局外再嵌套一层布局以使用layout_weight。 更多的布局需求：要实现固定宽高比、百分比布局，灵活控制大小等更高阶的布局需求，原先的各类布局方式都不能很好的支持，可能需要通过Java代码，在运行中二次实现。 想要通过ConstraintLayout来 优化性能，可能并不明显 亦或者你只是想尝试下这款Andorid官方力推的新布局，看看它有什么新特性。 引入lib:1234//确保SDK Tools中已经下载了ConstraintLayout的支持库：dependencies &#123; implementation 'com.android.support.constraint:constraint-layout:1.1.2'&#125; 开始之前，我们应该意识到在布局文件中Layout主要职责是什么，控制widgets的位置和大小。下面将从这两个方向出发，看看ConstraintLayout是怎么做的。 1. 控制位置layout中的view都有四个方向left(start), right(end), top, bottom，通过这些方向在两个view之间建立约束来实现基础的位置控制，相对于RelativeLayout，RL中所有的属性CL中都有与之对应的项目，稍加熟悉即可完成转换： 相对于父布局的相对布局属性，CL的规则是：将父布局当做一个id=”parent”的对象来对待： 1.1 Margins设置普通的margin： 1.2 visibility 对约束的影响特殊的情况是：连接到visibility为GONE的view时的margin，在ConstraintLayout中，当widgets被设置View.GONE时进行了特殊处理。 根据布局的传递，设置为GONE的view相当于大小被设置为0(实际上是被设置成了一个点) 如果他们已经跟其他的组件产生了约束关系，约束关系还是会存在，但是所有的margin都会变成0 也可以使用goneMargin来保持预期的边距 这种特殊的处理，可以在你临时的把view设置为GONE时，不破坏布局结构。 1.3 居中和偏移居中的设置参考之前于RelativeLayout的对应关系，CL增加了偏移属性，使用偏移可以更好的处理屏幕大小改变时的情景。 布局中设置：123456&lt;android.support.constraint.ConstraintLayout ...&gt; &lt;Button android:id="@+id/button" ... app:layout_constraintHorizontal_bias="0.3" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent/&gt;&lt;/&gt; 1.4 圆形的位置使用圆形约束，在创建圆形的菜单时非常有用 12345&lt;Button android:id="@+id/buttonA" ... /&gt;&lt;Button android:id="@+id/buttonB" ... app:layout_constraintCircle="@+id/buttonA" app:layout_constraintCircleRadius="100dp" app:layout_constraintCircleAngle="45" /&gt; 2. 控制尺寸(大小)2.1 给ConstraintLayout自己添加大小限制当ConstraintLayout的大小设置为WRAP_CONTENT时，可以很方便的设置自己的最大宽高 2.2 Widgets的尺寸(大小)约束和我们在常用的布局中设置宽高一样，控制Widgets的宽度和高度一共有3种方式： 固定的大小，如123dp WRAP_CONTENT 自适应 0dp，等于MATCH_CONSTRAINT，类似于match_parent，会利用所有可用的空间。注意，不建议使用match_parent 2.3 WRAP_CONTENT 强制约束默认情况下，设置为WRAP_CONTENT的组件不会限制他们的大小，有时会导致超出约束条件的情况，如果需要强制他们满足约束条件的话，使用下面的强制约束12app:layout_constrainedWidth=&quot;true|false&quot;app:layout_constrainedHeight=&quot;true|false&quot; 2.4 MATCH_CONSTRAINT 大小控制默认情况下，MATCH_CONSTRAINT 会利用所有可用的空间，通过下面的设置，可以自定义具体的行为 layout_constraintWidth_min and layout_constraintHeight_min layout_constraintWidth_max and layout_constraintHeight_max layout_constraintWidth_percent and layout_constraintHeight_percent 使用百分比大小时，对应方向的大小必须设置为 MATCH_CONSTRAINT 2.5 使用比例使用比例有两种情况，而且必须至少有一条边被设置为0dp： 如果只有一条边被设置为0dp，设置比例时，将参考另外一条已经确定尺寸的边 如果两条边都被设置为0dp，那么会在满足比例的条件下，设置为最大尺寸 同样的支持直接设置layout_constraintWidth_percent和layout_constraintHeight_percent来使用百分比控制相对于parent的比例1234567891011121314&lt;Button android:layout_width="wrap_content" android:layout_height="0dp" app:layout_constraintDimensionRatio="1.6" /&gt;&lt;Button android:layout_width="wrap_content" android:layout_height="0dp" app:layout_constraintDimensionRatio="1:1" /&gt;&lt;Button android:layout_width="0dp" android:layout_height="0dp" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintDimensionRatio="H,16:9" app:layout_constraintTop_toTopOf="parent" /&gt; 2.6 ChainsChains能自定义在同一轴线上view的位置和大小，首先我们来创建一条链，当widgets之间在同一个方向上相互连接(相互约束)时，链就形成了。 2.6.1 链的head水平方向chain最左边的控件和垂直方向chain最顶部的控件被成为head chain。通过对head chain添加chainStyle属性，可以设置该条chain在水平或垂直方向上的chainStyle 2.6.2 Chain Style12layout_constraintHorizontal_chainStylelayout_constraintVertical_chainStyle chainStyle属性一共有三种：spread、spread_inside、packed。再配合其他属性，最终可以组成五种chain style： 其他四种chain style的设置和效果都比较简单，重点介绍下Weighted Chain。 默认的spread模式，每个元素获得同样的空间，如果一个元素使用了0dp，将会占用剩下的所有可用空间 layout_constraintHorizontal_weight和layout_constraintVertical_weight可以用来控制同样设置为0dp的控件的比例 Weighted Chain中的控件也允许在chain方向上使用wrap_content自适应控件宽/高，且布局时优先满足设置为wrap_content的控件，相当于优先满足设置了指定宽高的控件 当设置了margin时，margin生效的同时weight的比例不变，链上的控件实际占有布局会被压缩 3. 不可见的辅助工具GuidelinebarrierGroup4. 用代码的方式操作ps. 选择优化类型Package Index:android.support.constraintandroid.support.constraint.helperandroid.support.constraint.motionandroid.support.constraint.utils]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「播放器」不自由的旋转]]></title>
    <url>%2F2018%2F06%2F11%2Fplayer-orientation%2F</url>
    <content type="text"><![CDATA[屏幕旋转是开发播放器过程中大家都会实现的基础功能，简单的说，就是接管手机方向的旋转控制，那为啥不直接用默认的旋转功能呢，主要是 播放页面有其他的显示内容，而这些内容的布局不适合在横屏下显示 有特殊需求，比如在软件中锁定方向、未播放时不允许旋转等等 在系统锁定方向时，依旧可以旋转 在不同的使用场景下对旋转的约束变的复杂起来，旋转也越来越”不自由”，这篇文章的目的是：如果你对屏幕旋转逻辑不够清晰，还对屏幕旋转的功能细节不够满意的话，一起来将整个逻辑思考清楚吧。 废话不多说先简单回顾一下基础知识。 基础回顾 设置屏幕方向很简单，通过activity.setRequestedOrientation(@ActivityInfo.ScreenOrientation)方法实现控制界面的方向（还可以控制旋转模式），具体的参数意义可以在文档中查看。 获取当前屏幕方向只能设置方向可不行，先得知道当前是什么方向。通过activity.getWindowManager().getDefaultDisplay().getRotation()方法来获取当前方向，注意返回值为@Surface.Rotation类型。WindowManager也可以通过Context获取。 自动旋转如果要实现更复杂的控制，还需要知道当前手机的角度。通过OrientationEventListener(activity)来监听屏幕方向(角度)的变化，监听的onOrientationChanged(int rotation)方法中，实时返回了当前设备的角度。 处理旋转导致的activity变更大家都知道旋转会导致activity重建，可以在AndroidManifest文件中修改activity的configChanges配置，即可在onConfigurationChanged(newConfig: Configuration?)方法中自行处理旋转变更，具体参考处理运行时变更。 12// 视频播放中常用的配置android:configChanges="keyboard|keyboardHidden|orientation|screenSize|screenLayout|smallestScreenSize|uiMode" 功能分析旋转功能可以实现的非常简单，也可以相对复杂，具体要看应用的场景，下面分析几个常见应用。 抖音最简单，没有旋转^_^ ，值得一提的是适配了视频源的方向，让视频看起来更舒服。 YouTube整个应用都支持旋转，播放页面多了一个全屏和非全屏的切换按钮。旋转的逻辑比较简单，但横竖屏切换对布局处理的逻辑复杂，也暂时不在本文的介绍范围。 bilbili点播页面旋转逻辑相对于YouTube复杂了一些，比如视频未播放时不支持自动旋转，支持屏幕锁，显示菜单时不允许旋转，可能还有很多我没发现的细节。 bilbili离线播放更简单一点，只支持横屏，但上面的功能也没少。 实现方式Android系统既提供了预设的旋转模式，也提供完全自由的控制，分别通过activity.setRequestedOrientation(@ActivityInfo.ScreenOrientation)方法，OrientationEventListener(activity)监听器来实现。因此这就为解决问题提供了两种思路， 通过组合系统的预设模式来达到预期效果 通过监听角度变化，配合需要的限制来完全自定义旋转效果 不管使用哪种方式，两个API都要结合使用，基础的旋转大家都能轻松做到，但要达到比较好的用户体验，细节往往决定成败┐(ﾟ～ﾟ)┌。 主动点击了全屏按钮屏幕会不会自己又转回来了？ 全屏状态下点击返回键是直接退出当前页面，还是回到竖屏？ 两个方向横屏的情况点击回到竖屏处理的是不是正确的？ 有没有适配默认方向为横向的Android平板?blablabla…今天就好好把这一切捋清楚&lt;(￣︶￣)&gt;，接下来分析一下常见的错误和如何优化。 值得注意的是，参数rotation的意义。 1234567891011121314/** * Called when the orientation of the device has changed. * orientation parameter is in degrees, ranging from 0 to 359. * orientation is 0 degrees when the device is oriented in its natural position, * 90 degrees when its left side is at the top, 180 degrees when it is upside down, * and 270 degrees when its right side is to the top. * &#123;@link #ORIENTATION_UNKNOWN&#125; is returned when the device is close to flat * and the orientation cannot be determined. * * @param orientation The new orientation of the device. * * @see #ORIENTATION_UNKNOWN */abstract public void onOrientationChanged(int orientation); 就这么简单，就这一个方法和一个监听器。旁白君：这么简单还讲毛线哇 (⊙ˍ⊙)，散了散了…！！！大家慢走，的确就这两个东东，但还要组合4个方向，两个操作，两个状态，还有balabala… 旁白君：有人装神弄鬼啦，大家快走！。 哈哈，言归正传~这些状态和操作一开始组合起来真的把我弄晕了，不过冷静下来思考之后，回归了简单。 情景分析首先看看手机方向示意图： 为什么会弄晕我，大家来看看下面的细节，由浅入深： 屏幕跟着手机旋转 在竖直方向点击横屏后，屏幕方向保持横向，不会自动转回来（同时也适用于横向的情况） 反向横屏的时候，点击竖屏，应该回到正向竖屏。反向竖屏的时候，点击横屏应该回到”正向”横屏。（保证都能回到正向竖屏，同时保持协调） 在2和3的条件下，比如在竖直方向点击横屏后，屏幕方向保持横向，然后手机屏幕旋转到横向后，再旋转到竖向时，屏幕应该跟随手机旋转到竖向。（相当于旋转到期望状态后，限制就自动解除） 在以上逻辑的前提下，旋转屏幕，手机应正常保持跟随旋转。（只限制应该限制的方向） 没这么复杂啊，你是不是在糊弄我？。。。咳咳，真的不是我太纠结，追求完美是吧。那么这些逻辑哪里复杂了？哪些条件又存在冲突呢。 矛盾的点： 「横屏、反向横屏」，「竖屏、反向竖屏」时，点击恢复按钮都需要都需要恢复到”正向”状态，且旋转后不能立刻恢复。 限制条件启动后，除了限制旋转的方向外，手机应正常保持跟随旋转 限制条件启动后，在旋转到期望状态后，解除限制 这里横向的”正方向”不重要，顺时针和逆时针都行。矛盾的关键就是： 正向时点击产生的限制与手机应正常保持跟随旋转 反向时点击产生的限制与手机应正常保持跟随旋转 限制与解除限制 正确的思路为了保证不先把我自己弄晕，直接来看正确的思路。o(￣▽￣)ｄ 切记不能跟着条件一个个满足，这就会进入矛盾的漩涡，解决了这个对立的那个又不满足了。 处理旋转逻辑的思路： 准确的知道当前方向（当前方向不能作为标志保存，必须实时获取） 保存点击时的方向，提供限制 旋转到非限制方向时，解除限制 这就好办了，首先我们完成最基础的，跟随手机的角度旋转屏幕： 再加上点击后屏幕旋转到竖(横)向正方向的功能： 注意开启功能1orientationEventListener.enable(); 这个时候我们会发现问题，没有满足这个条件：1在竖直方向点击横屏后，屏幕方向保持横向，不会自动转回来（同时也适用于横向的情况） 记住原来的教训：不能跟着条件一个个满足。问题的根本是我们要提供限制，并且在旋转到非限制方向时，解除限制。限制是什么，是我们不能旋转回原来的方向，所以我们记录下了点击时的方向：1mOldScreenRotation = activity.getWindowManager().getDefaultDisplay().getRotation(); 那什么时候解除限制呢，旋转到非原始方向时就解除限制1234567891011121314151617181920212223242526272829303132333435363738394041424344mScreenRotation = activity.getWindowManager().getDefaultDisplay().getRotation();// 自动竖屏if (((rotation &gt;= 0) &amp;&amp; (rotation &lt;= 15)) || (rotation &gt;= 345)) &#123; if (mOldScreenRotation != Surface.ROTATION_0) &#123; //解除限制 mOldScreenRotation = -1; //-1不代表任何方向 &#125; if (mScreenRotation == Surface.ROTATION_0 || (mOldScreenRotation != -1)) &#123; //当前的角度和屏幕方向一致，不处理 //没有旋转到非原始方向，被限制 return; &#125; activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);&#125;// 自动反向横屏else if (rotation &gt; 75 &amp;&amp; rotation &lt; 105) &#123; if (mOldScreenRotation != Surface.ROTATION_270) &#123; mOldScreenRotation = -1; &#125; if (mScreenRotation == Surface.ROTATION_270 || (mOldScreenRotation != -1)) &#123; return; &#125; activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);&#125;// 自动反向竖屏else if (rotation &gt; 165 &amp;&amp; rotation &lt; 195) &#123; if (mOldScreenRotation != Surface.ROTATION_180) &#123; mOldScreenRotation = -1; &#125; if (mScreenRotation == Surface.ROTATION_180 || mOldScreenRotation != -1) &#123; return; &#125; activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);&#125;// 自动横屏else if (((rotation &gt;= 255) &amp;&amp; (rotation &lt;= 285))) &#123; if (mOldScreenRotation != Surface.ROTATION_90) &#123; mOldScreenRotation = -1; &#125; if (mScreenRotation == Surface.ROTATION_90 || (mOldScreenRotation != -1)) &#123; return; &#125; activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);&#125; 注意Surface.ROTATION_270和onOrientationChanged(int rotation)的角度正好是相反的]]></content>
      <categories>
        <category>播放器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「播放器」Mac上编译ijkplayer so支持HTTPS]]></title>
    <url>%2F2018%2F06%2F07%2Fbuild-ijkplayer%2F</url>
    <content type="text"><![CDATA[当项目中使用ijkplayer，而且还需要播放HTTPS链接的视频时，就比较蛋疼了 (￣.￣)，ijkplayer默认不支持HTTPS播放，但提供了编译OpenSSL的选项，可以自己编译so文件支持HTTPS播放。这篇文章的目的是引导不熟悉的人完成整个编译过程，提醒过程中的注意事项，还有各种选项的解释。 我的编译环境VMware + Ubuntu编译环境也可以参考，基本上只有命令不同，homebrew的安装这里不再赘述。非常不建议在Windows环境下编译！123456Mac 10.13.2iTerm2 + zshHomeBrewNDK r10eNDK + 编译所有so大概需要10GB空间 相关链接: Bilibili/ijkplayer IJKPlayer编译so支持HTTPS的踩坑历程 ijkplayer编译so库真没那么难 1. 准备工作安装Git与yasm12brew install gitbrew install yasm 配置SDK、NDKSDK都会有，NDK一般没有下载，建议去官网下载:https://developer.android.google.cn/ndk/downloads/older_releases 需要注意的是最好下载官方lib使用的NDK r10e，使用其他版本的将无法编译。具体原因可以参考这篇issue SDK、NDK和准备完成后，在.bash_profile, 或者是.zshrc中添加配置。(Command + shift + . 显示隐藏文件) 123456// 注意替换为自己的文件路径export ANDROID_SDK=/Users/haoyuan/Library/Android/sdkexport PATH=$ANDROID_SDK/platform-tools:$PATHexport PATH=$ANDROID_SDK/tools:$PATHexport ANDROID_NDK=/Users/haoyuan/Library/Android/android-ndk-r10eexport PATH=$ANDROID_NDK:$PATH 添加完成后，保存文件，然后source .bash_profile等相关文件，或者直接重启终端，通过 ndk-build -v 检查是否生效 clone ijkplayer源码123git clone https://github.com/Bilibili/ijkplayer.git ijkplayer-androidcd ijkplayer-androidgit checkout -B latest k0.8.8 2. 编译之前编译前选择你的配置选择自动化编译时的一些配置选项，比如支持的协议，音视频类型等，官方给我们提供了三个模板。 可以打开config/目录下config/module.sh看看，enable启用，disable禁用123module-default.shmodule-lite-hevc.shmodule-lite.sh 官方默认建议选择的是 module-lite.sh，可以根据自己的需求选择123cd configrm module.shln -s module-lite.sh module.sh 如果要选择module-default.sh的话，可能会编译失败，可以参考这篇issue123仔细阅读module-lite.h 原来在最下面有一行配置：export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --disable-linux-perf&quot;把这行复制到module-default.sh 的最后面就可以了 在编译配置中可以增减需要的模块，选择需要支持的封装格式、编解码类型、协议能有效减小so库的体积。可以参考CarGuo/GSYVideoPlayer DECODERS.md 3. 开始编译ヽ(｀⌒´)ﾉ执行初始化初始化会下载各种包，尽量选择在良好的网络环境下╮(￣▽￣)╭12cd .../init-android.sh 初始化OpenSSL1./init-android-openssl.sh 编译OpenSSL和FFmpeg首先清除一波123cd android/contrib./compile-openssl.sh clean./compile-ffmpeg.sh clean 编译OpenSSL：可以选择不同版本，全量编译耗时更长，但最好选择全量编译，编译完成后再根据需求选择要使用的包。1./compile-openssl.sh all 编译FFmpeg，同样的123./compile-ffmpeg.sh all// 如果要选择特定的架构: ./compile-ffmpeg.sh armv7a | armv5 最后编译ijkplayer1./compile-ijk.sh all 经过漫长的等待终于完成了以上编译过程\（￣︶￣）/，在目录中生成了ijkplayer的工程 4. 导入项目原有的项目一般是这样配置的12implementation &apos;tv.danmaku.ijk.media:ijkplayer-java:&apos; + gradle.ijkplayer_javaimplementation &apos;tv.danmaku.ijk.media:ijkplayer-armv7a:&apos; + gradle.ijkplayer_java 如果只需要修改so库的话，删除掉第二行对so库的引用，将自己编译好的so文件复制到项目的libs文件夹中。 别忘了在gradle中配置，要不然会报错找不到so库 还可以在release包中设置abi过滤 最后大功告成啦\(^o^)/ 尾巴… 如果项目中同时使用了HTTP和HTTPS的视频源的话，要注意如果视频源刚好是相同域名，会导致播放失败，这是由于dns缓存造成的，解决办法参考这篇issue初始化IjkMediaPlayer时，设置清除dns cache1234567IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;dns_cache_clear&quot;, 1//还要注意开启相关支持的协议IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;protocol_whitelist&quot;, &quot;async,cache,crypto,file,http,https,ijkhttphook,ijkinject,ijklivehook,ijklongurl,ijksegment,ijktcphook,pipe,rtp,tcp,tls,udp,ijkurlhook,data&quot;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「播放器」Android音频焦点]]></title>
    <url>%2F2018%2F04%2F24%2FAndroid%20Sound%20overlap%2F</url>
    <content type="text"><![CDATA[音视频播放在手机日常使用中非常频繁，当我们听着音乐刷着微博时，看到有趣的视频点击开始播放，音乐自动暂停，退出视频时音乐又自动恢复了播放(如果没有自动恢复的话，比如QQ音乐就会提示是否设置中断后继续播放)。 这一系列流畅自然的操作不是理所应当的吗~当然如果处理不好的话就会出现声音重叠，音频焦点长期被占用的问题，下面我们来看看具体的功能逻辑。 音频焦点相关的讲解参考以下文章 Android音频焦点详解Managing Audio Focus Managing Audio Focus不同的APP可以同时播放音频，系统会将他们混合在一起，但为了避免同时播放，Android提供了audio focus机制来合理使用音频播放资源。同一时间只能有一个APP获取音频焦点，当需要播放音频时，应该立即请求音频焦点，同样的，在你的APP获取到音频焦点后，其他APP也可以抢占音频焦点，这时你的APP就需要暂停播放或降低声音。音频焦点是合作类型的，APP拥有完全自主的控制权，系统无法阻止，但应用应该遵守音频焦点的指导规则。 好的音频APP在播放时应该遵守以下规则： 开始播放后立即调用requestAudioFocus()方法，并验证返回值为AUDIOFOCUS_REQUEST_GRANTED 当其他app占用音频焦点时，暂停或停止播放，或者降低声音 当播放停止时，放弃音频焦点 在不同的Android版本下，需要使用不同的方法来处理音频焦点： API level 8以后，使用requestAudioFocus()和abandonAudioFocus()方法，并注册AudioManager.OnAudioFocusChangeListener接收回调。 API level 21以后，需要使用AudioAttributes来描述播放音频的类型。 API level 26以后，需要使用AudioFocusRequest参数，它携带了音频的context和相关功能，系统会根据这些自动管理音频焦点。 Android8.0以前参考官方文档获取焦点的方法如下： 123456// Request audio focus for playbackint result = am.requestAudioFocus(afChangeListener, // Use the music stream. AudioManager.STREAM_MUSIC, // Request permanent focus. AudioManager.AUDIOFOCUS_GAIN); 但在听音乐的时候播放音频或视频，依旧出现了重叠的声音，实际上有效的做法是这样的12345//下面两个常量参数试过很多 都无效，最终反编译了其他app才搞定，汗~ int requestFocusResult = mAudioManager.requestAudioFocus( mAudioFocusChangeListener, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN_TRANSIENT); 具体参考文章Android MediaPlayer音频焦点问题，抢占声道 最后在对应的播放状态下获取和释放音频焦点。 Android8.0之后和之前一样，Android8.0中也使用了requestAudioFocus()来请求音频焦点，不一样的是，使用abandonAudioFocusRequest()释放音频焦点，并且请求和释放都需要传入同一个AudioFocusRequest实例。使用AudioFocusRequest.Builder来创建，具体实现代码参考官方文档Audio focus in Android 8.0 and later。 123456789101112mAudioFocusRequest = new AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN) .setAudioAttributes(new AudioAttributes.Builder() .setUsage(AudioAttributes.USAGE_MEDIA) .setContentType(AudioAttributes.CONTENT_TYPE_MOVIE) .build()) .setAcceptsDelayedFocusGain(true) .setOnAudioFocusChangeListener(mAudioFocusChangeListener) .build();//请求音频焦点 requestFocusResult = mAudioManager.requestAudioFocus(mAudioFocusRequest);//释放音频焦点abandonFocusResult = mAudioManager.abandonAudioFocusRequest(mAudioFocusRequest); 注意事项： Android8.0中其他APP使用AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK参数获取焦点时，将不会回调本APP的onAudioFocusChange()方法。 焦点延迟获取，当焦点被其他APP“锁”住时，requestAudioFocus()会返回AUDIOFOCUS_REQUEST_FAILED，比如正在打电话时，焦点就会被锁住。如果使用了setAcceptsDelayedFocusGain(true)方法，请求将会返回AUDIOFOCUS_REQUEST_DELAYED，在锁解除后，系统会继续处理未完成的焦点请求，并回调onAudioFocusChange()方法。 处理音频焦点变化了解相应的请求、释放方法后，还需要进一步处理音频焦点变化问题，也就是优化跟其他APP或者是系统APP合作的过程。主要是处理onAudioFocusChange方法：12345678910111213141516171819202122232425262728293031323334private AudioManager.OnAudioFocusChangeListener mAudioFocusChange = new AudioManager.OnAudioFocusChangeListener() &#123; @Override public void onAudioFocusChange(int focusChange) &#123; switch (focusChange)&#123; case AudioManager.AUDIOFOCUS_GAIN: //当其他应用申请焦点之后又释放焦点会触发此回调 //可重新播放音乐 Log.d(TAG, "AUDIOFOCUS_GAIN"); start(); break; case AudioManager.AUDIOFOCUS_LOSS: //长时间丢失焦点,当其他应用申请的焦点为AUDIOFOCUS_GAIN时， //会触发此回调事件，例如播放QQ音乐，网易云音乐等 //通常需要暂停音乐播放，若没有暂停播放就会出现和其他音乐同时输出声音 Log.d(TAG, "AUDIOFOCUS_LOSS"); stop(); //释放焦点，该方法可根据需要来决定是否调用 //若焦点释放掉之后，将不会再自动获得 mAudioManager.abandonAudioFocus(mAudioFocusChange); break; case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT: //短暂性丢失焦点，当其他应用申请AUDIOFOCUS_GAIN_TRANSIENT或AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE时， //会触发此回调事件，例如播放短视频，拨打电话等。 //通常需要暂停音乐播放 stop(); Log.d(TAG, "AUDIOFOCUS_LOSS_TRANSIENT"); break; case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK: //短暂性丢失焦点并作降音处理 Log.d(TAG, "AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK"); break; &#125; &#125; &#125;; 最后音频相关的API常常让人疑惑，明明已经根据注释的描述和官方文档中的方法实现了，却达不到预期的效果。还有就是随着Android更新的推送速度越来越快，更新普及率也水涨船高，高版本API随时在发生变化，适配时需要注意这些细节，以及进行完善的测试。 工具类参见AudioFocusManager 未完成内容源码简单分析 在不同机型中进行测试]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[创建和销毁对象]]></title>
    <url>%2F2017%2F12%2F19%2Fcreate-and-destroy-objects%2F</url>
    <content type="text"><![CDATA[创建和销毁对象静态工厂方法代替构造器静态工厂方法与设计模式中的工厂方法不同。 优势 静态工厂方法有名称， 遇到多个构造器参数时，使用构建器-Builder模式1.使用构造方法创建对象重叠构造器 2.JavaBeans模式通过setter方法设置必要参数，拥有良好的可读性。缺点：构造过程中容易被改变，处于不一致的状态。 3.Builder模式通过公开的Builder内部类，私有的构造方法，构造必传参数和可选参数。Builder模式模拟了具名的可选参数，可以加强约束条件，在对象域中进行检验。可以在编译时进行异常检查。 缺点：特殊情况下额外的性能开销，冗长。适用情况：多个参数(大于4个)，需要比JavaBeans模式更加安全的情况。 参见 Notification 或 Alertdialog类。 用私有构造器或者枚举类型强化singleton属性为了防止反射调用私有构造方法、反序列化时创建新的实例，直接使用 包含单个元素的枚举类型. 12345public enum Elvis&#123; INSTANCE; ...&#125; 避免创建不必要的对象39条 应该创建新对象时，不要重用现有对象创建不必要的对象只会影响程序的风格和性能，没有实施保护性拷贝将会导致潜在的错误和安全漏洞。 消除过期的对象引用内存泄露]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mifare 1k S50卡]]></title>
    <url>%2F2017%2F12%2F13%2FM1%20card%2F</url>
    <content type="text"><![CDATA[背景：最近的项目中涉及到读写M1卡，之前完全没接触过一脸懵逼，却没意识到，生活中常用的公交卡、门禁卡、开水卡、会员卡等等大多数都是M1类的射频卡，如Mifare 1k S50系列。熟悉了相关知识后，发现原理如此简单，感谢开源也因此能做很多方便的事情了。记录一下，面对陌生的事物不要害怕，了解熟悉，探索乐趣。 基础知识M1卡M1卡结构 从上面可以看到，扇区0 块0固化了厂家代码，32位16进制数，一般作为ID使用。 每一个扇区的块3用于保存KEY A,存取控制,KEY B，除了扇区0的块0之外的其他的块0~块2都用于存储数据。KEY A不可读、可写，KEY B可读可写. 一般的门禁卡中，不存储任何数据，门禁系统只读取卡ID，学校里使用的开水卡，一般是离线使用，卡的余额或者使用次数是存储在卡中的，使用时进行读写。在武汉通中，存储了卡余额，储值、消费记录，具体的余额存储在服务器上。所以理论上可以模拟卡ID来模拟门禁卡，或者是读取修改水卡值来修改卡。 读写卡工具MIFARE Classic Tool, MifareClassicTool - GitHub 模拟卡工具NFC卡模拟 相关文章Mifare 1k S50 卡的简单探讨与破解]]></content>
      <categories>
        <category>生活</category>
        <category>乱七八糟的技巧</category>
      </categories>
  </entry>
</search>
