<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浩浩的被窝</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://haohaozaici.github.io/"/>
  <updated>2018-12-14T01:28:31.150Z</updated>
  <id>https://haohaozaici.github.io/</id>
  
  <author>
    <name>haohaozaici</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>鸣鸣小喵日记</title>
    <link href="https://haohaozaici.github.io/2018/12/13/%E9%B8%A3%E9%B8%A3%E5%B0%8F%E5%96%B5%E6%97%A5%E8%AE%B0/"/>
    <id>https://haohaozaici.github.io/2018/12/13/鸣鸣小喵日记/</id>
    <published>2018-12-13T11:34:38.000Z</published>
    <updated>2018-12-14T01:28:31.150Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/a328671cly1fy5cnfosabj20qo0k0jsx.jpg" alt="img"></p><p><br></p><p>上了一上午的课，鸣鸣非常疲惫，回到寝室看着干净、温暖的床铺，迫不及待要把自己狠狠地摔在柔软的床垫上，贪婪的呼吸因为刚刚晒过而散发清香的被子，然而，这令人心动到心脏砰砰直跳的幻想被身上几天没洗的衣服拉回了现实。</p><p>“唉，还是先吃饭吧。” </p><p>说完鸣鸣放下手中从没翻开的课本，不怀好意的告诉斜对面的张越今天老师又点名了。</p><p>“呵呵呵！”</p><p>突然，旁边传来一阵机智的笑声打断了鸣鸣的表演，原来他用了无数次的小把戏早已被人识破。</p><p>“其实没点名，啊哈哈哈”</p><p>匆忙解释了一句，鸣鸣赶紧用哈哈大笑来「自鸣得意」，大家也跟着笑了起来，空气中顿时充满了皮气。</p><p>…</p><p>鸣鸣摸了摸吃撑的肚子，因为大脑供血不足开始有些头晕眼花，想着下午还要上课愈加的烦躁，扭过头，鸣鸣贪婪的看了一眼整洁的床，又看了一眼正在战斗的小东，心里下定决心再不能让他们在自己的床上胡作飞为了。</p><p>双手趴在冰冷、坚硬、粗糙的书桌上，不时调整姿势缓解手臂的僵硬，天气渐渐转凉了，鸣鸣身上竟然只简单套了件蓝色卫衣，就睡的死气沉沉了，真让大家为他担心啊。</p><p>书桌下方的抽屉里，几只老鼠的幼崽正在瑟瑟发抖，好像在抱怨今年的寒冬来的太早了些，唉，小傻瓜们，他们可比趴在桌上睡觉的鸣鸣幸福多了啊。</p><p>没过多久，常来215做客的中华田园喵跳上了那个干净的床铺。呵，柔软、温暖的被窝，让小猫都慵懒起来，张开了时刻防备着的喵爪，撑开了四肢，伸了个大大的懒腰。为他们抓了这么久的老鼠，也该休息一下了吧~想着想着就这样小喵也和鸣鸣一起进入了梦乡。</p><p>…</p><p>“啊！！！”，“喵呜~~~”</p><p>到底发生了什么？！突然传来一阵仿佛要撕裂世界的怒吼！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/a328671cly1fy5cnfosabj20qo0k0jsx.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;上了一上午的课，鸣鸣非常疲惫，回到寝室看着干净、温暖的床铺，
      
    
    </summary>
    
      <category term="生活" scheme="https://haohaozaici.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>ConstraintLayout「最全总结」</title>
    <link href="https://haohaozaici.github.io/2018/07/11/ConstraintLayout/"/>
    <id>https://haohaozaici.github.io/2018/07/11/ConstraintLayout/</id>
    <published>2018-07-11T06:14:50.000Z</published>
    <updated>2018-07-12T03:25:31.879Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>现在大家几乎都使用过ConstraintLayout，但与经常使用的布局相比，可能会面临不熟悉CL的API或者是逐渐增加的新特性，还有可能因为对CL具体行为的理解模糊而导致误用，这篇文章的目的更多的是，<strong>全面总结ConstraintLayout的用法和实际行为特性，并不断更新</strong></p></blockquote><p>基于ConstraintLayout 1.1，当前2.0版本处于测试阶段<br>参考文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI1NjEwMTM4OA==&amp;mid=2651232651&amp;idx=1&amp;sn=9ea7beb5c280cd05d192cd3df072a745&amp;chksm=f1d9e4e8c6ae6dfe3aafc910cfd2785249d777a998521047127c5beac2c4657bdd7b6c2a43ac&amp;mpshare=1&amp;scene=23&amp;srcid=0608A4Q2cmC8SaMeykxP1klT%23rd" target="_blank" rel="noopener">ConstraintLayout入门指南</a></p><h2 id="为什么要引入ConstraintLayout"><a href="#为什么要引入ConstraintLayout" class="headerlink" title="为什么要引入ConstraintLayout"></a>为什么要引入ConstraintLayout</h2><ul><li><strong>减少布局层级</strong>：常用的布局划分成了几个不同的类型，要组合不同的功能需要通过嵌套的形式实现，比如想要按比例布局就要使用layout_weight属性，想要使用layout_weight属性就要使用LinearLayout（以下简称LL）或者TableLayout，然后你在原先同级的每个布局外再嵌套一层布局以使用layout_weight。</li><li><strong>更多的布局需求</strong>：要实现固定宽高比、百分比布局，灵活控制大小等更高阶的布局需求，原先的各类布局方式都不能很好的支持，可能需要通过Java代码，在运行中二次实现。</li><li>想要通过ConstraintLayout来 <strong>优化性能</strong>，<del>可能并不明显</del></li><li>亦或者你只是想尝试下这款Andorid官方力推的新布局，看看它有什么新特性。</li></ul><p>引入lib:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//确保SDK Tools中已经下载了ConstraintLayout的支持库：</span></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">'com.android.support.constraint:constraint-layout:1.1.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>开始之前，我们应该意识到在布局文件中Layout主要职责是什么，<strong>控制widgets的位置和大小</strong>。下面将从这两个方向出发，看看ConstraintLayout是怎么做的。</p><h2 id="1-控制位置"><a href="#1-控制位置" class="headerlink" title="1. 控制位置"></a>1. 控制位置</h2><p>layout中的view都有四个方向<code>left(start), right(end), top, bottom</code>，通过这些方向在两个view之间建立约束来实现基础的位置控制，相对于RelativeLayout，RL中所有的属性CL中都有与之对应的项目，稍加熟悉即可完成转换：</p><p><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbyw9rj212c0z4af4.jpg" alt="cl - rl"></p><p>相对于父布局的相对布局属性，CL的规则是：将父布局当做一个id=”parent”的对象来对待：</p><p><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nc04bdj213o16wwle.jpg" alt="cl parent - rl parent"></p><h3 id="1-1-Margins"><a href="#1-1-Margins" class="headerlink" title="1.1 Margins"></a>1.1 Margins</h3><p>设置普通的margin：<br><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbrn7yj20fy0dot9q.jpg" width="320" alt="margin"></p><h3 id="1-2-visibility-对约束的影响"><a href="#1-2-visibility-对约束的影响" class="headerlink" title="1.2 visibility 对约束的影响"></a>1.2 visibility 对约束的影响</h3><p>特殊的情况是：<strong>连接到visibility为GONE的view时的margin</strong>，在ConstraintLayout中，当widgets被设置<strong>View.GONE</strong>时进行了特殊处理。</p><ul><li>根据布局的传递，设置为GONE的view相当于大小被设置为0(实际上是被设置成了一个点)</li><li>如果他们已经跟其他的组件产生了约束关系，约束关系还是会存在，但是所有的margin都会变成0<br><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbvh3uj20pa0dygml.jpg" alt="Visibility Behavior"></li><li>也可以使用goneMargin来<strong>保持预期的边距</strong><!-- ![margin gone](https://ws1.sinaimg.cn/large/a328671cly1ft63nbnva9j20ee0dagmk.jpg) --><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbnva9j20ee0dagmk.jpg" width="320" alt="margin gone"></li></ul><p>这种特殊的处理，可以在你临时的把view设置为GONE时，不破坏布局结构。</p><h3 id="1-3-居中和偏移"><a href="#1-3-居中和偏移" class="headerlink" title="1.3 居中和偏移"></a>1.3 居中和偏移</h3><p>居中的设置参考之前于RelativeLayout的对应关系，CL增加了偏移属性，使用偏移可以更好的处理屏幕大小改变时的情景。<br><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbngqij20nm08gdgc.jpg" alt="center"><br><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbnttlj21340cot9z.jpg" alt="bias"></p><p>布局中设置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.constraint.ConstraintLayout ...&gt;</span><br><span class="line">    &lt;Button android:id=<span class="string">"@+id/button"</span> ...</span><br><span class="line">        app:layout_constraintHorizontal_bias=<span class="string">"0.3"</span></span><br><span class="line">        app:layout_constraintLeft_toLeftOf=<span class="string">"parent"</span></span><br><span class="line">        app:layout_constraintRight_toRightOf=<span class="string">"parent/&gt;</span></span><br><span class="line"><span class="string">&lt;/&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="1-4-圆形的位置"><a href="#1-4-圆形的位置" class="headerlink" title="1.4 圆形的位置"></a>1.4 圆形的位置</h3><p><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbyao7j21600tyq7z.jpg" alt="circle"><br>使用圆形约束，在创建圆形的菜单时非常有用<br><img src="https://cdn-images-1.medium.com/max/1600/1*dkCMb35o4HN7SVX8S1N3ig.gif" alt="circle menu"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button android:id=<span class="string">"@+id/buttonA"</span> ... /&gt;</span><br><span class="line">&lt;Button android:id=<span class="string">"@+id/buttonB"</span> ...</span><br><span class="line">    app:layout_constraintCircle=<span class="string">"@+id/buttonA"</span></span><br><span class="line">    app:layout_constraintCircleRadius=<span class="string">"100dp"</span></span><br><span class="line">    app:layout_constraintCircleAngle=<span class="string">"45"</span> /&gt;</span><br></pre></td></tr></table></figure><h2 id="2-控制尺寸-大小"><a href="#2-控制尺寸-大小" class="headerlink" title="2. 控制尺寸(大小)"></a>2. 控制尺寸(大小)</h2><h3 id="2-1-给ConstraintLayout自己添加大小限制"><a href="#2-1-给ConstraintLayout自己添加大小限制" class="headerlink" title="2.1 给ConstraintLayout自己添加大小限制"></a>2.1 给ConstraintLayout自己添加大小限制</h3><p>当ConstraintLayout的大小设置为<strong>WRAP_CONTENT</strong>时，可以很方便的设置自己的最大宽高<br><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbvcurj20pw08sdh1.jpg" width="600" alt="max min"><br><!-- ![max min](https://ws1.sinaimg.cn/large/a328671cly1ft63nbvcurj20pw08sdh1.jpg) --></p><h3 id="2-2-Widgets的尺寸-大小-约束"><a href="#2-2-Widgets的尺寸-大小-约束" class="headerlink" title="2.2 Widgets的尺寸(大小)约束"></a>2.2 Widgets的尺寸(大小)约束</h3><p>和我们在常用的布局中设置宽高一样，控制Widgets的宽度和高度一共有3种方式：</p><ul><li><strong>固定的大小</strong>，如123dp</li><li><strong>WRAP_CONTENT</strong> 自适应</li><li><strong>0dp</strong>，等于<strong>MATCH_CONSTRAINT</strong>，类似于match_parent，会利用所有可用的空间。注意，不建议使用match_parent</li></ul><p><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbpx54j20oc0heta2.jpg" alt="dimension-constraints"></p><h3 id="2-3-WRAP-CONTENT-强制约束"><a href="#2-3-WRAP-CONTENT-强制约束" class="headerlink" title="2.3 WRAP_CONTENT 强制约束"></a>2.3 WRAP_CONTENT 强制约束</h3><p>默认情况下，设置为WRAP_CONTENT的组件不会限制他们的大小，有时会导致超出约束条件的情况，如果需要强制他们满足约束条件的话，使用下面的强制约束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constrainedWidth=&quot;true|false&quot;</span><br><span class="line">app:layout_constrainedHeight=&quot;true|false&quot;</span><br></pre></td></tr></table></figure></p><h3 id="2-4-MATCH-CONSTRAINT-大小控制"><a href="#2-4-MATCH-CONSTRAINT-大小控制" class="headerlink" title="2.4 MATCH_CONSTRAINT 大小控制"></a>2.4 MATCH_CONSTRAINT 大小控制</h3><p>默认情况下，MATCH_CONSTRAINT 会利用所有可用的空间，通过下面的设置，可以自定义具体的行为</p><ul><li><code>layout_constraintWidth_min</code> and <code>layout_constraintHeight_min</code></li><li><code>layout_constraintWidth_max</code> and <code>layout_constraintHeight_max</code></li><li><code>layout_constraintWidth_percent</code> and <code>layout_constraintHeight_percent</code></li><li>使用百分比大小时，对应方向的大小必须设置为 MATCH_CONSTRAINT</li></ul><h3 id="2-5-使用比例"><a href="#2-5-使用比例" class="headerlink" title="2.5 使用比例"></a>2.5 使用比例</h3><p>使用比例有两种情况，而且必须至少有一条边被设置为0dp：</p><ul><li>如果只有一条边被设置为0dp，设置比例时，将参考另外一条已经确定尺寸的边</li><li>如果两条边都被设置为0dp，那么会在满足比例的条件下，设置为最大尺寸</li><li>同样的支持直接设置<code>layout_constraintWidth_percent</code>和<code>layout_constraintHeight_percent</code>来使用百分比控制相对于parent的比例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">    android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_height=<span class="string">"0dp"</span></span><br><span class="line">    app:layout_constraintDimensionRatio=<span class="string">"1.6"</span> /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">    android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_height=<span class="string">"0dp"</span></span><br><span class="line">    app:layout_constraintDimensionRatio=<span class="string">"1:1"</span> /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">    android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">    android:layout_height=<span class="string">"0dp"</span></span><br><span class="line">    app:layout_constraintBottom_toBottomOf=<span class="string">"parent"</span></span><br><span class="line">    app:layout_constraintDimensionRatio=<span class="string">"H,16:9"</span></span><br><span class="line">    app:layout_constraintTop_toTopOf=<span class="string">"parent"</span> /&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-6-Chains"><a href="#2-6-Chains" class="headerlink" title="2.6 Chains"></a>2.6 Chains</h3><p>Chains能自定义在同一轴线上view的位置和大小，首先我们来创建一条链，当widgets之间在同一个方向上相互连接(相互约束)时，链就形成了。</p><p><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbnpdwj20nq094jry.jpg" alt="chain"></p><h4 id="2-6-1-链的head"><a href="#2-6-1-链的head" class="headerlink" title="2.6.1 链的head"></a>2.6.1 链的head</h4><p>水平方向chain最左边的控件和垂直方向chain最顶部的控件被成为<code>head chain</code>。通过对head chain添加<code>chainStyle</code>属性，可以设置该条chain在水平或垂直方向上的chainStyle</p><p><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbnl5yj20r407ggm6.jpg" alt="chain head"></p><h4 id="2-6-2-Chain-Style"><a href="#2-6-2-Chain-Style" class="headerlink" title="2.6.2 Chain Style"></a>2.6.2 Chain Style</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout_constraintHorizontal_chainStyle</span><br><span class="line">layout_constraintVertical_chainStyle</span><br></pre></td></tr></table></figure><p>chainStyle属性一共有三种：spread、spread_inside、packed。再配合其他属性，最终可以组成五种chain style：<br><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbwsmtj21360kgdjl.jpg" alt="chainStyle"></p><p>其他四种chain style的设置和效果都比较简单，重点介绍下<strong>Weighted Chain</strong>。</p><ul><li>默认的spread模式，每个元素获得同样的空间，如果一个元素使用了0dp，将会占用剩下的所有可用空间</li><li><code>layout_constraintHorizontal_weight</code>和<code>layout_constraintVertical_weight</code>可以用来控制同样设置为0dp的控件的比例</li><li>Weighted Chain中的控件也允许在chain方向上使用wrap_content自适应控件宽/高，且布局时<strong>优先满足设置为wrap_content的控件</strong>，相当于优先满足设置了指定宽高的控件</li><li>当设置了margin时，margin生效的同时weight的比例不变，链上的控件实际占有布局会被压缩</li></ul><h2 id="3-不可见的辅助工具"><a href="#3-不可见的辅助工具" class="headerlink" title="3. 不可见的辅助工具"></a>3. 不可见的辅助工具</h2><h3 id="Guideline"><a href="#Guideline" class="headerlink" title="Guideline"></a>Guideline</h3><h3 id="barrier"><a href="#barrier" class="headerlink" title="barrier"></a>barrier</h3><h3 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h3><h2 id="4-用代码的方式操作"><a href="#4-用代码的方式操作" class="headerlink" title="4. 用代码的方式操作"></a>4. 用代码的方式操作</h2><h3 id="ps-选择优化类型"><a href="#ps-选择优化类型" class="headerlink" title="ps. 选择优化类型"></a>ps. 选择优化类型</h3><p>Package Index:<br>android.support.constraint<br>android.support.constraint.helper<br>android.support.constraint.motion<br>android.support.constraint.utils</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;现在大家几乎都使用过ConstraintLayout，但与经常使用的布局相比，可能会面临不熟悉CL的API或者是逐渐增加的新特性，还有可能因为对CL具体行为的理解模糊而导致误用，这篇文章的目的更多的是，&lt;strong&gt;全面总结ConstraintL
      
    
    </summary>
    
      <category term="Android" scheme="https://haohaozaici.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>「播放器」不自由的旋转</title>
    <link href="https://haohaozaici.github.io/2018/06/11/player-orientation/"/>
    <id>https://haohaozaici.github.io/2018/06/11/player-orientation/</id>
    <published>2018-06-11T11:49:06.000Z</published>
    <updated>2018-09-13T01:40:36.779Z</updated>
    
    <content type="html"><![CDATA[<p>屏幕旋转是开发播放器过程中大家都会实现的基础功能，简单的说，就是接管手机方向的旋转控制，那为啥不直接用默认的旋转功能呢，主要是</p><ul><li>播放页面有其他的显示内容，而这些内容的布局不适合在横屏下显示</li><li>有特殊需求，比如在软件中锁定方向、未播放时不允许旋转等等</li><li>在系统锁定方向时，依旧可以旋转</li></ul><blockquote><p>在不同的使用场景下对旋转的约束变的复杂起来，旋转也越来越”不自由”，这篇文章的目的是：<strong>如果你对屏幕旋转逻辑不够清晰，还对屏幕旋转的功能细节不够满意的话，一起来将整个逻辑思考清楚吧。</strong></p></blockquote><p>废话不多说先简单回顾一下基础知识。</p><h2 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a>基础回顾</h2><ol><li><p>设置屏幕方向<br>很简单，通过<code>activity.setRequestedOrientation(@ActivityInfo.ScreenOrientation)</code>方法实现控制界面的方向（还可以控制旋转模式），具体的参数意义可以在文档中查看。</p></li><li><p>获取当前屏幕方向<br>只能设置方向可不行，先得知道当前是什么方向。<br>通过<code>activity.getWindowManager().getDefaultDisplay().getRotation()</code>方法来获取当前方向，注意返回值为<code>@Surface.Rotation</code>类型。<code>WindowManager</code>也可以通过<code>Context</code>获取。</p></li><li><p>自动旋转<br>如果要实现更复杂的控制，还需要知道当前手机的角度。<br>通过<code>OrientationEventListener(activity)</code>来监听屏幕方向(角度)的变化，监听的<code>onOrientationChanged(int rotation)</code>方法中，实时返回了当前设备的角度。</p></li><li><p>处理旋转导致的activity变更<br>大家都知道旋转会导致<code>activity</code>重建，可以在<code>AndroidManifest</code>文件中修改<code>activity</code>的<code>configChanges</code>配置，即可在<code>onConfigurationChanged(newConfig: Configuration?)</code>方法中自行处理旋转变更，具体参考<a href="https://developer.android.com/guide/topics/resources/runtime-changes?hl=zh-cn" target="_blank" rel="noopener">处理运行时变更。</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 视频播放中常用的配置</span><br><span class="line">android:configChanges="keyboard|keyboardHidden|orientation|screenSize|screenLayout|smallestScreenSize|uiMode"</span><br></pre></td></tr></table></figure></li></ol><h2 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h2><p>旋转功能可以实现的非常简单，也可以相对复杂，具体要看应用的场景，下面分析几个常见应用。</p><ol><li><p>抖音<br>最简单，没有旋转^_^ ，值得一提的是适配了视频源的方向，让视频看起来更舒服。</p></li><li><p>YouTube<br>整个应用都支持旋转，播放页面多了一个全屏和非全屏的切换按钮。旋转的逻辑比较简单，但横竖屏切换对布局处理的逻辑复杂，也暂时不在本文的介绍范围。</p></li><li><p>bilbili点播页面<br>旋转逻辑相对于YouTube复杂了一些，比如视频未播放时不支持自动旋转，支持屏幕锁，显示菜单时不允许旋转，可能还有很多我没发现的细节。</p></li><li><p>bilbili离线播放<br>更简单一点，只支持横屏，但上面的功能也没少。</p></li></ol><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>Android系统既提供了预设的旋转模式，也提供完全自由的控制，分别通过<code>activity.setRequestedOrientation(@ActivityInfo.ScreenOrientation)</code>方法，<code>OrientationEventListener(activity)</code>监听器来实现。因此这就为解决问题提供了两种思路，</p><ol><li>通过组合系统的预设模式来达到预期效果</li><li>通过监听角度变化，配合需要的限制来完全自定义旋转效果</li></ol><p>不管使用哪种方式，两个API都要结合使用，基础的旋转大家都能轻松做到，但要达到比较好的用户体验，细节往往决定成败┐(ﾟ～ﾟ)┌。</p><ul><li>主动点击了全屏按钮屏幕会不会自己又转回来了？</li><li>全屏状态下点击返回键是直接退出当前页面，还是回到竖屏？</li><li>两个方向横屏的情况点击回到竖屏处理的是不是正确的？</li><li>有没有适配默认方向为横向的Android平板?<br>blablabla…今天就好好把这一切捋清楚&lt;(￣︶￣)&gt;，接下来分析一下常见的错误和如何优化。</li></ul><p>值得注意的是，参数<code>rotation</code>的意义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called when the orientation of the device has changed.</span></span><br><span class="line"><span class="comment"> * orientation parameter is in degrees, ranging from 0 to 359.</span></span><br><span class="line"><span class="comment"> * orientation is 0 degrees when the device is oriented in its natural position,</span></span><br><span class="line"><span class="comment"> * 90 degrees when its left side is at the top, 180 degrees when it is upside down, </span></span><br><span class="line"><span class="comment"> * and 270 degrees when its right side is to the top.</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #ORIENTATION_UNKNOWN&#125; is returned when the device is close to flat</span></span><br><span class="line"><span class="comment"> * and the orientation cannot be determined.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> orientation The new orientation of the device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@see</span> #ORIENTATION_UNKNOWN</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOrientationChanged</span><span class="params">(<span class="keyword">int</span> orientation)</span></span>;</span><br></pre></td></tr></table></figure><p>就这么简单，就这一个方法和一个监听器。旁白君：这么简单还讲毛线哇 (⊙ˍ⊙)，散了散了…！！！大家慢走，<br>的确就这两个东东，但还要组合4个方向，两个操作，两个状态，还有balabala… 旁白君：有人装神弄鬼啦，大家快走！。</p><p>哈哈，言归正传~这些状态和操作一开始组合起来真的把我弄晕了，不过冷静下来思考之后，回归了简单。</p><h2 id="情景分析"><a href="#情景分析" class="headerlink" title="情景分析"></a>情景分析</h2><p>首先看看手机方向示意图：</p><p><img src="https://ww1.sinaimg.cn/large/a328671cly1fs7iv2gkuwj20eg0eowg8.jpg" alt="img1"></p><p>为什么会弄晕我，大家来看看下面的细节，由浅入深：</p><ul><li>屏幕跟着手机旋转</li><li>在竖直方向点击横屏后，屏幕方向保持横向，不会自动转回来（同时也适用于横向的情况）</li><li>反向横屏的时候，点击竖屏，应该回到正向竖屏。反向竖屏的时候，点击横屏应该回到”正向”横屏。<br>（保证都能回到正向竖屏，同时保持协调）</li><li>在2和3的条件下，比如在竖直方向点击横屏后，屏幕方向保持横向，然后手机屏幕旋转到横向后，<br>再旋转到竖向时，屏幕应该跟随手机旋转到竖向。（相当于旋转到期望状态后，限制就自动解除）</li><li>在以上逻辑的前提下，旋转屏幕，手机应正常保持跟随旋转。（只限制应该限制的方向）</li></ul><p>没这么复杂啊，你是不是在糊弄我？。。。咳咳，真的不是我太纠结，追求完美是吧。<br>那么这些逻辑哪里复杂了？哪些条件又存在冲突呢。</p><p><strong>矛盾的点</strong>：</p><ul><li>「横屏、反向横屏」，「竖屏、反向竖屏」时，点击恢复按钮都需要都需要恢复到”正向”状态，且旋转后不能立刻恢复。</li><li>限制条件启动后，除了限制旋转的方向外，手机应正常保持跟随旋转</li><li>限制条件启动后，在旋转到期望状态后，解除限制</li></ul><p>这里横向的”正方向”不重要，顺时针和逆时针都行。矛盾的关键就是：</p><ul><li>正向时点击产生的限制与手机应正常保持跟随旋转</li><li>反向时点击产生的限制与手机应正常保持跟随旋转</li><li>限制与解除限制</li></ul><h2 id="正确的思路"><a href="#正确的思路" class="headerlink" title="正确的思路"></a>正确的思路</h2><p>为了保证不先把我自己弄晕，直接来看正确的思路。o(￣▽￣)ｄ</p><p>切记不能跟着条件一个个满足，这就会进入矛盾的漩涡，解决了这个对立的那个又不满足了。</p><p>处理旋转逻辑的思路：</p><ul><li>准确的知道当前方向（当前方向不能作为标志保存，必须实时获取）</li><li>保存点击时的方向，提供限制</li><li>旋转到非限制方向时，解除限制</li></ul><p>这就好办了，首先我们完成最基础的，跟随手机的角度旋转屏幕：<br><img src="https://ww1.sinaimg.cn/large/a328671cly1fs7iv2gs7xj20lz0bpq5c.jpg" alt="img2"></p><p>再加上点击后屏幕旋转到竖(横)向正方向的功能：<br><img src="https://ww1.sinaimg.cn/large/a328671cly1fs7iv2gu1sj20ja07iwg9.jpg" alt="img3"></p><p>注意开启功能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orientationEventListener.enable();</span><br></pre></td></tr></table></figure></p><p>这个时候我们会发现问题，没有满足这个条件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在竖直方向点击横屏后，屏幕方向保持横向，不会自动转回来（同时也适用于横向的情况）</span><br></pre></td></tr></table></figure></p><p>记住原来的教训：<strong>不能跟着条件一个个满足</strong>。问题的根本是我们要提供限制，并且在旋转到非限制方向时，解除限制。限制是什么，是我们不能旋转回原来的方向，所以我们记录下了点击时的方向：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mOldScreenRotation = activity.getWindowManager().getDefaultDisplay().getRotation();</span><br></pre></td></tr></table></figure></p><p>那什么时候解除限制呢，旋转到非原始方向时就解除限制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">mScreenRotation = activity.getWindowManager().getDefaultDisplay().getRotation();</span><br><span class="line"><span class="comment">// 自动竖屏</span></span><br><span class="line"><span class="keyword">if</span> (((rotation &gt;= <span class="number">0</span>) &amp;&amp; (rotation &lt;= <span class="number">15</span>)) || (rotation &gt;= <span class="number">345</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mOldScreenRotation != Surface.ROTATION_0) &#123;</span><br><span class="line">        <span class="comment">//解除限制</span></span><br><span class="line">        mOldScreenRotation = -<span class="number">1</span>; <span class="comment">//-1不代表任何方向</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mScreenRotation == Surface.ROTATION_0 || (mOldScreenRotation != -<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">//当前的角度和屏幕方向一致，不处理</span></span><br><span class="line">        <span class="comment">//没有旋转到非原始方向，被限制</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自动反向横屏</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (rotation &gt; <span class="number">75</span> &amp;&amp; rotation &lt; <span class="number">105</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mOldScreenRotation != Surface.ROTATION_270) &#123;</span><br><span class="line">        mOldScreenRotation = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mScreenRotation == Surface.ROTATION_270 || (mOldScreenRotation != -<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自动反向竖屏</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (rotation &gt; <span class="number">165</span> &amp;&amp; rotation &lt; <span class="number">195</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mOldScreenRotation != Surface.ROTATION_180) &#123;</span><br><span class="line">        mOldScreenRotation = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mScreenRotation == Surface.ROTATION_180 || mOldScreenRotation != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自动横屏</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (((rotation &gt;= <span class="number">255</span>) &amp;&amp; (rotation &lt;= <span class="number">285</span>))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mOldScreenRotation != Surface.ROTATION_90) &#123;</span><br><span class="line">        mOldScreenRotation = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mScreenRotation == Surface.ROTATION_90 || (mOldScreenRotation != -<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意<code>Surface.ROTATION_270</code>和<code>onOrientationChanged(int rotation)</code>的角度正好是相反的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;屏幕旋转是开发播放器过程中大家都会实现的基础功能，简单的说，就是接管手机方向的旋转控制，那为啥不直接用默认的旋转功能呢，主要是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;播放页面有其他的显示内容，而这些内容的布局不适合在横屏下显示&lt;/li&gt;
&lt;li&gt;有特殊需求，比如在软件中锁定方向、未播放
      
    
    </summary>
    
      <category term="播放器" scheme="https://haohaozaici.github.io/categories/%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>「播放器」Mac上编译ijkplayer so支持HTTPS</title>
    <link href="https://haohaozaici.github.io/2018/06/07/build-ijkplayer/"/>
    <id>https://haohaozaici.github.io/2018/06/07/build-ijkplayer/</id>
    <published>2018-06-07T08:02:19.000Z</published>
    <updated>2018-07-11T12:29:44.559Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>当项目中使用ijkplayer，而且还需要播放HTTPS链接的视频时，就比较蛋疼了 (￣.￣)，ijkplayer默认不支持HTTPS播放，但提供了编译OpenSSL的选项，可以自己编译so文件支持HTTPS播放。这篇文章的目的是<strong>引导不熟悉的人完成整个编译过程，提醒过程中的注意事项，还有各种选项的解释</strong>。</p></blockquote><h2 id="我的编译环境"><a href="#我的编译环境" class="headerlink" title="我的编译环境"></a>我的编译环境</h2><p>VMware + Ubuntu编译环境也可以参考，基本上只有命令不同，homebrew的安装这里不再赘述。非常不建议在Windows环境下编译！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mac 10.13.2</span><br><span class="line">iTerm2 + zsh</span><br><span class="line">HomeBrew</span><br><span class="line">NDK r10e</span><br><span class="line"></span><br><span class="line">NDK + 编译所有so大概需要10GB空间</span><br></pre></td></tr></table></figure></p><p>相关链接:</p><ul><li><a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="noopener">Bilibili/ijkplayer</a></li><li><a href="https://www.jianshu.com/p/bd289e25d272" target="_blank" rel="noopener">IJKPlayer编译so支持HTTPS的踩坑历程</a></li><li><a href="https://blog.csdn.net/coder_pig/article/details/79134625" target="_blank" rel="noopener">ijkplayer编译so库真没那么难</a></li></ul><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><h3 id="安装Git与yasm"><a href="#安装Git与yasm" class="headerlink" title="安装Git与yasm"></a>安装Git与yasm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br><span class="line">brew install yasm</span><br></pre></td></tr></table></figure><h3 id="配置SDK、NDK"><a href="#配置SDK、NDK" class="headerlink" title="配置SDK、NDK"></a>配置SDK、NDK</h3><p>SDK都会有，NDK一般没有下载，建议去官网下载:<a href="https://developer.android.google.cn/ndk/downloads/older_releases" target="_blank" rel="noopener">https://developer.android.google.cn/ndk/downloads/older_releases</a></p><p>需要注意的是最好下载官方lib使用的<strong>NDK r10e</strong>，使用其他版本的将无法编译。具体原因可以参考<a href="https://github.com/Bilibili/ijkplayer/issues/2752" target="_blank" rel="noopener">这篇issue</a></p><p>SDK、NDK和准备完成后，在<code>.bash_profile</code>, 或者是<code>.zshrc</code>中添加配置。(<code>Command + shift + .</code> 显示隐藏文件)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 注意替换为自己的文件路径</span><br><span class="line">export ANDROID_SDK=/Users/haoyuan/Library/Android/sdk</span><br><span class="line">export PATH=$ANDROID_SDK/platform-tools:$PATH</span><br><span class="line">export PATH=$ANDROID_SDK/tools:$PATH</span><br><span class="line">export ANDROID_NDK=/Users/haoyuan/Library/Android/android-ndk-r10e</span><br><span class="line">export PATH=$ANDROID_NDK:$PATH</span><br></pre></td></tr></table></figure><p>添加完成后，保存文件，然后<code>source .bash_profile</code>等相关文件，或者<strong>直接重启终端</strong>，通过 <code>ndk-build -v</code> 检查是否生效</p><p><img src="https://ww1.sinaimg.cn/large/a328671cly1fs2p78ggb9j20ug084dpy.jpg" alt="img"></p><h3 id="clone-ijkplayer源码"><a href="#clone-ijkplayer源码" class="headerlink" title="clone ijkplayer源码"></a>clone ijkplayer源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Bilibili/ijkplayer.git ijkplayer-android</span><br><span class="line">cd ijkplayer-android</span><br><span class="line">git checkout -B latest k0.8.8</span><br></pre></td></tr></table></figure><h2 id="2-编译之前"><a href="#2-编译之前" class="headerlink" title="2. 编译之前"></a>2. 编译之前</h2><h3 id="编译前选择你的配置"><a href="#编译前选择你的配置" class="headerlink" title="编译前选择你的配置"></a>编译前选择你的配置</h3><p>选择自动化编译时的一些配置选项，比如支持的协议，音视频类型等，官方给我们提供了三个模板。</p><p>可以打开config/目录下config/module.sh看看，enable启用，disable禁用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module-default.sh</span><br><span class="line">module-lite-hevc.sh</span><br><span class="line">module-lite.sh</span><br></pre></td></tr></table></figure></p><p><img src="https://ww1.sinaimg.cn/large/a328671cly1fs2p78eh8lj20yc0xqwir.jpg" alt="img"></p><p>官方默认建议选择的是 <code>module-lite.sh</code>，可以根据自己的需求选择<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd config</span><br><span class="line">rm module.sh</span><br><span class="line">ln -s module-lite.sh module.sh</span><br></pre></td></tr></table></figure></p><p>如果要选择<code>module-default.sh</code>的话，可能会编译失败，可以参考<a href="https://github.com/Bilibili/ijkplayer/issues/4043" target="_blank" rel="noopener">这篇issue</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">仔细阅读module-lite.h 原来在最下面有一行配置：</span><br><span class="line">export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --disable-linux-perf&quot;</span><br><span class="line">把这行复制到module-default.sh 的最后面就可以了</span><br></pre></td></tr></table></figure></p><p>在编译配置中可以增减需要的模块，选择需要支持的<strong>封装格式、编解码类型、协议</strong>能有效减小so库的体积。可以参考<a href="https://github.com/CarGuo/GSYVideoPlayer/blob/master/doc/DECODERS.md" target="_blank" rel="noopener">CarGuo/GSYVideoPlayer DECODERS.md</a></p><h2 id="3-开始编译ヽ-｀⌒´-ﾉ"><a href="#3-开始编译ヽ-｀⌒´-ﾉ" class="headerlink" title="3. 开始编译ヽ(｀⌒´)ﾉ"></a>3. 开始编译ヽ(｀⌒´)ﾉ</h2><h3 id="执行初始化"><a href="#执行初始化" class="headerlink" title="执行初始化"></a>执行初始化</h3><p>初始化会下载各种包，尽量选择在良好的网络环境下╮(￣▽￣)╭<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">./init-android.sh</span><br></pre></td></tr></table></figure></p><p>初始化OpenSSL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./init-android-openssl.sh</span><br></pre></td></tr></table></figure></p><h3 id="编译OpenSSL和FFmpeg"><a href="#编译OpenSSL和FFmpeg" class="headerlink" title="编译OpenSSL和FFmpeg"></a>编译OpenSSL和FFmpeg</h3><p>首先清除一波<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd android/contrib</span><br><span class="line">./compile-openssl.sh clean</span><br><span class="line">./compile-ffmpeg.sh clean</span><br></pre></td></tr></table></figure></p><p>编译OpenSSL：可以选择不同版本，全量编译耗时更长，但最好选择全量编译，编译完成后再根据需求选择要使用的包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./compile-openssl.sh all</span><br></pre></td></tr></table></figure></p><p>编译FFmpeg，同样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./compile-ffmpeg.sh all</span><br><span class="line"></span><br><span class="line">// 如果要选择特定的架构: ./compile-ffmpeg.sh armv7a | armv5</span><br></pre></td></tr></table></figure></p><p>最后编译ijkplayer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./compile-ijk.sh all</span><br></pre></td></tr></table></figure></p><p>经过漫长的等待终于完成了以上编译过程\（￣︶￣）/，在目录中生成了ijkplayer的工程<br><img src="https://ww1.sinaimg.cn/large/a328671cly1fs2p78dwkmj20hq09vac5.jpg" alt="IMG"></p><h2 id="4-导入项目"><a href="#4-导入项目" class="headerlink" title="4. 导入项目"></a>4. 导入项目</h2><p>原有的项目一般是这样配置的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;tv.danmaku.ijk.media:ijkplayer-java:&apos; + gradle.ijkplayer_java</span><br><span class="line">implementation &apos;tv.danmaku.ijk.media:ijkplayer-armv7a:&apos; + gradle.ijkplayer_java</span><br></pre></td></tr></table></figure></p><p>如果只需要修改so库的话，<strong>删除掉第二行对so库的引用，将自己编译好的so文件复制到项目的libs文件夹中</strong>。</p><p>别忘了在gradle中配置，要不然会报错找不到so库<br><img src="https://ww1.sinaimg.cn/large/a328671cly1fs2p78cr4dj209602vgll.jpg" alt="IMG"></p><p>还可以在release包中设置abi过滤<br><img src="https://ww1.sinaimg.cn/large/a328671cly1fs2p78dgn4j20l50cgwfu.jpg" alt="IMG"></p><p>最后大功告成啦\(^o^)/</p><p>尾巴…</p><p>如果项目中同时使用了HTTP和HTTPS的视频源的话，要注意如果视频源刚好是相同域名，会导致播放失败，这是由于dns缓存造成的，解决办法参考<a href="https://github.com/CarGuo/GSYVideoPlayer/issues/1175" target="_blank" rel="noopener">这篇issue</a><br>初始化<code>IjkMediaPlayer</code>时，设置清除<code>dns cache</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;dns_cache_clear&quot;, 1</span><br><span class="line"></span><br><span class="line">//还要注意开启相关支持的协议</span><br><span class="line">IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;protocol_whitelist&quot;, </span><br><span class="line">&quot;async,cache,crypto,file,http,https,ijkhttphook,ijkinject,</span><br><span class="line">ijklivehook,ijklongurl,ijksegment,ijktcphook,</span><br><span class="line">pipe,rtp,tcp,tls,udp,ijkurlhook,data&quot;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;当项目中使用ijkplayer，而且还需要播放HTTPS链接的视频时，就比较蛋疼了 (￣.￣)，ijkplayer默认不支持HTTPS播放，但提供了编译OpenSSL的选项，可以自己编译so文件支持HTTPS播放。这篇文章的目的是&lt;strong&gt;引
      
    
    </summary>
    
      <category term="Android" scheme="https://haohaozaici.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>「播放器」Android音频焦点</title>
    <link href="https://haohaozaici.github.io/2018/04/24/Android%20Sound%20overlap/"/>
    <id>https://haohaozaici.github.io/2018/04/24/Android Sound overlap/</id>
    <published>2018-04-24T11:22:02.000Z</published>
    <updated>2018-08-01T11:44:32.987Z</updated>
    
    <content type="html"><![CDATA[<p>音视频播放在手机日常使用中非常频繁，当我们听着音乐刷着微博时，看到有趣的视频点击开始播放，音乐自动暂停，退出视频时音乐又自动恢复了播放(如果没有自动恢复的话，比如QQ音乐就会提示是否设置中断后继续播放)。</p><p><img src="https://img.mukewang.com/5aded21b0001ab9210801920.png" width="240" alt="中断后继续播放"></p><p>这一系列流畅自然的操作不是理所应当的吗~当然如果处理不好的话就会出现声音重叠，音频焦点长期被占用的问题，下面我们来看看具体的功能逻辑。</p><p>音频焦点相关的讲解参考以下文章</p><blockquote><p><a href="https://www.jianshu.com/p/5d8d7b677690" target="_blank" rel="noopener">Android音频焦点详解</a><br><a href="https://developer.android.com/guide/topics/media-apps/audio-focus.html" target="_blank" rel="noopener">Managing Audio Focus</a></p></blockquote><h2 id="Managing-Audio-Focus"><a href="#Managing-Audio-Focus" class="headerlink" title="Managing Audio Focus"></a>Managing Audio Focus</h2><p>不同的APP可以同时播放音频，系统会将他们混合在一起，但为了避免同时播放，Android提供了<strong>audio focus</strong>机制来合理使用音频播放资源。同一时间只能有一个APP获取音频焦点，当需要播放音频时，应该立即请求音频焦点，同样的，在你的APP获取到音频焦点后，其他APP也可以抢占音频焦点，这时你的APP就需要暂停播放或降低声音。音频焦点是合作类型的，APP拥有完全自主的控制权，系统无法阻止，但应用应该遵守音频焦点的指导规则。</p><p>好的音频APP在播放时应该遵守以下规则：</p><ul><li>开始播放后立即调用<code>requestAudioFocus()</code>方法，并验证返回值为<code>AUDIOFOCUS_REQUEST_GRANTED</code></li><li>当其他app占用音频焦点时，暂停或停止播放，或者降低声音</li><li>当播放停止时，放弃音频焦点</li></ul><p>在不同的Android版本下，需要使用不同的方法来处理音频焦点：</p><ul><li><em>API level 8</em>以后，使用<code>requestAudioFocus()</code>和<code>abandonAudioFocus()</code>方法，并注册<code>AudioManager.OnAudioFocusChangeListener</code>接收回调。</li><li><em>API level 21</em>以后，需要使用<code>AudioAttributes</code>来描述播放音频的类型。</li><li><p><em>API level 26</em>以后，需要使用<code>AudioFocusRequest</code>参数，它携带了音频的context和相关功能，系统会根据这些自动管理音频焦点。</p><h3 id="Android8-0以前"><a href="#Android8-0以前" class="headerlink" title="Android8.0以前"></a>Android8.0以前</h3><p>参考官方文档获取焦点的方法如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Request audio focus for playback</span></span><br><span class="line"><span class="keyword">int</span> result = am.requestAudioFocus(afChangeListener,</span><br><span class="line">        <span class="comment">// Use the music stream.</span></span><br><span class="line">        AudioManager.STREAM_MUSIC,</span><br><span class="line">        <span class="comment">// Request permanent focus.</span></span><br><span class="line">        AudioManager.AUDIOFOCUS_GAIN);</span><br></pre></td></tr></table></figure><p>但在听音乐的时候播放音频或视频，依旧出现了重叠的声音，实际上有效的做法是这样的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面两个常量参数试过很多 都无效，最终反编译了其他app才搞定，汗~  </span></span><br><span class="line"><span class="keyword">int</span> requestFocusResult = mAudioManager.requestAudioFocus(</span><br><span class="line">        mAudioFocusChangeListener,</span><br><span class="line">        AudioManager.STREAM_MUSIC,</span><br><span class="line">        AudioManager.AUDIOFOCUS_GAIN_TRANSIENT);</span><br></pre></td></tr></table></figure></p><p>具体参考文章<a href="https://blog.csdn.net/SYIF88/article/details/68064866" target="_blank" rel="noopener">Android MediaPlayer音频焦点问题，抢占声道</a></p><p>最后在对应的播放状态下获取和释放音频焦点。</p><h3 id="Android8-0之后"><a href="#Android8-0之后" class="headerlink" title="Android8.0之后"></a>Android8.0之后</h3><p>和之前一样，Android8.0中也使用了<code>requestAudioFocus()</code>来请求音频焦点，不一样的是，使用<code>abandonAudioFocusRequest()</code>释放音频焦点，并且请求和释放都需要传入同一个<code>AudioFocusRequest</code>实例。使用<code>AudioFocusRequest.Builder</code>来创建，具体实现代码参考官方文档<a href="https://developer.android.com/guide/topics/media-apps/audio-focus.html#audio-focus-8-0" target="_blank" rel="noopener">Audio focus in Android 8.0 and later</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mAudioFocusRequest = <span class="keyword">new</span> AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN)</span><br><span class="line">        .setAudioAttributes(<span class="keyword">new</span> AudioAttributes.Builder()</span><br><span class="line">                .setUsage(AudioAttributes.USAGE_MEDIA)</span><br><span class="line">                .setContentType(AudioAttributes.CONTENT_TYPE_MOVIE)</span><br><span class="line">                .build())</span><br><span class="line">        .setAcceptsDelayedFocusGain(<span class="keyword">true</span>)</span><br><span class="line">        .setOnAudioFocusChangeListener(mAudioFocusChangeListener)</span><br><span class="line">        .build();</span><br><span class="line"><span class="comment">//请求音频焦点      </span></span><br><span class="line">requestFocusResult = mAudioManager.requestAudioFocus(mAudioFocusRequest);</span><br><span class="line"><span class="comment">//释放音频焦点</span></span><br><span class="line">abandonFocusResult = mAudioManager.abandonAudioFocusRequest(mAudioFocusRequest);</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>Android8.0中其他APP使用<code>AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK</code>参数获取焦点时，将不会回调本APP的<code>onAudioFocusChange()</code>方法。</li><li>焦点延迟获取，当焦点被其他APP<strong>“锁”</strong>住时，<code>requestAudioFocus()</code>会返回<code>AUDIOFOCUS_REQUEST_FAILED</code>，比如正在打电话时，焦点就会被锁住。如果使用了<code>setAcceptsDelayedFocusGain(true)</code>方法，请求将会返回<code>AUDIOFOCUS_REQUEST_DELAYED</code>，在锁解除后，系统会继续处理未完成的焦点请求，并回调<code>onAudioFocusChange()</code>方法。</li></ul><h2 id="处理音频焦点变化"><a href="#处理音频焦点变化" class="headerlink" title="处理音频焦点变化"></a>处理音频焦点变化</h2><p>了解相应的请求、释放方法后，还需要进一步处理音频焦点变化问题，也就是优化跟其他APP或者是系统APP合作的过程。主要是处理<code>onAudioFocusChange</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AudioManager.OnAudioFocusChangeListener mAudioFocusChange = <span class="keyword">new</span> AudioManager.OnAudioFocusChangeListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAudioFocusChange</span><span class="params">(<span class="keyword">int</span> focusChange)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (focusChange)&#123;</span><br><span class="line">                <span class="keyword">case</span> AudioManager.AUDIOFOCUS_GAIN:</span><br><span class="line">                    <span class="comment">//当其他应用申请焦点之后又释放焦点会触发此回调</span></span><br><span class="line">                    <span class="comment">//可重新播放音乐</span></span><br><span class="line">                    Log.d(TAG, <span class="string">"AUDIOFOCUS_GAIN"</span>);</span><br><span class="line">                    start();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS:</span><br><span class="line">                    <span class="comment">//长时间丢失焦点,当其他应用申请的焦点为AUDIOFOCUS_GAIN时，</span></span><br><span class="line">                    <span class="comment">//会触发此回调事件，例如播放QQ音乐，网易云音乐等</span></span><br><span class="line">                    <span class="comment">//通常需要暂停音乐播放，若没有暂停播放就会出现和其他音乐同时输出声音</span></span><br><span class="line">                    Log.d(TAG, <span class="string">"AUDIOFOCUS_LOSS"</span>);</span><br><span class="line">                    stop();</span><br><span class="line">                    <span class="comment">//释放焦点，该方法可根据需要来决定是否调用</span></span><br><span class="line">                    <span class="comment">//若焦点释放掉之后，将不会再自动获得</span></span><br><span class="line">                    mAudioManager.abandonAudioFocus(mAudioFocusChange);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:</span><br><span class="line">                    <span class="comment">//短暂性丢失焦点，当其他应用申请AUDIOFOCUS_GAIN_TRANSIENT或AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE时，</span></span><br><span class="line">                    <span class="comment">//会触发此回调事件，例如播放短视频，拨打电话等。</span></span><br><span class="line">                    <span class="comment">//通常需要暂停音乐播放</span></span><br><span class="line">                    stop();</span><br><span class="line">                    Log.d(TAG, <span class="string">"AUDIOFOCUS_LOSS_TRANSIENT"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:</span><br><span class="line">                    <span class="comment">//短暂性丢失焦点并作降音处理</span></span><br><span class="line">                    Log.d(TAG, <span class="string">"AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>音频相关的API常常让人疑惑，明明已经根据注释的描述和官方文档中的方法实现了，却达不到预期的效果。还有就是随着Android更新的推送速度越来越快，更新普及率也水涨船高，高版本API随时在发生变化，适配时需要注意这些细节，以及进行完善的测试。</p><p>工具类参见<a href="https://gist.github.com/haohaozaici/baaa022e6ea5f61f37112135fe1cac07" target="_blank" rel="noopener">AudioFocusManager</a></p><h4 id="未完成内容"><a href="#未完成内容" class="headerlink" title="未完成内容"></a>未完成内容</h4><p>源码简单分析</p><p>在不同机型中进行测试</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;音视频播放在手机日常使用中非常频繁，当我们听着音乐刷着微博时，看到有趣的视频点击开始播放，音乐自动暂停，退出视频时音乐又自动恢复了播放(如果没有自动恢复的话，比如QQ音乐就会提示是否设置中断后继续播放)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.mukew
      
    
    </summary>
    
      <category term="Android" scheme="https://haohaozaici.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>创建和销毁对象</title>
    <link href="https://haohaozaici.github.io/2017/12/19/create-and-destroy-objects/"/>
    <id>https://haohaozaici.github.io/2017/12/19/create-and-destroy-objects/</id>
    <published>2017-12-19T07:12:41.000Z</published>
    <updated>2017-12-29T15:17:35.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h2><h3 id="静态工厂方法代替构造器"><a href="#静态工厂方法代替构造器" class="headerlink" title="静态工厂方法代替构造器"></a>静态工厂方法代替构造器</h3><p>静态工厂方法与设计模式中的<code>工厂方法</code>不同。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li>静态工厂方法有名称，</li></ol><h3 id="遇到多个构造器参数时，使用构建器-Builder模式"><a href="#遇到多个构造器参数时，使用构建器-Builder模式" class="headerlink" title="遇到多个构造器参数时，使用构建器-Builder模式"></a>遇到多个构造器参数时，使用构建器-Builder模式</h3><h4 id="1-使用构造方法创建对象"><a href="#1-使用构造方法创建对象" class="headerlink" title="1.使用构造方法创建对象"></a>1.使用构造方法创建对象</h4><p>重叠构造器</p><h4 id="2-JavaBeans模式"><a href="#2-JavaBeans模式" class="headerlink" title="2.JavaBeans模式"></a>2.JavaBeans模式</h4><p>通过setter方法设置必要参数，拥有良好的可读性。<br><em>缺点</em>：构造过程中容易被改变，处于不一致的状态。</p><h4 id="3-Builder模式"><a href="#3-Builder模式" class="headerlink" title="3.Builder模式"></a>3.Builder模式</h4><p>通过公开的Builder内部类，私有的构造方法，构造必传参数和可选参数。Builder模式模拟了具名的可选参数，可以加强约束条件，在对象域中进行检验。可以在编译时进行异常检查。 </p><p><em>缺点</em>：特殊情况下额外的性能开销，冗长。<br><em>适用情况</em>：多个参数(大于4个)，需要比JavaBeans模式更加安全的情况。</p><p>参见 <code>Notification</code> 或 <code>Alertdialog</code>类。</p><h3 id="用私有构造器或者枚举类型强化singleton属性"><a href="#用私有构造器或者枚举类型强化singleton属性" class="headerlink" title="用私有构造器或者枚举类型强化singleton属性"></a>用私有构造器或者枚举类型强化singleton属性</h3><p>为了防止反射调用私有构造方法、反序列化时创建新的实例，直接使用 <code>包含单个元素的枚举类型</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Elvis&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h3><p>39条 应该创建新对象时，不要重用现有对象<br>创建不必要的对象只会影响程序的风格和性能，没有实施保护性拷贝将会导致潜在的错误和安全漏洞。</p><h3 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h3><p><code>内存泄露</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建和销毁对象&quot;&gt;&lt;a href=&quot;#创建和销毁对象&quot; class=&quot;headerlink&quot; title=&quot;创建和销毁对象&quot;&gt;&lt;/a&gt;创建和销毁对象&lt;/h2&gt;&lt;h3 id=&quot;静态工厂方法代替构造器&quot;&gt;&lt;a href=&quot;#静态工厂方法代替构造器&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Java" scheme="https://haohaozaici.github.io/categories/Java/"/>
    
      <category term="Effective Java" scheme="https://haohaozaici.github.io/categories/Java/Effective-Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Mifare 1k S50卡</title>
    <link href="https://haohaozaici.github.io/2017/12/13/M1%20card/"/>
    <id>https://haohaozaici.github.io/2017/12/13/M1 card/</id>
    <published>2017-12-13T08:41:43.000Z</published>
    <updated>2018-04-20T02:05:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>背景：最近的项目中涉及到读写M1卡，之前完全没接触过一脸懵逼，却没意识到，生活中常用的公交卡、门禁卡、开水卡、会员卡等等大多数都是M1类的射频卡，如Mifare 1k S50系列。熟悉了相关知识后，发现原理如此简单，感谢开源也因此能做很多方便的事情了。记录一下，面对陌生的事物不要害怕，了解熟悉，探索乐趣。</p></blockquote><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="M1卡"><a href="#M1卡" class="headerlink" title="M1卡"></a>M1卡</h3><p>M1卡结构</p><div style="align: center"><img src="/img/m1card.webp" alt="M1卡结构"> </div><p>从上面可以看到，<code>扇区0 块0</code>固化了厂家代码，32位16进制数，一般作为<code>ID</code>使用。</p><p>每一个扇区的块3用于保存<code>KEY A,存取控制,KEY B</code>，除了扇区0的块0之外的其他的<code>块0~块2</code>都用于存储数据。<code>KEY A</code>不可读、可写，<code>KEY B</code>可读可写.</p><p>一般的门禁卡中，不存储任何数据，门禁系统只读取卡ID，学校里使用的开水卡，一般是离线使用，卡的余额或者使用次数是存储在卡中的，使用时进行读写。在武汉通中，存储了卡余额，储值、消费记录，具体的余额存储在服务器上。所以理论上可以模拟卡ID来模拟门禁卡，或者是读取修改水卡值来修改卡。</p><p>读写卡工具<a href="https://play.google.com/store/apps/details?id=de.syss.MifareClassicTool" target="_blank" rel="noopener">MIFARE Classic Tool</a>, <a href="https://github.com/ikarus23/MifareClassicTool" target="_blank" rel="noopener">MifareClassicTool - GitHub</a></p><p>模拟卡工具<a href="https://play.google.com/store/apps/details?id=com.yuanwofei.cardemulator" target="_blank" rel="noopener">NFC卡模拟</a></p><h4 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h4><p><a href="https://www.null17.com/blog/coding/NFC/20151019-nfc-mod/" target="_blank" rel="noopener">Mifare 1k S50 卡的简单探讨与破解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;背景：最近的项目中涉及到读写M1卡，之前完全没接触过一脸懵逼，却没意识到，生活中常用的公交卡、门禁卡、开水卡、会员卡等等大多数都是M1类的射频卡，如Mifare 1k S50系列。熟悉了相关知识后，发现原理如此简单，感谢开源也因此能做很多方便的事情
      
    
    </summary>
    
      <category term="生活" scheme="https://haohaozaici.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="乱七八糟的技巧" scheme="https://haohaozaici.github.io/categories/%E7%94%9F%E6%B4%BB/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
</feed>
