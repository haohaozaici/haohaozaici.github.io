<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浩浩的被窝</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://haohaozaici.github.io/"/>
  <updated>2018-06-08T01:27:33.445Z</updated>
  <id>https://haohaozaici.github.io/</id>
  
  <author>
    <name>haohaozaici</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac上编译ijkplayer so支持HTTPS</title>
    <link href="https://haohaozaici.github.io/2018/06/07/build-ijkplayer/"/>
    <id>https://haohaozaici.github.io/2018/06/07/build-ijkplayer/</id>
    <published>2018-06-07T08:02:19.000Z</published>
    <updated>2018-06-08T01:27:33.445Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>当项目中使用ijkplayer，而且还需要播放HTTPS链接的视频时，就比较蛋疼了 (￣.￣)，ijkplayer默认不支持HTTPS播放，但提供了编译OpenSSL的选项，可以自己编译so文件支持HTTPS播放。这篇文章的目的是<strong>引导不熟悉的人完成整个编译过程，提醒过程中的注意事项，还有各种选项的解释</strong>。</p></blockquote><h2 id="我的编译环境"><a href="#我的编译环境" class="headerlink" title="我的编译环境"></a>我的编译环境</h2><p>VMware + Ubuntu编译环境也可以参考，基本上只有命令不同，homebrew的安装这里不再赘述。非常不建议在Windows环境下编译！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mac 10.13.2</span><br><span class="line">iTerm2 + zsh</span><br><span class="line">HomeBrew</span><br><span class="line">NDK r10e</span><br><span class="line"></span><br><span class="line">NDK + 编译所有so大概需要10GB空间</span><br></pre></td></tr></table></figure></p><p>相关链接:</p><ul><li><a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="noopener">Bilibili/ijkplayer</a></li><li><a href="https://www.jianshu.com/p/bd289e25d272" target="_blank" rel="noopener">IJKPlayer编译so支持HTTPS的踩坑历程</a></li><li><a href="https://blog.csdn.net/coder_pig/article/details/79134625" target="_blank" rel="noopener">ijkplayer编译so库真没那么难</a></li></ul><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><h3 id="安装Git与yasm"><a href="#安装Git与yasm" class="headerlink" title="安装Git与yasm"></a>安装Git与yasm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br><span class="line">brew install yasm</span><br></pre></td></tr></table></figure><h3 id="配置SDK、NDK"><a href="#配置SDK、NDK" class="headerlink" title="配置SDK、NDK"></a>配置SDK、NDK</h3><p>SDK都会有，NDK一般没有下载，建议去官网下载:<a href="https://developer.android.google.cn/ndk/downloads/older_releases" target="_blank" rel="noopener">https://developer.android.google.cn/ndk/downloads/older_releases</a></p><p>需要注意的是最好下载官方lib使用的<strong>NDK r10e</strong>，使用其他版本的将无法编译。具体原因可以参考<a href="https://github.com/Bilibili/ijkplayer/issues/2752" target="_blank" rel="noopener">这篇issue</a></p><p>SDK、NDK和准备完成后，在<code>.bash_profile</code>, 或者是<code>.zshrc</code>中添加配置。(<code>Command + shift + .</code> 显示隐藏文件)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 注意替换为自己的文件路径</span><br><span class="line">export ANDROID_SDK=/Users/haoyuan/Library/Android/sdk</span><br><span class="line">export PATH=$ANDROID_SDK/platform-tools:$PATH</span><br><span class="line">export PATH=$ANDROID_SDK/tools:$PATH</span><br><span class="line">export ANDROID_NDK=/Users/haoyuan/Library/Android/android-ndk-r10e</span><br><span class="line">export PATH=$ANDROID_NDK:$PATH</span><br></pre></td></tr></table></figure><p>添加完成后，保存文件，然后<code>source .bash_profile</code>等相关文件，或者<strong>直接重启终端</strong>，通过 <code>ndk-build -v</code> 检查是否生效</p><p><img src="https://ww1.sinaimg.cn/large/a328671cly1fs2p78ggb9j20ug084dpy.jpg" alt="img"></p><h3 id="clone-ijkplayer源码"><a href="#clone-ijkplayer源码" class="headerlink" title="clone ijkplayer源码"></a>clone ijkplayer源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Bilibili/ijkplayer.git ijkplayer-android</span><br><span class="line">cd ijkplayer-android</span><br><span class="line">git checkout -B latest k0.8.8</span><br></pre></td></tr></table></figure><h2 id="2-编译之前"><a href="#2-编译之前" class="headerlink" title="2. 编译之前"></a>2. 编译之前</h2><h3 id="编译前选择你的配置"><a href="#编译前选择你的配置" class="headerlink" title="编译前选择你的配置"></a>编译前选择你的配置</h3><p>选择自动化编译时的一些配置选项，比如支持的协议，音视频类型等，官方给我们提供了三个模板。</p><p>可以打开config/目录下config/module.sh看看，enable启用，disable禁用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module-default.sh</span><br><span class="line">module-lite-hevc.sh</span><br><span class="line">module-lite.sh</span><br></pre></td></tr></table></figure></p><p><img src="https://ww1.sinaimg.cn/large/a328671cly1fs2p78eh8lj20yc0xqwir.jpg" alt="img"></p><p>官方默认建议选择的是 <code>module-lite.sh</code>，可以根据自己的需求选择<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd config</span><br><span class="line">rm module.sh</span><br><span class="line">ln -s module-lite.sh module.sh</span><br></pre></td></tr></table></figure></p><p>如果要选择<code>module-default.sh</code>的话，可能会编译失败，可以参考<a href="https://github.com/Bilibili/ijkplayer/issues/4043" target="_blank" rel="noopener">这篇issue</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">仔细阅读module-lite.h 原来在最下面有一行配置：</span><br><span class="line">export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --disable-linux-perf&quot;</span><br><span class="line">把这行复制到module-default.sh 的最后面就可以了</span><br></pre></td></tr></table></figure></p><h2 id="3-开始编译ヽ-｀⌒´-ﾉ"><a href="#3-开始编译ヽ-｀⌒´-ﾉ" class="headerlink" title="3. 开始编译ヽ(｀⌒´)ﾉ"></a>3. 开始编译ヽ(｀⌒´)ﾉ</h2><h3 id="执行初始化"><a href="#执行初始化" class="headerlink" title="执行初始化"></a>执行初始化</h3><p>初始化会下载各种包，尽量选择在良好的网络环境下╮(￣▽￣)╭<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">./init-android.sh</span><br></pre></td></tr></table></figure></p><p>初始化OpenSSL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./init-android-openssl.sh</span><br></pre></td></tr></table></figure></p><h3 id="编译OpenSSL和FFmpeg"><a href="#编译OpenSSL和FFmpeg" class="headerlink" title="编译OpenSSL和FFmpeg"></a>编译OpenSSL和FFmpeg</h3><p>首先清除一波<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd android/contrib</span><br><span class="line">./compile-openssl.sh clean</span><br><span class="line">./compile-ffmpeg.sh clean</span><br></pre></td></tr></table></figure></p><p>编译OpenSSL：可以选择不同版本，全量编译耗时更长，但最好选择全量编译，编译完成后再根据需求选择要使用的包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./compile-openssl.sh all</span><br></pre></td></tr></table></figure></p><p>编译FFmpeg，同样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./compile-ffmpeg.sh all</span><br><span class="line"></span><br><span class="line">// 如果要选择特定的架构: ./compile-ffmpeg.sh armv7a | armv5</span><br></pre></td></tr></table></figure></p><p>最后编译ijkplayer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./compile-ijk.sh all</span><br></pre></td></tr></table></figure></p><p>经过漫长的等待终于完成了以上编译过程\（￣︶￣）/，在目录中生成了ijkplayer的工程<br><img src="https://ww1.sinaimg.cn/large/a328671cly1fs2p78dwkmj20hq09vac5.jpg" alt="IMG"></p><h2 id="4-导入项目"><a href="#4-导入项目" class="headerlink" title="4. 导入项目"></a>4. 导入项目</h2><p>原有的项目一般是这样配置的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;tv.danmaku.ijk.media:ijkplayer-java:&apos; + gradle.ijkplayer_java</span><br><span class="line">implementation &apos;tv.danmaku.ijk.media:ijkplayer-armv7a:&apos; + gradle.ijkplayer_java</span><br></pre></td></tr></table></figure></p><p>如果只需要修改so库的话，<strong>删除掉第二行对so库的引用，将自己编译好的so文件复制到项目的libs文件夹中</strong>。</p><p>别忘了在gradle中配置，要不然会报错找不到so库<br><img src="https://ww1.sinaimg.cn/large/a328671cly1fs2p78cr4dj209602vgll.jpg" alt="IMG"></p><p>还可以在release包中设置abi过滤<br><img src="https://ww1.sinaimg.cn/large/a328671cly1fs2p78dgn4j20l50cgwfu.jpg" alt="IMG"></p><p>最后大功告成啦\(^o^)/</p><p>尾巴…</p><p>如果项目中同时使用了HTTP和HTTPS的视频源的话，要注意如果视频源刚好是相同域名，会导致播放失败，这是由于dns缓存造成的，解决办法参考<a href="https://github.com/CarGuo/GSYVideoPlayer/issues/1175" target="_blank" rel="noopener">这篇issue</a><br>初始化<code>IjkMediaPlayer</code>时，设置清除<code>dns cache</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;dns_cache_clear&quot;, 1</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;当项目中使用ijkplayer，而且还需要播放HTTPS链接的视频时，就比较蛋疼了 (￣.￣)，ijkplayer默认不支持HTTPS播放，但提供了编译OpenSSL的选项，可以自己编译so文件支持HTTPS播放。这篇文章的目的是&lt;strong&gt;引
      
    
    </summary>
    
      <category term="Android" scheme="https://haohaozaici.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android音频焦点与声音重叠</title>
    <link href="https://haohaozaici.github.io/2018/04/24/Android%20Sound%20overlap/"/>
    <id>https://haohaozaici.github.io/2018/04/24/Android Sound overlap/</id>
    <published>2018-04-24T11:22:02.000Z</published>
    <updated>2018-04-24T11:27:23.818Z</updated>
    
    <content type="html"><![CDATA[<p>音视频播放在手机日常使用中非常频繁，当我们听着音乐刷着微博时，看到有趣的视频点击开始播放，音乐自动暂停，退出视频时音乐又自动恢复了播放(如果没有自动恢复的话，比如QQ音乐就会提示是否设置中断后继续播放)。</p><p><img src="https://img.mukewang.com/5aded21b0001ab9210801920.png" width="240" alt="中断后继续播放"></p><p>这一系列流畅自然的操作不是理所应当的吗~当然如果处理不好的话就会出现声音重叠，音频焦点长期被占用的问题，下面我们来看看具体的功能逻辑。</p><p>音频焦点相关的讲解参考以下文章</p><blockquote><p><a href="https://www.jianshu.com/p/5d8d7b677690" target="_blank" rel="noopener">Android音频焦点详解</a><br><a href="https://developer.android.com/guide/topics/media-apps/audio-focus.html" target="_blank" rel="noopener">Managing Audio Focus</a></p></blockquote><h2 id="Managing-Audio-Focus"><a href="#Managing-Audio-Focus" class="headerlink" title="Managing Audio Focus"></a>Managing Audio Focus</h2><p>不同的APP可以同时播放音频，系统会将他们混合在一起，但为了避免同时播放，Android提供了<strong>audio focus</strong>机制来合理使用音频播放资源。同一时间只能有一个APP获取音频焦点，当需要播放音频时，应该立即请求音频焦点，同样的，在你的APP获取到音频焦点后，其他APP也可以抢占音频焦点，这时你的APP就需要暂停播放或降低声音。音频焦点是合作类型的，APP拥有完全自主的控制权，系统无法阻止，但应用应该遵守音频焦点的指导规则。</p><p>好的音频APP在播放时应该遵守以下规则：</p><ul><li>开始播放后立即调用<code>requestAudioFocus()</code>方法，并验证返回值为<code>AUDIOFOCUS_REQUEST_GRANTED</code></li><li>当其他app占用音频焦点时，暂停或停止播放，或者降低声音</li><li>当播放停止时，放弃音频焦点</li></ul><p>在不同的Android版本下，需要使用不同的方法来处理音频焦点：</p><ul><li><em>API level 8</em>以后，使用<code>requestAudioFocus()</code>和<code>abandonAudioFocus()</code>方法，并注册<code>AudioManager.OnAudioFocusChangeListener</code>接收回调。</li><li><em>API level 21</em>以后，需要使用<code>AudioAttributes</code>来描述播放音频的类型。</li><li><p><em>API level 26</em>以后，需要使用<code>AudioFocusRequest</code>参数，它携带了音频的context和相关功能，系统会根据这些自动管理音频焦点。</p><h3 id="Android8-0以前"><a href="#Android8-0以前" class="headerlink" title="Android8.0以前"></a>Android8.0以前</h3><p>参考官方文档获取焦点的方法如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Request audio focus for playback</span></span><br><span class="line"><span class="keyword">int</span> result = am.requestAudioFocus(afChangeListener,</span><br><span class="line">        <span class="comment">// Use the music stream.</span></span><br><span class="line">        AudioManager.STREAM_MUSIC,</span><br><span class="line">        <span class="comment">// Request permanent focus.</span></span><br><span class="line">        AudioManager.AUDIOFOCUS_GAIN);</span><br></pre></td></tr></table></figure><p>但在听音乐的时候播放音频或视频，依旧出现了重叠的声音，实际上有效的做法是这样的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面两个常量参数试过很多 都无效，最终反编译了其他app才搞定，汗~  </span></span><br><span class="line"><span class="keyword">int</span> requestFocusResult = mAudioManager.requestAudioFocus(</span><br><span class="line">        mAudioFocusChangeListener,</span><br><span class="line">        AudioManager.STREAM_MUSIC,</span><br><span class="line">        AudioManager.AUDIOFOCUS_GAIN_TRANSIENT);</span><br></pre></td></tr></table></figure></p><p>具体参考文章<a href="https://blog.csdn.net/SYIF88/article/details/68064866" target="_blank" rel="noopener">Android MediaPlayer音频焦点问题，抢占声道</a></p><p>最后在对应的播放状态下获取和释放音频焦点。</p><h3 id="Android8-0之后"><a href="#Android8-0之后" class="headerlink" title="Android8.0之后"></a>Android8.0之后</h3><p>和之前一样，Android8.0中也使用了<code>requestAudioFocus()</code>来请求音频焦点，不一样的是，使用<code>abandonAudioFocusRequest()</code>释放音频焦点，并且请求和释放都需要传入同一个<code>AudioFocusRequest</code>实例。使用<code>AudioFocusRequest.Builder</code>来创建，具体实现代码参考官方文档<a href="https://developer.android.com/guide/topics/media-apps/audio-focus.html#audio-focus-8-0" target="_blank" rel="noopener">Audio focus in Android 8.0 and later</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mAudioFocusRequest = <span class="keyword">new</span> AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN)</span><br><span class="line">        .setAudioAttributes(<span class="keyword">new</span> AudioAttributes.Builder()</span><br><span class="line">                .setUsage(AudioAttributes.USAGE_MEDIA)</span><br><span class="line">                .setContentType(AudioAttributes.CONTENT_TYPE_MOVIE)</span><br><span class="line">                .build())</span><br><span class="line">        .setAcceptsDelayedFocusGain(<span class="keyword">true</span>)</span><br><span class="line">        .setOnAudioFocusChangeListener(mAudioFocusChangeListener)</span><br><span class="line">        .build();</span><br><span class="line"><span class="comment">//请求音频焦点      </span></span><br><span class="line">requestFocusResult = mAudioManager.requestAudioFocus(mAudioFocusRequest);</span><br><span class="line"><span class="comment">//释放音频焦点</span></span><br><span class="line">abandonFocusResult = mAudioManager.abandonAudioFocusRequest(mAudioFocusRequest);</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>Android8.0中其他APP使用<code>AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK</code>参数获取焦点时，将不会回调本APP的<code>onAudioFocusChange()</code>方法。</li><li>焦点延迟获取，当焦点被其他APP<strong>“锁”</strong>住时，<code>requestAudioFocus()</code>会返回<code>AUDIOFOCUS_REQUEST_FAILED</code>，比如正在打电话时，焦点就会被锁住。如果使用了<code>setAcceptsDelayedFocusGain(true)</code>方法，请求将会返回<code>AUDIOFOCUS_REQUEST_DELAYED</code>，在锁解除后，系统会继续处理未完成的焦点请求，并回调<code>onAudioFocusChange()</code>方法。</li></ul><h2 id="处理音频焦点变化"><a href="#处理音频焦点变化" class="headerlink" title="处理音频焦点变化"></a>处理音频焦点变化</h2><p>了解相应的请求、释放方法后，还需要进一步处理音频焦点变化问题，也就是优化跟其他APP或者是系统APP合作的过程。主要是处理<code>onAudioFocusChange</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AudioManager.OnAudioFocusChangeListener mAudioFocusChange = <span class="keyword">new</span> AudioManager.OnAudioFocusChangeListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAudioFocusChange</span><span class="params">(<span class="keyword">int</span> focusChange)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (focusChange)&#123;</span><br><span class="line">                <span class="keyword">case</span> AudioManager.AUDIOFOCUS_GAIN:</span><br><span class="line">                    <span class="comment">//当其他应用申请焦点之后又释放焦点会触发此回调</span></span><br><span class="line">                    <span class="comment">//可重新播放音乐</span></span><br><span class="line">                    Log.d(TAG, <span class="string">"AUDIOFOCUS_GAIN"</span>);</span><br><span class="line">                    start();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS:</span><br><span class="line">                    <span class="comment">//长时间丢失焦点,当其他应用申请的焦点为AUDIOFOCUS_GAIN时，</span></span><br><span class="line">                    <span class="comment">//会触发此回调事件，例如播放QQ音乐，网易云音乐等</span></span><br><span class="line">                    <span class="comment">//通常需要暂停音乐播放，若没有暂停播放就会出现和其他音乐同时输出声音</span></span><br><span class="line">                    Log.d(TAG, <span class="string">"AUDIOFOCUS_LOSS"</span>);</span><br><span class="line">                    stop();</span><br><span class="line">                    <span class="comment">//释放焦点，该方法可根据需要来决定是否调用</span></span><br><span class="line">                    <span class="comment">//若焦点释放掉之后，将不会再自动获得</span></span><br><span class="line">                    mAudioManager.abandonAudioFocus(mAudioFocusChange);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:</span><br><span class="line">                    <span class="comment">//短暂性丢失焦点，当其他应用申请AUDIOFOCUS_GAIN_TRANSIENT或AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE时，</span></span><br><span class="line">                    <span class="comment">//会触发此回调事件，例如播放短视频，拨打电话等。</span></span><br><span class="line">                    <span class="comment">//通常需要暂停音乐播放</span></span><br><span class="line">                    stop();</span><br><span class="line">                    Log.d(TAG, <span class="string">"AUDIOFOCUS_LOSS_TRANSIENT"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:</span><br><span class="line">                    <span class="comment">//短暂性丢失焦点并作降音处理</span></span><br><span class="line">                    Log.d(TAG, <span class="string">"AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>音频相关的API常常让人疑惑，明明已经根据注释的描述和官方文档中的方法实现了，却达不到预期的效果。还有就是随着Android更新的推送速度越来越快，更新普及率也水涨船高，高版本API随时在发生变化，适配时需要注意这些细节，以及进行完善的测试。</p><p>工具类参见<a href="https://gist.github.com/haohaozaici/baaa022e6ea5f61f37112135fe1cac07" target="_blank" rel="noopener">AudioFocusManager</a></p><h4 id="未完成内容"><a href="#未完成内容" class="headerlink" title="未完成内容"></a>未完成内容</h4><p>源码简单分析</p><p>在不同机型中进行测试</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;音视频播放在手机日常使用中非常频繁，当我们听着音乐刷着微博时，看到有趣的视频点击开始播放，音乐自动暂停，退出视频时音乐又自动恢复了播放(如果没有自动恢复的话，比如QQ音乐就会提示是否设置中断后继续播放)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.mukew
      
    
    </summary>
    
      <category term="Android" scheme="https://haohaozaici.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>创建和销毁对象</title>
    <link href="https://haohaozaici.github.io/2017/12/19/create-and-destroy-objects/"/>
    <id>https://haohaozaici.github.io/2017/12/19/create-and-destroy-objects/</id>
    <published>2017-12-19T07:12:41.000Z</published>
    <updated>2017-12-29T15:17:35.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h2><h3 id="静态工厂方法代替构造器"><a href="#静态工厂方法代替构造器" class="headerlink" title="静态工厂方法代替构造器"></a>静态工厂方法代替构造器</h3><p>静态工厂方法与设计模式中的<code>工厂方法</code>不同。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li>静态工厂方法有名称，</li></ol><h3 id="遇到多个构造器参数时，使用构建器-Builder模式"><a href="#遇到多个构造器参数时，使用构建器-Builder模式" class="headerlink" title="遇到多个构造器参数时，使用构建器-Builder模式"></a>遇到多个构造器参数时，使用构建器-Builder模式</h3><h4 id="1-使用构造方法创建对象"><a href="#1-使用构造方法创建对象" class="headerlink" title="1.使用构造方法创建对象"></a>1.使用构造方法创建对象</h4><p>重叠构造器</p><h4 id="2-JavaBeans模式"><a href="#2-JavaBeans模式" class="headerlink" title="2.JavaBeans模式"></a>2.JavaBeans模式</h4><p>通过setter方法设置必要参数，拥有良好的可读性。<br><em>缺点</em>：构造过程中容易被改变，处于不一致的状态。</p><h4 id="3-Builder模式"><a href="#3-Builder模式" class="headerlink" title="3.Builder模式"></a>3.Builder模式</h4><p>通过公开的Builder内部类，私有的构造方法，构造必传参数和可选参数。Builder模式模拟了具名的可选参数，可以加强约束条件，在对象域中进行检验。可以在编译时进行异常检查。 </p><p><em>缺点</em>：特殊情况下额外的性能开销，冗长。<br><em>适用情况</em>：多个参数(大于4个)，需要比JavaBeans模式更加安全的情况。</p><p>参见 <code>Notification</code> 或 <code>Alertdialog</code>类。</p><h3 id="用私有构造器或者枚举类型强化singleton属性"><a href="#用私有构造器或者枚举类型强化singleton属性" class="headerlink" title="用私有构造器或者枚举类型强化singleton属性"></a>用私有构造器或者枚举类型强化singleton属性</h3><p>为了防止反射调用私有构造方法、反序列化时创建新的实例，直接使用 <code>包含单个元素的枚举类型</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Elvis&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h3><p>39条 应该创建新对象时，不要重用现有对象<br>创建不必要的对象只会影响程序的风格和性能，没有实施保护性拷贝将会导致潜在的错误和安全漏洞。</p><h3 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h3><p><code>内存泄露</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建和销毁对象&quot;&gt;&lt;a href=&quot;#创建和销毁对象&quot; class=&quot;headerlink&quot; title=&quot;创建和销毁对象&quot;&gt;&lt;/a&gt;创建和销毁对象&lt;/h2&gt;&lt;h3 id=&quot;静态工厂方法代替构造器&quot;&gt;&lt;a href=&quot;#静态工厂方法代替构造器&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Java" scheme="https://haohaozaici.github.io/categories/Java/"/>
    
      <category term="Effective Java" scheme="https://haohaozaici.github.io/categories/Java/Effective-Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Mifare 1k S50卡</title>
    <link href="https://haohaozaici.github.io/2017/12/13/M1%20card/"/>
    <id>https://haohaozaici.github.io/2017/12/13/M1 card/</id>
    <published>2017-12-13T08:41:43.000Z</published>
    <updated>2018-04-20T02:05:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>背景：最近的项目中涉及到读写M1卡，之前完全没接触过一脸懵逼，却没意识到，生活中常用的公交卡、门禁卡、开水卡、会员卡等等大多数都是M1类的射频卡，如Mifare 1k S50系列。熟悉了相关知识后，发现原理如此简单，感谢开源也因此能做很多方便的事情了。记录一下，面对陌生的事物不要害怕，了解熟悉，探索乐趣。</p></blockquote><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="M1卡"><a href="#M1卡" class="headerlink" title="M1卡"></a>M1卡</h3><p>M1卡结构</p><div style="align: center"><img src="/img/m1card.webp" alt="M1卡结构"> </div><p>从上面可以看到，<code>扇区0 块0</code>固化了厂家代码，32位16进制数，一般作为<code>ID</code>使用。</p><p>每一个扇区的块3用于保存<code>KEY A,存取控制,KEY B</code>，除了扇区0的块0之外的其他的<code>块0~块2</code>都用于存储数据。<code>KEY A</code>不可读、可写，<code>KEY B</code>可读可写.</p><p>一般的门禁卡中，不存储任何数据，门禁系统只读取卡ID，学校里使用的开水卡，一般是离线使用，卡的余额或者使用次数是存储在卡中的，使用时进行读写。在武汉通中，存储了卡余额，储值、消费记录，具体的余额存储在服务器上。所以理论上可以模拟卡ID来模拟门禁卡，或者是读取修改水卡值来修改卡。</p><p>读写卡工具<a href="https://play.google.com/store/apps/details?id=de.syss.MifareClassicTool" target="_blank" rel="noopener">MIFARE Classic Tool</a>, <a href="https://github.com/ikarus23/MifareClassicTool" target="_blank" rel="noopener">MifareClassicTool - GitHub</a></p><p>模拟卡工具<a href="https://play.google.com/store/apps/details?id=com.yuanwofei.cardemulator" target="_blank" rel="noopener">NFC卡模拟</a></p><h4 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h4><p><a href="https://www.null17.com/blog/coding/NFC/20151019-nfc-mod/" target="_blank" rel="noopener">Mifare 1k S50 卡的简单探讨与破解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;背景：最近的项目中涉及到读写M1卡，之前完全没接触过一脸懵逼，却没意识到，生活中常用的公交卡、门禁卡、开水卡、会员卡等等大多数都是M1类的射频卡，如Mifare 1k S50系列。熟悉了相关知识后，发现原理如此简单，感谢开源也因此能做很多方便的事情
      
    
    </summary>
    
      <category term="生活" scheme="https://haohaozaici.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="乱七八糟的技巧" scheme="https://haohaozaici.github.io/categories/%E7%94%9F%E6%B4%BB/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
</feed>
