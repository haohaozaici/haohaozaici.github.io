<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浩浩的被窝</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://haohaozaici.github.io/"/>
  <updated>2020-09-30T04:06:49.667Z</updated>
  <id>https://haohaozaici.github.io/</id>
  
  <author>
    <name>haohaozaici</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>三亚游记</title>
    <link href="https://haohaozaici.github.io/2020/09/30/%E4%B8%89%E4%BA%9A%E6%B8%B8%E8%AE%B0/"/>
    <id>https://haohaozaici.github.io/2020/09/30/三亚游记/</id>
    <published>2020-09-30T03:46:25.000Z</published>
    <updated>2020-09-30T04:06:49.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="出发之前"><a href="#出发之前" class="headerlink" title="出发之前"></a>出发之前</h2><p>因为最近的一些事情，对出门旅行的兴趣不大，更想要的是自由活动的时间，但后来又发生了一些事情。不管怎么说，还是准备出发了。<br>预计旅行时间4天，周五到下周一，三亚天气阵雨，气温30°左右，要准备的东西不多，包括两套速干的衣物，泳裤，小瓶防晒霜，遮阳伞，凉鞋，还有一些通用旅行装备。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通用旅行装备：</span><br><span class="line"><span class="bullet">- </span>出门用的小背包</span><br><span class="line"><span class="bullet">- </span>充电宝，降噪耳机，switch</span><br><span class="line"><span class="bullet">- </span>纸巾，湿纸巾，薄荷糖</span><br><span class="line"><span class="bullet">- </span>根据目的地选用：牙刷、牙膏、毛巾，洗澡套装，雨伞</span><br><span class="line"><span class="bullet">- </span>坐飞机：小水杯</span><br></pre></td></tr></table></figure><p><br></p><h2 id="出发、到达、亚龙湾"><a href="#出发、到达、亚龙湾" class="headerlink" title="出发、到达、亚龙湾"></a>出发、到达、亚龙湾</h2><p>2020.9.11早晨出发首都机场t3航站楼，这时北京的天气已经非常凉爽，除了阳光有一点点晒。第一次坐长时间的航班，海南航空的中型机，预计4个小时，实际飞行时间3个半小时，体验很不错，比小型机要稳的多，噪音、空间也更好，还发了入耳式耳机，不过我已经有降噪耳机了，没有用上。选择了后排靠窗的位置，一路上看窗外的风景也非常壮丽。</p><p><img src="/img/sanya/20200911_124921.jpg" alt="img"><br><img src="/img/sanya/20200911_131843.jpg" alt="img"></p><p><br></p><p>到三亚了，海岛的风景确实完全不一样，云层很低，一朵朵像棉花糖，压在头顶上。虽然早有心里准备，但湿润的空气，闷热的感觉还是有点不舒服。<br>入住的酒店是亚龙湾的喜来登，因为是团建，同事提前选好的，我也没有关心价格和位置，酒店的大厅可以直接看到海滩，第一次看到真的超级兴奋，让我想到了神秘海域4最后一章的场景。</p><p><img src="/img/sanya/20200911_161147.jpg" alt="img"></p><p><br></p><p>赶紧到房间，换上泳裤，出发海滩。之前我哥暑假去过海边，不记得是广州还是无锡了，听姐姐们说，他喜欢坐在泳圈里，让海浪推到沙滩上。我已经有点迫不及待了。冲进海水里，没想到沙子这么软，脚下一滑就摔倒了，挣扎着想站起来，一波浪推了过来，沙子太软，脚下站不稳，又翻进海水里了。几秒钟，喝了好几口海水，超级咸的海水，灌在我的鼻腔里，很难受。不过兴奋的心情让我无视了这些，在沙滩边游了起来。</p><p><img src="/img/sanya/20200911_172705.jpg" alt="img"></p><p><br></p><h2 id="三亚湾"><a href="#三亚湾" class="headerlink" title="三亚湾"></a>三亚湾</h2><p>第二天，我们起早拿到租的帕萨特，一行5人出发去了三亚市区，前往三亚湾，可能是因为疫情和淡季的关系，沙滩上没有几个人。超大的海湾，壮丽的风景，让我的心情好了很多很多。只是闷热、暴晒的天气让我不敢在外面多待，这里要感谢遮阳伞，光靠防晒霜是肯定顶不住的。玩了好一会儿舍不得走，还看到了寄居蟹。然后我们前往了几个景区，虽然都没有进去哈哈，喝了10块钱一个酸酸的冰椰子。</p><p>图图图</p><p>傍晚，回到酒店，这时的三亚湾超美，海浪不断的涌向海滩，黄昏的云，有一种温柔的感觉。</p><p>图图</p><p><br></p><h2 id="日出"><a href="#日出" class="headerlink" title="日出"></a>日出</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;出发之前&quot;&gt;&lt;a href=&quot;#出发之前&quot; class=&quot;headerlink&quot; title=&quot;出发之前&quot;&gt;&lt;/a&gt;出发之前&lt;/h2&gt;&lt;p&gt;因为最近的一些事情，对出门旅行的兴趣不大，更想要的是自由活动的时间，但后来又发生了一些事情。不管怎么说，还是准备出发了。&lt;b
      
    
    </summary>
    
      <category term="旅游" scheme="https://haohaozaici.github.io/categories/%E6%97%85%E6%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>「播放器」初识ExoPlayer</title>
    <link href="https://haohaozaici.github.io/2019/07/15/exoplayer_1/"/>
    <id>https://haohaozaici.github.io/2019/07/15/exoplayer_1/</id>
    <published>2019-07-15T08:45:27.000Z</published>
    <updated>2019-07-15T13:15:49.255Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这只是一篇记录</p></blockquote><h2 id="又爱又恨的ijkplayer"><a href="#又爱又恨的ijkplayer" class="headerlink" title="又爱又恨的ijkplayer"></a>又爱又恨的<a href="https://github.com/bilibili/ijkplayer" target="_blank" rel="noopener">ijkplayer</a></h2><p>刚开始准备改造视频播放器的时候，对比了<code>ijkplayer</code>和<code>ExoPlayer</code>，我们的用例是HLS源点播，因为ijkplayer中文资料更多，支持更多的格式，而且b站这么多的用户，”兼容性”应该更好，所以毫不犹豫选择了ijkplayer。实际使用起来也并不复杂，简单封装修改了IjkVideoView，根据需要修改编译配置，编译so库，API使用非常方便。但是在使用了大半年ijkplayer后，被几个问题一直困扰，导致现在不得不考虑更换。</p><p>遇到的问题：</p><ol><li>经常出现加载失败，一直在加载</li><li>错误状态不清晰，比较难定位问题</li><li>IjkMediaPlayer不保证复用安全</li><li>在某些4.4机型上频繁创建IjkMediaPlayer会崩溃</li></ol><p>加载失败的问题最严重，虽然用户量不算大，但经常收到反馈，出现的情况比如<strong>播放时频繁加载、播放一段时间就卡住了，一直显示在加载</strong>，由于IjkMediaPlayer不保证复用安全，只能重新创建MediaPlayer。起初我以为只是用户的网络问题，或者是视频服务、CDN问题。但随着类似的反馈越来越多，问题肯定出在播放器上，我也尝试过各种设置，修改了各种参数，还有类似<code>ijkhttphook</code>等等，都无法解决。加载慢还带来了seek慢问题，<strong>seek之后需要等待很长时间才生效</strong>，当然这和视频源也有很大的关系，但在iOS、web端都正常。</p><p>错误状态不清晰也让我逐渐对她失去信心，视频源、播放设备都可能会出现问题，因为无法定位问题，浪费了很多时间联系用户，错误内容也没有直观的信息，每次收到出错日志都慌的一匹。</p><p>其他的如在某些4.4机型上频繁创建IjkMediaPlayer会崩溃，不断累积的native异常等，可靠性也不算好。不能确定是否是硬解软解与显示surface的问题，在Profiler里观察到播放效率(耗电量)明显偏高，内存占用也不少。</p><p>我并不擅长FFmpeg和c语言，没有信心在ijkplayer的基础上修改好，再加上一些安全性问题，需要修改之前的自定义协议方式，综合以上，在前段时间开始准备迁移到ExoPlayer。</p><h2 id="迁移到ExoPlayer"><a href="#迁移到ExoPlayer" class="headerlink" title="迁移到ExoPlayer"></a>迁移到<a href="https://github.com/google/ExoPlayer" target="_blank" rel="noopener">ExoPlayer</a></h2><h3 id="首先想好做什么"><a href="#首先想好做什么" class="headerlink" title="首先想好做什么"></a>首先想好做什么</h3><p>目标很清晰，替换<code>IjkMediaPlayer -&gt; Player</code>、<code>IjkVideoView -&gt; PlayerView</code>，因为并不打算继续使用ijkplayer，而且两个播放器API差异不算小，所以没有使用接口抽象继续兼容ijkplayer，播放器与业务相关的API改动不大，只需要替换player即可。除此之外我还需要加入部分解密算法，实现自定义协议、支持解密，native代码混淆。</p><h3 id="研究原理"><a href="#研究原理" class="headerlink" title="研究原理"></a>研究原理</h3><p>ExoPlayer资料非常丰富详细，包含官方文档、google io视频、丰富的github issue。通过这些方法解决了我遇到的所有问题，并且让我了解了很多相关知识，后面会介绍我涉及到的部分。解密的部分可以通过<code>OpenSSL</code>配合自定义<code>DataSource</code>实现，native代码混淆可以使用<code>ollvm</code>，他们的用法资料也非常多。</p><h3 id="选择方案"><a href="#选择方案" class="headerlink" title="选择方案"></a>选择方案</h3><p>得益于ExoPlayer清晰灵活的结构，很明确，ExoPlayer自定义数据源 + OpenSSL解密数据源 + ollvm native代码混淆。</p><h3 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h3><p>生产环境的大项目可不适合试错，打开配置好的模板demo，编写简单可播放sample的示例，自定义数据源参考<code>ExoPlayer OkHttp extension</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建数据源</span></span><br><span class="line">HttpDataSource</span><br><span class="line">HttpDataSourceFactory</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改数据加载方法，处理请求和响应，满足自定义协议</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">open</span><span class="params">(DataSpec dataSpec)</span> <span class="keyword">throws</span> HttpDataSourceException </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>OpenSSL解密数据源，配置native开发环境，编译OpenSSL动态(静态)链接库，导入头文件，参考官方demo实现AES解密的相关jni方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">jbyte *key = (*env)-&gt;GetByteArrayElements(env, decryptKey, JNI_FALSE);</span><br><span class="line">jbyte *iv = (*env)-&gt;GetByteArrayElements(env, encryptionIv, JNI_FALSE);</span><br><span class="line"></span><br><span class="line">EVP_CIPHER_CTX *ctx;</span><br><span class="line"><span class="comment">/* Create and initialise the context */</span></span><br><span class="line"><span class="keyword">if</span> (!(ctx = EVP_CIPHER_CTX_new())) &#123;</span><br><span class="line">    LOGE(<span class="string">"initialise context failed -1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Initialise the decryption operation. IMPORTANT - ensure you use a key</span></span><br><span class="line"><span class="comment"> * and IV size appropriate for your cipher</span></span><br><span class="line"><span class="comment"> * In this example we are using 256 bit AES (i.e. a 256 bit key). The</span></span><br><span class="line"><span class="comment"> * IV size for *most* modes is the same as the block size. For AES this</span></span><br><span class="line"><span class="comment"> * is 128 bits</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> != EVP_DecryptInit_ex(ctx, EVP_aes_128_cbc(), <span class="literal">NULL</span>,</span><br><span class="line">                            (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *) key,</span><br><span class="line">                            (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *) iv)) &#123;</span><br><span class="line">    LOGE(<span class="string">"DecryptInit failed -2"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(*env)-&gt;ReleaseByteArrayElements(env, decryptKey, key, JNI_FALSE);</span><br><span class="line">(*env)-&gt;ReleaseByteArrayElements(env, encryptionIv, iv, JNI_FALSE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (jlong) ctx;</span><br></pre></td></tr></table></figure><p>使用FFmpeg准备好加密的HLS源，验证sample正确播放</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i 0_blv.mp4 \</span><br><span class="line">-c copy -bsf:v h264_mp4toannexb -hls_time 5 -hls_list_size 0 \</span><br><span class="line">-hls_key_info_file key.info \</span><br><span class="line">encryptionM3U8/output.m3u8</span><br></pre></td></tr></table></figure><p>ollvm native代码混淆，编译支持混淆的llvm，修改ndk toolchain，配置支持混淆的ndk路径，因为native代码并不多，支持的混淆方式都加上了，最后用IDA Pro查看是否混淆成功，一行简单的return代码被加上了几十层循环。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">externalNativeBuild &#123;</span><br><span class="line">    cmake &#123;</span><br><span class="line">        <span class="comment">// 添加各种混淆方式</span></span><br><span class="line">        cFlags <span class="string">"-mllvm -sub -mllvm -bcf -mllvm -fla -mllvm -sobf"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化细节"><a href="#优化细节" class="headerlink" title="优化细节"></a>优化细节</h3><p>在应用到项目之前，可以尝试优化一些细节，比如在线播放的时候加上<code>CacheDataSource</code>作为临时缓存，能极大提升拖动进度条的体验，减少流量消耗</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SimpleCache(downloadContentDirectory, LeastRecentlyUsedCacheEvictor(CACHE_MAX_SIZE))</span><br></pre></td></tr></table></figure><p>提前尝试好各种参数配置，如<code>loadControl</code>，<code>LoadErrorHandlingPolicy</code>，整理好一些工具、辅助类方便处理<code>MediaSession</code>、<code>PlayerNotification</code>、截图、状态栏等等。清晰的错误报告这次不会错过了，处理好方法的异常，返回值，关键点日志，API，注释，混淆配置。</p><h3 id="应用到项目"><a href="#应用到项目" class="headerlink" title="应用到项目"></a>应用到项目</h3><p>最后就需要耐心的接入到项目中了，发布SDK到maven仓库，细心的修改不同功能模块，细粒度的对比检查、提交代码。经过几周的测试，生产环境试用，最终优雅的解决了之前自定义协议带来的问题，网络加载问题得到了极大的改善，内存消耗减少，性能也显著提升。</p><p>通过使用ijkplayer了解到很多视频播放相关的知识，但每当我想一窥究竟的时候，里面的内容却是不熟悉的c代码。亲切的Java代码，加上ExoPlayer清晰的结构，把里面复杂的模块拆分展现出来，终于认识到我写的一串<code>newSimpleInstance</code>代码到底是什么了。</p><p>参考资料：</p><ul><li><a href="https://exoplayer.dev/" target="_blank" rel="noopener">exoplayer.dev</a></li><li><a href="https://medium.com/google-exoplayer" target="_blank" rel="noopener">google-exoplayer blog</a></li><li><a href="https://wiki.openssl.org/index.php/EVP_Symmetric_Encryption_and_Decryption#Decrypting_the_Message" target="_blank" rel="noopener">openssl Decrypting the Message</a></li><li><a href="https://heroims.github.io/2019/01/06/OLLVM%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E7%A7%BB%E6%A4%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">OLLVM代码混淆移植与使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这只是一篇记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;又爱又恨的ijkplayer&quot;&gt;&lt;a href=&quot;#又爱又恨的ijkplayer&quot; class=&quot;headerlink&quot; title=&quot;又爱又恨的ijkplayer&quot;&gt;&lt;/a&gt;又爱
      
    
    </summary>
    
      <category term="Android" scheme="https://haohaozaici.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>拔智齿</title>
    <link href="https://haohaozaici.github.io/2019/06/30/%E6%8B%94%E6%99%BA%E9%BD%BF/"/>
    <id>https://haohaozaici.github.io/2019/06/30/拔智齿/</id>
    <published>2019-06-30T08:02:39.000Z</published>
    <updated>2019-06-30T08:03:07.964Z</updated>
    
    <content type="html"><![CDATA[<p>拔智齿</p><p>一、2019.6.28 几天前</p><p>马上又要去拔牙了，虽然上次拔牙过程很顺利，但心里还是有些忐忑。首先是拔一颗智齿花了接近1300，看到网上别人不到500心里会有些不平衡，不知道这次会花多少？一定要跟医生说选便宜的方式。其次多少还是有些痛苦的，刚打麻药时针刺的感觉，拔完牙吃饭的不便（第一天下午睡着了，口水夹杂着血水流了一枕头），不过医生姐姐的细心、温柔、专业把这些不快都冲淡了。日子一天天临近，想着28号早上还得早起，心里兴奋又紧张，这次会遇到什么样的医生呢。</p><p>二、2019.6.28 前往医院</p><p>早上6:30，急忙收拾好资料，钱包，带上眼镜，昨天晚上不小心放在外套口袋里被扔进洗衣机的耳机是指望不上了。6月的北京，天早已大亮，出了公寓门口，湿润的地面暗示今天可能又会比较闷热，街道上已经有不少人在疾行，今天是周五，城市在忙碌的运转着。掏出手机，在地图里确认了已经走过一遍的路线。每一次坐地铁我都会想起P5，里面每天都会出现的地铁场景让游戏突然变得很真实，贴近生活，好像小时候上学基本靠走路一样。</p><p>走出地铁站门口就是天坛公园，还需要穿过一段小巷才能到医院，上次走路的体验很不错，路面干净，比较窄只能过一辆车，行人不多不少。路过小卖铺，老板娘给我的映像特别深，店铺大概4平米，第一次进店我说话声音很大，阿姨的却回复非常温柔，轻声细语，让我有一种粗鲁的羞愧感，这一次我没有再犯错误，声音几乎是最轻了^_^。买完了水，离预约时间8:00很近了，我加快了脚步。距离上次拔牙只过了一个月，附近的建筑没有太大的变化，我的注意力转向了路上与我同行的人，几乎都是女生，大多数职业女性的装扮，我提着印着医院名称的塑料袋，是去医院看病的，她们呢？很快我就知道了答案。快到医院了，我的方向是从医院后方走到门口，她们在中间的位置就折向了后门，她们是医生，开始上班工作了，一路的同行突然让我有了一种参与感，就像平日里早晨同事们一起上楼一样。</p><p>轻车熟路，取号的时候错把武汉的社保卡插入机器，一直报错，不知道是头晕了，还是眼花了。爬楼梯到五楼7:40刚好，医生还没上班，只有窗口有一位医生，8点才开始分诊，楼道里坐着的人已经不少了，陆续还有人坐电梯上来，然后医生姐姐不停的被问：啥时候开始？挂号完了要咋办？我当然也参与了其中haha，现在真的开始理解她们的不耐烦了…</p><p>三、拔牙</p><p>8:00登记完就要开始等待了，我被分在了第一诊室（上次是第二诊室），这一层全都是拔牙的，病人陆续被分往各个诊室，每个诊室大概6个工位。来往的人，医生的呼喊，忙碌的护士，楼道比较窄，我靠在墙边上，开始观察旁边的人。大多数拔牙的都是年轻人，女生拔牙的基本都有人陪着，大多是带妈妈一起来的，有带男朋友的，还有跟爸爸一起的。我旁边的女生明显是一个人来的，小小的个子，跟数学老师豆豆有点像，好想问她是不是一个人来的，然后她很快就被叫进去了…有一对大概60多岁的爷爷奶奶，女的涂着精致的妆，男的成熟帅气，颇有些英雄迟暮的感觉，不经开始幻想他们年轻时的模样。大家都在门口等待着，有的焦躁，有的紧张。还有些年纪很大的人来拔牙，医生说是要连心电设备才能做，这个科室做不了。</p><p>终于叫到我了，医生姐姐拿着曲面断层片跟我说了一堆风险啥的，我基本没听进去，只能不停的点头，估计看我脸色不好，最后安慰我说一般几个月都会好的，然后就找老师去了。她的老师是个老师傅，身材高大，眉毛有点白了，亲切幽默的东北口音。我跟着过去，听到应该要做微创，先割开牙龈，磨一部分，再取出来，这部分手术费比较高，还没问能不能选便宜点的方案，直接被领着躺椅子上了，赶紧提了一句。医生开始准备麻药，不太熟练的用脚掌操作椅子的高度，检查，注射，因为手法有些不熟练，调整了几次，注射时有些胀通，慢慢开始失去知觉，开始准备第二针，金属的针筒，旋转固定有点像电影里的场景，这时老师路过提醒要在靠近骨头的地方注射，要不然不一定麻，我分不清肾上腺素和麻药的顺序。注射完毕，老师过来了，麻溜的升高椅子，让学生辅助，吸收口水和血水，磨牙时喷水，老师力量特别大，下面的智齿用了几次力都没出来，“怎么这么不愿意出来”，说话的语气很幽默，磨了几下很快就拔出来了，我也跟着笑了起来，上面的智齿长得比较整齐，感觉几秒钟就完事了，剩下就是冲洗和缝针，老师提醒学生注意拿刀的姿势，不能对着患者，老师用刀绕线的姿势感觉像武林高手，学生认真又带点笨拙的节奏我觉得特别可爱。</p><p>清理的时候，老师去拿缝线，我没忍住笑意，口胡着对学生说：“感觉你比我还紧张~”，医生姐姐顿时笑了起来，她带着口罩，我只能看到她的眼角。</p><p>结束了，缴费787，自费40，其他都是自付一，拿上冰袋在诊室门口等待，有个带女儿来的阿姨想让位置给我，我面带笑容急忙摇头拒绝了，看着不断进出的人们，感觉心里好温暖。也不是所有人拔完牙都面带笑容，有个女生从来的时候，到拔完牙一直都是闷闷不乐，我看着特别想笑。拿完假条，看着医生又开始下一轮注射麻药，我得离开了。到了时间点，吐了棉球，走在回家的路上，心里有些失落。</p><p>四、美好的情感</p><p>回家的路上我为什么会感到失落，一天的经历下来，我突然感到自己离美好的人，美好的事在越来越远，痛苦趁虚而入，占据了我的脑海。我开始觉得人的一生都在受苦，拔牙是身体上的痛苦，追求美好的事物是求之不得苦。麻药消退后不断加剧的疼痛，让我更加难以保持清醒。</p><p>我在大镖客2里找到一份慰藉，周末有了拔牙的借口，可以认真的玩玩游戏了，之前没认真了解过大镖客2，简单玩过只知道节奏很慢，这一次重新开始玩我总是害怕错过一些内容，我开始变的急躁，不断寻找攻略、秘籍，可它告诉我，不要着急，不要着急，慢慢来，不要害怕错过，这个世界很精彩，有无数种可能。</p><p>痛苦的经历不值得感到沮丧，而是变为故事，就像现在这样可以被简单的记录下来，美好的事物在这片土地孕育，我爱上了在北京的这段时光。</p><p>2019.6.30 北京 公寓</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;拔智齿&lt;/p&gt;
&lt;p&gt;一、2019.6.28 几天前&lt;/p&gt;
&lt;p&gt;马上又要去拔牙了，虽然上次拔牙过程很顺利，但心里还是有些忐忑。首先是拔一颗智齿花了接近1300，看到网上别人不到500心里会有些不平衡，不知道这次会花多少？一定要跟医生说选便宜的方式。其次多少还是有些痛苦的
      
    
    </summary>
    
      <category term="生活" scheme="https://haohaozaici.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="情感" scheme="https://haohaozaici.github.io/categories/%E7%94%9F%E6%B4%BB/%E6%83%85%E6%84%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>白蛇 缘起</title>
    <link href="https://haohaozaici.github.io/2019/01/26/%E7%99%BD%E8%9B%87%20%E7%BC%98%E8%B5%B7/"/>
    <id>https://haohaozaici.github.io/2019/01/26/白蛇 缘起/</id>
    <published>2019-01-26T11:40:11.000Z</published>
    <updated>2019-04-15T10:13:45.356Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>画面8分<br>比较精致的电影，制作优良，画面细节不错，衣服、头发的纹理真实，唯美的场景。类似修仙小说里的招魂幡让人眼前一亮，还有不少比较性感的场景，表现不错haha。<br>总结：部分场景非常好，但几个比较大的场景和总体的细节一般，所以略有遗憾，但唯美的画风加分不少。</p></li><li><p>剧情6分<br>剧情节奏比较紧凑，把俗套的故事演绎的不错，但实在没啥亮点。</p></li><li><p>音乐7分<br>整体的音效及格，几个重要的旋律还不错，还有个幽默的小插曲，但是除此之外，没有突出的bgm，考虑到情怀还是加一分。</p></li><li><p>人物7分<br>把大家如此熟悉的人物，演绎出了许宣-白蛇恋、白蛇-小青恋、单身狗，让不同的人都能找到自己的定位，haha，导演有点坏，不过也因此加分不少。</p></li></ul><p>这一次是和小东一起看的。。别人都是成双成对，难受哦。。不过<strong>是一部值得以后再翻出来看的电影</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;画面8分&lt;br&gt;比较精致的电影，制作优良，画面细节不错，衣服、头发的纹理真实，唯美的场景。类似修仙小说里的招魂幡让人眼前一亮，还有不少比较性感的场景，表现不错haha。&lt;br&gt;总结：部分场景非常好，但几个比较大的场景和总体的细节一般，所以略有遗憾，但唯美的
      
    
    </summary>
    
      <category term="生活" scheme="https://haohaozaici.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="电影" scheme="https://haohaozaici.github.io/categories/%E7%94%9F%E6%B4%BB/%E7%94%B5%E5%BD%B1/"/>
    
    
  </entry>
  
  <entry>
    <title>鸣鸣小喵日记</title>
    <link href="https://haohaozaici.github.io/2018/12/13/%E9%B8%A3%E9%B8%A3%E5%B0%8F%E5%96%B5%E6%97%A5%E8%AE%B0/"/>
    <id>https://haohaozaici.github.io/2018/12/13/鸣鸣小喵日记/</id>
    <published>2018-12-13T11:34:38.000Z</published>
    <updated>2019-04-15T10:13:37.649Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/a328671cly1fy5cnfosabj20qo0k0jsx.jpg" alt="img"></p><p><br></p><p>上了一上午的课，鸣鸣非常疲惫，回到寝室看着干净、温暖的床铺，迫不及待要把自己狠狠地摔在柔软的床垫上，贪婪的呼吸因为刚刚晒过而散发清香的被子，然而，这令人心动到心脏砰砰直跳的幻想被身上几天没洗的衣服拉回了现实。</p><p>“唉，还是先吃饭吧。” </p><p>说完鸣鸣放下手中从没翻开的课本，不怀好意的告诉斜对面的张越今天老师又点名了。</p><p>“呵呵呵！”</p><p>突然，旁边传来一阵机智的笑声打断了鸣鸣的表演，原来他用了无数次的小把戏早已被人识破。</p><p>“其实没点名，啊哈哈哈”</p><p>匆忙解释了一句，鸣鸣赶紧用哈哈大笑来「自鸣得意」，大家也跟着笑了起来，空气中顿时充满了皮气。</p><p>…</p><p>鸣鸣摸了摸吃撑的肚子，因为大脑供血不足开始有些头晕眼花，想着下午还要上课愈加的烦躁，扭过头，鸣鸣贪婪的看了一眼整洁的床，又看了一眼正在战斗的小东，心里下定决心再不能让他们在自己的床上胡作飞为了。</p><p>双手趴在冰冷、坚硬、粗糙的书桌上，不时调整姿势缓解手臂的僵硬，天气渐渐转凉了，鸣鸣身上竟然只简单套了件蓝色卫衣，就睡的死气沉沉了，真让大家为他担心啊。</p><p>书桌下方的抽屉里，几只老鼠的幼崽正在瑟瑟发抖，好像在抱怨今年的寒冬来的太早了些，唉，小傻瓜们，他们可比趴在桌上睡觉的鸣鸣幸福多了啊。</p><p>没过多久，常来215做客的中华田园喵跳上了那个干净的床铺。呵，柔软、温暖的被窝，让小猫都慵懒起来，张开了时刻防备着的喵爪，撑开了四肢，伸了个大大的懒腰。为他们抓了这么久的老鼠，也该休息一下了吧~想着想着就这样小喵也和鸣鸣一起进入了梦乡。</p><p>…</p><p>“啊！！！”，“喵呜~~~”</p><p>到底发生了什么？！突然传来一阵仿佛要撕裂世界的怒吼！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/a328671cly1fy5cnfosabj20qo0k0jsx.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;上了一上午的课，鸣鸣非常疲惫，回到寝室看着干净、温暖的床铺，
      
    
    </summary>
    
      <category term="生活" scheme="https://haohaozaici.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>ConstraintLayout「最全总结」</title>
    <link href="https://haohaozaici.github.io/2018/07/11/ConstraintLayout/"/>
    <id>https://haohaozaici.github.io/2018/07/11/ConstraintLayout/</id>
    <published>2018-07-11T06:14:50.000Z</published>
    <updated>2018-07-12T03:25:31.879Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>现在大家几乎都使用过ConstraintLayout，但与经常使用的布局相比，可能会面临不熟悉CL的API或者是逐渐增加的新特性，还有可能因为对CL具体行为的理解模糊而导致误用，这篇文章的目的更多的是，<strong>全面总结ConstraintLayout的用法和实际行为特性，并不断更新</strong></p></blockquote><p>基于ConstraintLayout 1.1，当前2.0版本处于测试阶段<br>参考文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI1NjEwMTM4OA==&amp;mid=2651232651&amp;idx=1&amp;sn=9ea7beb5c280cd05d192cd3df072a745&amp;chksm=f1d9e4e8c6ae6dfe3aafc910cfd2785249d777a998521047127c5beac2c4657bdd7b6c2a43ac&amp;mpshare=1&amp;scene=23&amp;srcid=0608A4Q2cmC8SaMeykxP1klT%23rd" target="_blank" rel="noopener">ConstraintLayout入门指南</a></p><h2 id="为什么要引入ConstraintLayout"><a href="#为什么要引入ConstraintLayout" class="headerlink" title="为什么要引入ConstraintLayout"></a>为什么要引入ConstraintLayout</h2><ul><li><strong>减少布局层级</strong>：常用的布局划分成了几个不同的类型，要组合不同的功能需要通过嵌套的形式实现，比如想要按比例布局就要使用layout_weight属性，想要使用layout_weight属性就要使用LinearLayout（以下简称LL）或者TableLayout，然后你在原先同级的每个布局外再嵌套一层布局以使用layout_weight。</li><li><strong>更多的布局需求</strong>：要实现固定宽高比、百分比布局，灵活控制大小等更高阶的布局需求，原先的各类布局方式都不能很好的支持，可能需要通过Java代码，在运行中二次实现。</li><li>想要通过ConstraintLayout来 <strong>优化性能</strong>，<del>可能并不明显</del></li><li>亦或者你只是想尝试下这款Andorid官方力推的新布局，看看它有什么新特性。</li></ul><p>引入lib:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//确保SDK Tools中已经下载了ConstraintLayout的支持库：</span></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">'com.android.support.constraint:constraint-layout:1.1.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>开始之前，我们应该意识到在布局文件中Layout主要职责是什么，<strong>控制widgets的位置和大小</strong>。下面将从这两个方向出发，看看ConstraintLayout是怎么做的。</p><h2 id="1-控制位置"><a href="#1-控制位置" class="headerlink" title="1. 控制位置"></a>1. 控制位置</h2><p>layout中的view都有四个方向<code>left(start), right(end), top, bottom</code>，通过这些方向在两个view之间建立约束来实现基础的位置控制，相对于RelativeLayout，RL中所有的属性CL中都有与之对应的项目，稍加熟悉即可完成转换：</p><p><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbyw9rj212c0z4af4.jpg" alt="cl - rl"></p><p>相对于父布局的相对布局属性，CL的规则是：将父布局当做一个id=”parent”的对象来对待：</p><p><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nc04bdj213o16wwle.jpg" alt="cl parent - rl parent"></p><h3 id="1-1-Margins"><a href="#1-1-Margins" class="headerlink" title="1.1 Margins"></a>1.1 Margins</h3><p>设置普通的margin：<br><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbrn7yj20fy0dot9q.jpg" width="320" alt="margin"></p><h3 id="1-2-visibility-对约束的影响"><a href="#1-2-visibility-对约束的影响" class="headerlink" title="1.2 visibility 对约束的影响"></a>1.2 visibility 对约束的影响</h3><p>特殊的情况是：<strong>连接到visibility为GONE的view时的margin</strong>，在ConstraintLayout中，当widgets被设置<strong>View.GONE</strong>时进行了特殊处理。</p><ul><li>根据布局的传递，设置为GONE的view相当于大小被设置为0(实际上是被设置成了一个点)</li><li>如果他们已经跟其他的组件产生了约束关系，约束关系还是会存在，但是所有的margin都会变成0<br><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbvh3uj20pa0dygml.jpg" alt="Visibility Behavior"></li><li>也可以使用goneMargin来<strong>保持预期的边距</strong><!-- ![margin gone](https://ws1.sinaimg.cn/large/a328671cly1ft63nbnva9j20ee0dagmk.jpg) --><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbnva9j20ee0dagmk.jpg" width="320" alt="margin gone"></li></ul><p>这种特殊的处理，可以在你临时的把view设置为GONE时，不破坏布局结构。</p><h3 id="1-3-居中和偏移"><a href="#1-3-居中和偏移" class="headerlink" title="1.3 居中和偏移"></a>1.3 居中和偏移</h3><p>居中的设置参考之前于RelativeLayout的对应关系，CL增加了偏移属性，使用偏移可以更好的处理屏幕大小改变时的情景。<br><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbngqij20nm08gdgc.jpg" alt="center"><br><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbnttlj21340cot9z.jpg" alt="bias"></p><p>布局中设置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.constraint.ConstraintLayout ...&gt;</span><br><span class="line">    &lt;Button android:id=<span class="string">"@+id/button"</span> ...</span><br><span class="line">        app:layout_constraintHorizontal_bias=<span class="string">"0.3"</span></span><br><span class="line">        app:layout_constraintLeft_toLeftOf=<span class="string">"parent"</span></span><br><span class="line">        app:layout_constraintRight_toRightOf=<span class="string">"parent/&gt;</span></span><br><span class="line"><span class="string">&lt;/&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="1-4-圆形的位置"><a href="#1-4-圆形的位置" class="headerlink" title="1.4 圆形的位置"></a>1.4 圆形的位置</h3><p><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbyao7j21600tyq7z.jpg" alt="circle"><br>使用圆形约束，在创建圆形的菜单时非常有用<br><img src="https://cdn-images-1.medium.com/max/1600/1*dkCMb35o4HN7SVX8S1N3ig.gif" alt="circle menu"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button android:id=<span class="string">"@+id/buttonA"</span> ... /&gt;</span><br><span class="line">&lt;Button android:id=<span class="string">"@+id/buttonB"</span> ...</span><br><span class="line">    app:layout_constraintCircle=<span class="string">"@+id/buttonA"</span></span><br><span class="line">    app:layout_constraintCircleRadius=<span class="string">"100dp"</span></span><br><span class="line">    app:layout_constraintCircleAngle=<span class="string">"45"</span> /&gt;</span><br></pre></td></tr></table></figure><h2 id="2-控制尺寸-大小"><a href="#2-控制尺寸-大小" class="headerlink" title="2. 控制尺寸(大小)"></a>2. 控制尺寸(大小)</h2><h3 id="2-1-给ConstraintLayout自己添加大小限制"><a href="#2-1-给ConstraintLayout自己添加大小限制" class="headerlink" title="2.1 给ConstraintLayout自己添加大小限制"></a>2.1 给ConstraintLayout自己添加大小限制</h3><p>当ConstraintLayout的大小设置为<strong>WRAP_CONTENT</strong>时，可以很方便的设置自己的最大宽高<br><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbvcurj20pw08sdh1.jpg" width="600" alt="max min"><br><!-- ![max min](https://ws1.sinaimg.cn/large/a328671cly1ft63nbvcurj20pw08sdh1.jpg) --></p><h3 id="2-2-Widgets的尺寸-大小-约束"><a href="#2-2-Widgets的尺寸-大小-约束" class="headerlink" title="2.2 Widgets的尺寸(大小)约束"></a>2.2 Widgets的尺寸(大小)约束</h3><p>和我们在常用的布局中设置宽高一样，控制Widgets的宽度和高度一共有3种方式：</p><ul><li><strong>固定的大小</strong>，如123dp</li><li><strong>WRAP_CONTENT</strong> 自适应</li><li><strong>0dp</strong>，等于<strong>MATCH_CONSTRAINT</strong>，类似于match_parent，会利用所有可用的空间。注意，不建议使用match_parent</li></ul><p><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbpx54j20oc0heta2.jpg" alt="dimension-constraints"></p><h3 id="2-3-WRAP-CONTENT-强制约束"><a href="#2-3-WRAP-CONTENT-强制约束" class="headerlink" title="2.3 WRAP_CONTENT 强制约束"></a>2.3 WRAP_CONTENT 强制约束</h3><p>默认情况下，设置为WRAP_CONTENT的组件不会限制他们的大小，有时会导致超出约束条件的情况，如果需要强制他们满足约束条件的话，使用下面的强制约束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constrainedWidth=&quot;true|false&quot;</span><br><span class="line">app:layout_constrainedHeight=&quot;true|false&quot;</span><br></pre></td></tr></table></figure></p><h3 id="2-4-MATCH-CONSTRAINT-大小控制"><a href="#2-4-MATCH-CONSTRAINT-大小控制" class="headerlink" title="2.4 MATCH_CONSTRAINT 大小控制"></a>2.4 MATCH_CONSTRAINT 大小控制</h3><p>默认情况下，MATCH_CONSTRAINT 会利用所有可用的空间，通过下面的设置，可以自定义具体的行为</p><ul><li><code>layout_constraintWidth_min</code> and <code>layout_constraintHeight_min</code></li><li><code>layout_constraintWidth_max</code> and <code>layout_constraintHeight_max</code></li><li><code>layout_constraintWidth_percent</code> and <code>layout_constraintHeight_percent</code></li><li>使用百分比大小时，对应方向的大小必须设置为 MATCH_CONSTRAINT</li></ul><h3 id="2-5-使用比例"><a href="#2-5-使用比例" class="headerlink" title="2.5 使用比例"></a>2.5 使用比例</h3><p>使用比例有两种情况，而且必须至少有一条边被设置为0dp：</p><ul><li>如果只有一条边被设置为0dp，设置比例时，将参考另外一条已经确定尺寸的边</li><li>如果两条边都被设置为0dp，那么会在满足比例的条件下，设置为最大尺寸</li><li>同样的支持直接设置<code>layout_constraintWidth_percent</code>和<code>layout_constraintHeight_percent</code>来使用百分比控制相对于parent的比例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">    android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_height=<span class="string">"0dp"</span></span><br><span class="line">    app:layout_constraintDimensionRatio=<span class="string">"1.6"</span> /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">    android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_height=<span class="string">"0dp"</span></span><br><span class="line">    app:layout_constraintDimensionRatio=<span class="string">"1:1"</span> /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">    android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">    android:layout_height=<span class="string">"0dp"</span></span><br><span class="line">    app:layout_constraintBottom_toBottomOf=<span class="string">"parent"</span></span><br><span class="line">    app:layout_constraintDimensionRatio=<span class="string">"H,16:9"</span></span><br><span class="line">    app:layout_constraintTop_toTopOf=<span class="string">"parent"</span> /&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-6-Chains"><a href="#2-6-Chains" class="headerlink" title="2.6 Chains"></a>2.6 Chains</h3><p>Chains能自定义在同一轴线上view的位置和大小，首先我们来创建一条链，当widgets之间在同一个方向上相互连接(相互约束)时，链就形成了。</p><p><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbnpdwj20nq094jry.jpg" alt="chain"></p><h4 id="2-6-1-链的head"><a href="#2-6-1-链的head" class="headerlink" title="2.6.1 链的head"></a>2.6.1 链的head</h4><p>水平方向chain最左边的控件和垂直方向chain最顶部的控件被成为<code>head chain</code>。通过对head chain添加<code>chainStyle</code>属性，可以设置该条chain在水平或垂直方向上的chainStyle</p><p><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbnl5yj20r407ggm6.jpg" alt="chain head"></p><h4 id="2-6-2-Chain-Style"><a href="#2-6-2-Chain-Style" class="headerlink" title="2.6.2 Chain Style"></a>2.6.2 Chain Style</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout_constraintHorizontal_chainStyle</span><br><span class="line">layout_constraintVertical_chainStyle</span><br></pre></td></tr></table></figure><p>chainStyle属性一共有三种：spread、spread_inside、packed。再配合其他属性，最终可以组成五种chain style：<br><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbwsmtj21360kgdjl.jpg" alt="chainStyle"></p><p>其他四种chain style的设置和效果都比较简单，重点介绍下<strong>Weighted Chain</strong>。</p><ul><li>默认的spread模式，每个元素获得同样的空间，如果一个元素使用了0dp，将会占用剩下的所有可用空间</li><li><code>layout_constraintHorizontal_weight</code>和<code>layout_constraintVertical_weight</code>可以用来控制同样设置为0dp的控件的比例</li><li>Weighted Chain中的控件也允许在chain方向上使用wrap_content自适应控件宽/高，且布局时<strong>优先满足设置为wrap_content的控件</strong>，相当于优先满足设置了指定宽高的控件</li><li>当设置了margin时，margin生效的同时weight的比例不变，链上的控件实际占有布局会被压缩</li></ul><h2 id="3-不可见的辅助工具"><a href="#3-不可见的辅助工具" class="headerlink" title="3. 不可见的辅助工具"></a>3. 不可见的辅助工具</h2><h3 id="Guideline"><a href="#Guideline" class="headerlink" title="Guideline"></a>Guideline</h3><h3 id="barrier"><a href="#barrier" class="headerlink" title="barrier"></a>barrier</h3><h3 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h3><h2 id="4-用代码的方式操作"><a href="#4-用代码的方式操作" class="headerlink" title="4. 用代码的方式操作"></a>4. 用代码的方式操作</h2><h3 id="ps-选择优化类型"><a href="#ps-选择优化类型" class="headerlink" title="ps. 选择优化类型"></a>ps. 选择优化类型</h3><p>Package Index:<br>android.support.constraint<br>android.support.constraint.helper<br>android.support.constraint.motion<br>android.support.constraint.utils</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;现在大家几乎都使用过ConstraintLayout，但与经常使用的布局相比，可能会面临不熟悉CL的API或者是逐渐增加的新特性，还有可能因为对CL具体行为的理解模糊而导致误用，这篇文章的目的更多的是，&lt;strong&gt;全面总结ConstraintL
      
    
    </summary>
    
      <category term="Android" scheme="https://haohaozaici.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>「播放器」Mac上编译ijkplayer so支持HTTPS</title>
    <link href="https://haohaozaici.github.io/2018/06/07/build-ijkplayer/"/>
    <id>https://haohaozaici.github.io/2018/06/07/build-ijkplayer/</id>
    <published>2018-06-07T08:02:19.000Z</published>
    <updated>2018-07-11T12:29:44.559Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>当项目中使用ijkplayer，而且还需要播放HTTPS链接的视频时，就比较蛋疼了 (￣.￣)，ijkplayer默认不支持HTTPS播放，但提供了编译OpenSSL的选项，可以自己编译so文件支持HTTPS播放。这篇文章的目的是<strong>引导不熟悉的人完成整个编译过程，提醒过程中的注意事项，还有各种选项的解释</strong>。</p></blockquote><h2 id="我的编译环境"><a href="#我的编译环境" class="headerlink" title="我的编译环境"></a>我的编译环境</h2><p>VMware + Ubuntu编译环境也可以参考，基本上只有命令不同，homebrew的安装这里不再赘述。非常不建议在Windows环境下编译！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mac 10.13.2</span><br><span class="line">iTerm2 + zsh</span><br><span class="line">HomeBrew</span><br><span class="line">NDK r10e</span><br><span class="line"></span><br><span class="line">NDK + 编译所有so大概需要10GB空间</span><br></pre></td></tr></table></figure></p><p>相关链接:</p><ul><li><a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="noopener">Bilibili/ijkplayer</a></li><li><a href="https://www.jianshu.com/p/bd289e25d272" target="_blank" rel="noopener">IJKPlayer编译so支持HTTPS的踩坑历程</a></li><li><a href="https://blog.csdn.net/coder_pig/article/details/79134625" target="_blank" rel="noopener">ijkplayer编译so库真没那么难</a></li></ul><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><h3 id="安装Git与yasm"><a href="#安装Git与yasm" class="headerlink" title="安装Git与yasm"></a>安装Git与yasm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br><span class="line">brew install yasm</span><br></pre></td></tr></table></figure><h3 id="配置SDK、NDK"><a href="#配置SDK、NDK" class="headerlink" title="配置SDK、NDK"></a>配置SDK、NDK</h3><p>SDK都会有，NDK一般没有下载，建议去官网下载:<a href="https://developer.android.google.cn/ndk/downloads/older_releases" target="_blank" rel="noopener">https://developer.android.google.cn/ndk/downloads/older_releases</a></p><p>需要注意的是最好下载官方lib使用的<strong>NDK r10e</strong>，使用其他版本的将无法编译。具体原因可以参考<a href="https://github.com/Bilibili/ijkplayer/issues/2752" target="_blank" rel="noopener">这篇issue</a></p><p>SDK、NDK和准备完成后，在<code>.bash_profile</code>, 或者是<code>.zshrc</code>中添加配置。(<code>Command + shift + .</code> 显示隐藏文件)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 注意替换为自己的文件路径</span><br><span class="line">export ANDROID_SDK=/Users/haoyuan/Library/Android/sdk</span><br><span class="line">export PATH=$ANDROID_SDK/platform-tools:$PATH</span><br><span class="line">export PATH=$ANDROID_SDK/tools:$PATH</span><br><span class="line">export ANDROID_NDK=/Users/haoyuan/Library/Android/android-ndk-r10e</span><br><span class="line">export PATH=$ANDROID_NDK:$PATH</span><br></pre></td></tr></table></figure><p>添加完成后，保存文件，然后<code>source .bash_profile</code>等相关文件，或者<strong>直接重启终端</strong>，通过 <code>ndk-build -v</code> 检查是否生效</p><p><img src="https://ww1.sinaimg.cn/large/a328671cly1fs2p78ggb9j20ug084dpy.jpg" alt="img"></p><h3 id="clone-ijkplayer源码"><a href="#clone-ijkplayer源码" class="headerlink" title="clone ijkplayer源码"></a>clone ijkplayer源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Bilibili/ijkplayer.git ijkplayer-android</span><br><span class="line">cd ijkplayer-android</span><br><span class="line">git checkout -B latest k0.8.8</span><br></pre></td></tr></table></figure><h2 id="2-编译之前"><a href="#2-编译之前" class="headerlink" title="2. 编译之前"></a>2. 编译之前</h2><h3 id="编译前选择你的配置"><a href="#编译前选择你的配置" class="headerlink" title="编译前选择你的配置"></a>编译前选择你的配置</h3><p>选择自动化编译时的一些配置选项，比如支持的协议，音视频类型等，官方给我们提供了三个模板。</p><p>可以打开config/目录下config/module.sh看看，enable启用，disable禁用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module-default.sh</span><br><span class="line">module-lite-hevc.sh</span><br><span class="line">module-lite.sh</span><br></pre></td></tr></table></figure></p><p><img src="https://ww1.sinaimg.cn/large/a328671cly1fs2p78eh8lj20yc0xqwir.jpg" alt="img"></p><p>官方默认建议选择的是 <code>module-lite.sh</code>，可以根据自己的需求选择<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd config</span><br><span class="line">rm module.sh</span><br><span class="line">ln -s module-lite.sh module.sh</span><br></pre></td></tr></table></figure></p><p>如果要选择<code>module-default.sh</code>的话，可能会编译失败，可以参考<a href="https://github.com/Bilibili/ijkplayer/issues/4043" target="_blank" rel="noopener">这篇issue</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">仔细阅读module-lite.h 原来在最下面有一行配置：</span><br><span class="line">export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --disable-linux-perf&quot;</span><br><span class="line">把这行复制到module-default.sh 的最后面就可以了</span><br></pre></td></tr></table></figure></p><p>在编译配置中可以增减需要的模块，选择需要支持的<strong>封装格式、编解码类型、协议</strong>能有效减小so库的体积。可以参考<a href="https://github.com/CarGuo/GSYVideoPlayer/blob/master/doc/DECODERS.md" target="_blank" rel="noopener">CarGuo/GSYVideoPlayer DECODERS.md</a></p><h2 id="3-开始编译ヽ-｀⌒´-ﾉ"><a href="#3-开始编译ヽ-｀⌒´-ﾉ" class="headerlink" title="3. 开始编译ヽ(｀⌒´)ﾉ"></a>3. 开始编译ヽ(｀⌒´)ﾉ</h2><h3 id="执行初始化"><a href="#执行初始化" class="headerlink" title="执行初始化"></a>执行初始化</h3><p>初始化会下载各种包，尽量选择在良好的网络环境下╮(￣▽￣)╭<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">./init-android.sh</span><br></pre></td></tr></table></figure></p><p>初始化OpenSSL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./init-android-openssl.sh</span><br></pre></td></tr></table></figure></p><h3 id="编译OpenSSL和FFmpeg"><a href="#编译OpenSSL和FFmpeg" class="headerlink" title="编译OpenSSL和FFmpeg"></a>编译OpenSSL和FFmpeg</h3><p>首先清除一波<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd android/contrib</span><br><span class="line">./compile-openssl.sh clean</span><br><span class="line">./compile-ffmpeg.sh clean</span><br></pre></td></tr></table></figure></p><p>编译OpenSSL：可以选择不同版本，全量编译耗时更长，但最好选择全量编译，编译完成后再根据需求选择要使用的包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./compile-openssl.sh all</span><br></pre></td></tr></table></figure></p><p>编译FFmpeg，同样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./compile-ffmpeg.sh all</span><br><span class="line"></span><br><span class="line">// 如果要选择特定的架构: ./compile-ffmpeg.sh armv7a | armv5</span><br></pre></td></tr></table></figure></p><p>最后编译ijkplayer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./compile-ijk.sh all</span><br></pre></td></tr></table></figure></p><p>经过漫长的等待终于完成了以上编译过程\（￣︶￣）/，在目录中生成了ijkplayer的工程<br><img src="https://ww1.sinaimg.cn/large/a328671cly1fs2p78dwkmj20hq09vac5.jpg" alt="IMG"></p><h2 id="4-导入项目"><a href="#4-导入项目" class="headerlink" title="4. 导入项目"></a>4. 导入项目</h2><p>原有的项目一般是这样配置的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;tv.danmaku.ijk.media:ijkplayer-java:&apos; + gradle.ijkplayer_java</span><br><span class="line">implementation &apos;tv.danmaku.ijk.media:ijkplayer-armv7a:&apos; + gradle.ijkplayer_java</span><br></pre></td></tr></table></figure></p><p>如果只需要修改so库的话，<strong>删除掉第二行对so库的引用，将自己编译好的so文件复制到项目的libs文件夹中</strong>。</p><p>别忘了在gradle中配置，要不然会报错找不到so库<br><img src="https://ww1.sinaimg.cn/large/a328671cly1fs2p78cr4dj209602vgll.jpg" alt="IMG"></p><p>还可以在release包中设置abi过滤<br><img src="https://ww1.sinaimg.cn/large/a328671cly1fs2p78dgn4j20l50cgwfu.jpg" alt="IMG"></p><p>最后大功告成啦\(^o^)/</p><p>尾巴…</p><p>如果项目中同时使用了HTTP和HTTPS的视频源的话，要注意如果视频源刚好是相同域名，会导致播放失败，这是由于dns缓存造成的，解决办法参考<a href="https://github.com/CarGuo/GSYVideoPlayer/issues/1175" target="_blank" rel="noopener">这篇issue</a><br>初始化<code>IjkMediaPlayer</code>时，设置清除<code>dns cache</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;dns_cache_clear&quot;, 1</span><br><span class="line"></span><br><span class="line">//还要注意开启相关支持的协议</span><br><span class="line">IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;protocol_whitelist&quot;, </span><br><span class="line">&quot;async,cache,crypto,file,http,https,ijkhttphook,ijkinject,</span><br><span class="line">ijklivehook,ijklongurl,ijksegment,ijktcphook,</span><br><span class="line">pipe,rtp,tcp,tls,udp,ijkurlhook,data&quot;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;当项目中使用ijkplayer，而且还需要播放HTTPS链接的视频时，就比较蛋疼了 (￣.￣)，ijkplayer默认不支持HTTPS播放，但提供了编译OpenSSL的选项，可以自己编译so文件支持HTTPS播放。这篇文章的目的是&lt;strong&gt;引
      
    
    </summary>
    
      <category term="Android" scheme="https://haohaozaici.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>「播放器」Android音频焦点</title>
    <link href="https://haohaozaici.github.io/2018/04/24/Android%20Sound%20overlap/"/>
    <id>https://haohaozaici.github.io/2018/04/24/Android Sound overlap/</id>
    <published>2018-04-24T11:22:02.000Z</published>
    <updated>2018-08-01T11:44:32.987Z</updated>
    
    <content type="html"><![CDATA[<p>音视频播放在手机日常使用中非常频繁，当我们听着音乐刷着微博时，看到有趣的视频点击开始播放，音乐自动暂停，退出视频时音乐又自动恢复了播放(如果没有自动恢复的话，比如QQ音乐就会提示是否设置中断后继续播放)。</p><p><img src="https://img.mukewang.com/5aded21b0001ab9210801920.png" width="240" alt="中断后继续播放"></p><p>这一系列流畅自然的操作不是理所应当的吗~当然如果处理不好的话就会出现声音重叠，音频焦点长期被占用的问题，下面我们来看看具体的功能逻辑。</p><p>音频焦点相关的讲解参考以下文章</p><blockquote><p><a href="https://www.jianshu.com/p/5d8d7b677690" target="_blank" rel="noopener">Android音频焦点详解</a><br><a href="https://developer.android.com/guide/topics/media-apps/audio-focus.html" target="_blank" rel="noopener">Managing Audio Focus</a></p></blockquote><h2 id="Managing-Audio-Focus"><a href="#Managing-Audio-Focus" class="headerlink" title="Managing Audio Focus"></a>Managing Audio Focus</h2><p>不同的APP可以同时播放音频，系统会将他们混合在一起，但为了避免同时播放，Android提供了<strong>audio focus</strong>机制来合理使用音频播放资源。同一时间只能有一个APP获取音频焦点，当需要播放音频时，应该立即请求音频焦点，同样的，在你的APP获取到音频焦点后，其他APP也可以抢占音频焦点，这时你的APP就需要暂停播放或降低声音。音频焦点是合作类型的，APP拥有完全自主的控制权，系统无法阻止，但应用应该遵守音频焦点的指导规则。</p><p>好的音频APP在播放时应该遵守以下规则：</p><ul><li>开始播放后立即调用<code>requestAudioFocus()</code>方法，并验证返回值为<code>AUDIOFOCUS_REQUEST_GRANTED</code></li><li>当其他app占用音频焦点时，暂停或停止播放，或者降低声音</li><li>当播放停止时，放弃音频焦点</li></ul><p>在不同的Android版本下，需要使用不同的方法来处理音频焦点：</p><ul><li><em>API level 8</em>以后，使用<code>requestAudioFocus()</code>和<code>abandonAudioFocus()</code>方法，并注册<code>AudioManager.OnAudioFocusChangeListener</code>接收回调。</li><li><em>API level 21</em>以后，需要使用<code>AudioAttributes</code>来描述播放音频的类型。</li><li><p><em>API level 26</em>以后，需要使用<code>AudioFocusRequest</code>参数，它携带了音频的context和相关功能，系统会根据这些自动管理音频焦点。</p><h3 id="Android8-0以前"><a href="#Android8-0以前" class="headerlink" title="Android8.0以前"></a>Android8.0以前</h3><p>参考官方文档获取焦点的方法如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Request audio focus for playback</span></span><br><span class="line"><span class="keyword">int</span> result = am.requestAudioFocus(afChangeListener,</span><br><span class="line">        <span class="comment">// Use the music stream.</span></span><br><span class="line">        AudioManager.STREAM_MUSIC,</span><br><span class="line">        <span class="comment">// Request permanent focus.</span></span><br><span class="line">        AudioManager.AUDIOFOCUS_GAIN);</span><br></pre></td></tr></table></figure><p>但在听音乐的时候播放音频或视频，依旧出现了重叠的声音，实际上有效的做法是这样的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面两个常量参数试过很多 都无效，最终反编译了其他app才搞定，汗~  </span></span><br><span class="line"><span class="keyword">int</span> requestFocusResult = mAudioManager.requestAudioFocus(</span><br><span class="line">        mAudioFocusChangeListener,</span><br><span class="line">        AudioManager.STREAM_MUSIC,</span><br><span class="line">        AudioManager.AUDIOFOCUS_GAIN_TRANSIENT);</span><br></pre></td></tr></table></figure></p><p>具体参考文章<a href="https://blog.csdn.net/SYIF88/article/details/68064866" target="_blank" rel="noopener">Android MediaPlayer音频焦点问题，抢占声道</a></p><p>最后在对应的播放状态下获取和释放音频焦点。</p><h3 id="Android8-0之后"><a href="#Android8-0之后" class="headerlink" title="Android8.0之后"></a>Android8.0之后</h3><p>和之前一样，Android8.0中也使用了<code>requestAudioFocus()</code>来请求音频焦点，不一样的是，使用<code>abandonAudioFocusRequest()</code>释放音频焦点，并且请求和释放都需要传入同一个<code>AudioFocusRequest</code>实例。使用<code>AudioFocusRequest.Builder</code>来创建，具体实现代码参考官方文档<a href="https://developer.android.com/guide/topics/media-apps/audio-focus.html#audio-focus-8-0" target="_blank" rel="noopener">Audio focus in Android 8.0 and later</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mAudioFocusRequest = <span class="keyword">new</span> AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN)</span><br><span class="line">        .setAudioAttributes(<span class="keyword">new</span> AudioAttributes.Builder()</span><br><span class="line">                .setUsage(AudioAttributes.USAGE_MEDIA)</span><br><span class="line">                .setContentType(AudioAttributes.CONTENT_TYPE_MOVIE)</span><br><span class="line">                .build())</span><br><span class="line">        .setAcceptsDelayedFocusGain(<span class="keyword">true</span>)</span><br><span class="line">        .setOnAudioFocusChangeListener(mAudioFocusChangeListener)</span><br><span class="line">        .build();</span><br><span class="line"><span class="comment">//请求音频焦点      </span></span><br><span class="line">requestFocusResult = mAudioManager.requestAudioFocus(mAudioFocusRequest);</span><br><span class="line"><span class="comment">//释放音频焦点</span></span><br><span class="line">abandonFocusResult = mAudioManager.abandonAudioFocusRequest(mAudioFocusRequest);</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>Android8.0中其他APP使用<code>AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK</code>参数获取焦点时，将不会回调本APP的<code>onAudioFocusChange()</code>方法。</li><li>焦点延迟获取，当焦点被其他APP<strong>“锁”</strong>住时，<code>requestAudioFocus()</code>会返回<code>AUDIOFOCUS_REQUEST_FAILED</code>，比如正在打电话时，焦点就会被锁住。如果使用了<code>setAcceptsDelayedFocusGain(true)</code>方法，请求将会返回<code>AUDIOFOCUS_REQUEST_DELAYED</code>，在锁解除后，系统会继续处理未完成的焦点请求，并回调<code>onAudioFocusChange()</code>方法。</li></ul><h2 id="处理音频焦点变化"><a href="#处理音频焦点变化" class="headerlink" title="处理音频焦点变化"></a>处理音频焦点变化</h2><p>了解相应的请求、释放方法后，还需要进一步处理音频焦点变化问题，也就是优化跟其他APP或者是系统APP合作的过程。主要是处理<code>onAudioFocusChange</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AudioManager.OnAudioFocusChangeListener mAudioFocusChange = <span class="keyword">new</span> AudioManager.OnAudioFocusChangeListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAudioFocusChange</span><span class="params">(<span class="keyword">int</span> focusChange)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (focusChange)&#123;</span><br><span class="line">                <span class="keyword">case</span> AudioManager.AUDIOFOCUS_GAIN:</span><br><span class="line">                    <span class="comment">//当其他应用申请焦点之后又释放焦点会触发此回调</span></span><br><span class="line">                    <span class="comment">//可重新播放音乐</span></span><br><span class="line">                    Log.d(TAG, <span class="string">"AUDIOFOCUS_GAIN"</span>);</span><br><span class="line">                    start();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS:</span><br><span class="line">                    <span class="comment">//长时间丢失焦点,当其他应用申请的焦点为AUDIOFOCUS_GAIN时，</span></span><br><span class="line">                    <span class="comment">//会触发此回调事件，例如播放QQ音乐，网易云音乐等</span></span><br><span class="line">                    <span class="comment">//通常需要暂停音乐播放，若没有暂停播放就会出现和其他音乐同时输出声音</span></span><br><span class="line">                    Log.d(TAG, <span class="string">"AUDIOFOCUS_LOSS"</span>);</span><br><span class="line">                    stop();</span><br><span class="line">                    <span class="comment">//释放焦点，该方法可根据需要来决定是否调用</span></span><br><span class="line">                    <span class="comment">//若焦点释放掉之后，将不会再自动获得</span></span><br><span class="line">                    mAudioManager.abandonAudioFocus(mAudioFocusChange);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:</span><br><span class="line">                    <span class="comment">//短暂性丢失焦点，当其他应用申请AUDIOFOCUS_GAIN_TRANSIENT或AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE时，</span></span><br><span class="line">                    <span class="comment">//会触发此回调事件，例如播放短视频，拨打电话等。</span></span><br><span class="line">                    <span class="comment">//通常需要暂停音乐播放</span></span><br><span class="line">                    stop();</span><br><span class="line">                    Log.d(TAG, <span class="string">"AUDIOFOCUS_LOSS_TRANSIENT"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:</span><br><span class="line">                    <span class="comment">//短暂性丢失焦点并作降音处理</span></span><br><span class="line">                    Log.d(TAG, <span class="string">"AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>音频相关的API常常让人疑惑，明明已经根据注释的描述和官方文档中的方法实现了，却达不到预期的效果。还有就是随着Android更新的推送速度越来越快，更新普及率也水涨船高，高版本API随时在发生变化，适配时需要注意这些细节，以及进行完善的测试。</p><p>工具类参见<a href="https://gist.github.com/haohaozaici/baaa022e6ea5f61f37112135fe1cac07" target="_blank" rel="noopener">AudioFocusManager</a></p><h4 id="未完成内容"><a href="#未完成内容" class="headerlink" title="未完成内容"></a>未完成内容</h4><p>源码简单分析</p><p>在不同机型中进行测试</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;音视频播放在手机日常使用中非常频繁，当我们听着音乐刷着微博时，看到有趣的视频点击开始播放，音乐自动暂停，退出视频时音乐又自动恢复了播放(如果没有自动恢复的话，比如QQ音乐就会提示是否设置中断后继续播放)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.mukew
      
    
    </summary>
    
      <category term="Android" scheme="https://haohaozaici.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>创建和销毁对象</title>
    <link href="https://haohaozaici.github.io/2017/12/19/create-and-destroy-objects/"/>
    <id>https://haohaozaici.github.io/2017/12/19/create-and-destroy-objects/</id>
    <published>2017-12-19T07:12:41.000Z</published>
    <updated>2017-12-29T15:17:35.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h2><h3 id="静态工厂方法代替构造器"><a href="#静态工厂方法代替构造器" class="headerlink" title="静态工厂方法代替构造器"></a>静态工厂方法代替构造器</h3><p>静态工厂方法与设计模式中的<code>工厂方法</code>不同。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li>静态工厂方法有名称，</li></ol><h3 id="遇到多个构造器参数时，使用构建器-Builder模式"><a href="#遇到多个构造器参数时，使用构建器-Builder模式" class="headerlink" title="遇到多个构造器参数时，使用构建器-Builder模式"></a>遇到多个构造器参数时，使用构建器-Builder模式</h3><h4 id="1-使用构造方法创建对象"><a href="#1-使用构造方法创建对象" class="headerlink" title="1.使用构造方法创建对象"></a>1.使用构造方法创建对象</h4><p>重叠构造器</p><h4 id="2-JavaBeans模式"><a href="#2-JavaBeans模式" class="headerlink" title="2.JavaBeans模式"></a>2.JavaBeans模式</h4><p>通过setter方法设置必要参数，拥有良好的可读性。<br><em>缺点</em>：构造过程中容易被改变，处于不一致的状态。</p><h4 id="3-Builder模式"><a href="#3-Builder模式" class="headerlink" title="3.Builder模式"></a>3.Builder模式</h4><p>通过公开的Builder内部类，私有的构造方法，构造必传参数和可选参数。Builder模式模拟了具名的可选参数，可以加强约束条件，在对象域中进行检验。可以在编译时进行异常检查。 </p><p><em>缺点</em>：特殊情况下额外的性能开销，冗长。<br><em>适用情况</em>：多个参数(大于4个)，需要比JavaBeans模式更加安全的情况。</p><p>参见 <code>Notification</code> 或 <code>Alertdialog</code>类。</p><h3 id="用私有构造器或者枚举类型强化singleton属性"><a href="#用私有构造器或者枚举类型强化singleton属性" class="headerlink" title="用私有构造器或者枚举类型强化singleton属性"></a>用私有构造器或者枚举类型强化singleton属性</h3><p>为了防止反射调用私有构造方法、反序列化时创建新的实例，直接使用 <code>包含单个元素的枚举类型</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Elvis&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h3><p>39条 应该创建新对象时，不要重用现有对象<br>创建不必要的对象只会影响程序的风格和性能，没有实施保护性拷贝将会导致潜在的错误和安全漏洞。</p><h3 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h3><p><code>内存泄露</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建和销毁对象&quot;&gt;&lt;a href=&quot;#创建和销毁对象&quot; class=&quot;headerlink&quot; title=&quot;创建和销毁对象&quot;&gt;&lt;/a&gt;创建和销毁对象&lt;/h2&gt;&lt;h3 id=&quot;静态工厂方法代替构造器&quot;&gt;&lt;a href=&quot;#静态工厂方法代替构造器&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Java" scheme="https://haohaozaici.github.io/categories/Java/"/>
    
      <category term="Effective Java" scheme="https://haohaozaici.github.io/categories/Java/Effective-Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Mifare 1k S50卡</title>
    <link href="https://haohaozaici.github.io/2017/12/13/M1%20card/"/>
    <id>https://haohaozaici.github.io/2017/12/13/M1 card/</id>
    <published>2017-12-13T08:41:43.000Z</published>
    <updated>2018-04-20T02:05:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>背景：最近的项目中涉及到读写M1卡，之前完全没接触过一脸懵逼，却没意识到，生活中常用的公交卡、门禁卡、开水卡、会员卡等等大多数都是M1类的射频卡，如Mifare 1k S50系列。熟悉了相关知识后，发现原理如此简单，感谢开源也因此能做很多方便的事情了。记录一下，面对陌生的事物不要害怕，了解熟悉，探索乐趣。</p></blockquote><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="M1卡"><a href="#M1卡" class="headerlink" title="M1卡"></a>M1卡</h3><p>M1卡结构</p><div style="align: center"><img src="/img/m1card.webp" alt="M1卡结构"> </div><p>从上面可以看到，<code>扇区0 块0</code>固化了厂家代码，32位16进制数，一般作为<code>ID</code>使用。</p><p>每一个扇区的块3用于保存<code>KEY A,存取控制,KEY B</code>，除了扇区0的块0之外的其他的<code>块0~块2</code>都用于存储数据。<code>KEY A</code>不可读、可写，<code>KEY B</code>可读可写.</p><p>一般的门禁卡中，不存储任何数据，门禁系统只读取卡ID，学校里使用的开水卡，一般是离线使用，卡的余额或者使用次数是存储在卡中的，使用时进行读写。在武汉通中，存储了卡余额，储值、消费记录，具体的余额存储在服务器上。所以理论上可以模拟卡ID来模拟门禁卡，或者是读取修改水卡值来修改卡。</p><p>读写卡工具<a href="https://play.google.com/store/apps/details?id=de.syss.MifareClassicTool" target="_blank" rel="noopener">MIFARE Classic Tool</a>, <a href="https://github.com/ikarus23/MifareClassicTool" target="_blank" rel="noopener">MifareClassicTool - GitHub</a></p><p>模拟卡工具<a href="https://play.google.com/store/apps/details?id=com.yuanwofei.cardemulator" target="_blank" rel="noopener">NFC卡模拟</a></p><h4 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h4><p><a href="https://www.null17.com/blog/coding/NFC/20151019-nfc-mod/" target="_blank" rel="noopener">Mifare 1k S50 卡的简单探讨与破解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;背景：最近的项目中涉及到读写M1卡，之前完全没接触过一脸懵逼，却没意识到，生活中常用的公交卡、门禁卡、开水卡、会员卡等等大多数都是M1类的射频卡，如Mifare 1k S50系列。熟悉了相关知识后，发现原理如此简单，感谢开源也因此能做很多方便的事情
      
    
    </summary>
    
      <category term="生活" scheme="https://haohaozaici.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="乱七八糟的技巧" scheme="https://haohaozaici.github.io/categories/%E7%94%9F%E6%B4%BB/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
</feed>
