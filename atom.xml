<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浩浩的被窝</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://haohaozaici.github.io/"/>
  <updated>2018-05-12T07:56:45.571Z</updated>
  <id>https://haohaozaici.github.io/</id>
  
  <author>
    <name>haohaozaici</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018求职的痛苦经历</title>
    <link href="https://haohaozaici.github.io/2018/05/12/2018%E6%B1%82%E8%81%8C%E7%9A%84%E7%97%9B%E8%8B%A6%E7%BB%8F%E5%8E%86/"/>
    <id>https://haohaozaici.github.io/2018/05/12/2018求职的痛苦经历/</id>
    <published>2018-05-12T07:40:01.000Z</published>
    <updated>2018-05-12T07:56:45.571Z</updated>
    
    <content type="html"><![CDATA[<p>来北京快一个月了，刚开始每个周末都很忙，找房子、体检、回家、公司出游，没想到今天（2018-05-12）居然是第一天闲下来回忆、思考、记录的时候。</p><p>刚到北京，因为对于未知的城市心怀忐忑，所以提前做了些功课，住房上几乎没带来任何困扰，加上地图软件，出行也很顺利。似乎一切都很顺利，刚到第一天就确定了工作，在小东的陪伴下，一起游玩了颐和园，遇到了活历史老爷爷（现在很后悔当时不够亲切和尊敬），正常上班，不错的工作环境，有发展前景的互联网工作内容，北京这座陌生的城市给我带来了无限的新鲜感。</p><p>但是，我的心理却一直充满了焦虑、担忧、不自信，好像这一切都会很容易失去，这导致我直到现在内心都无法完全安定下来。今天主要想说说从离职以来的心路历程，之前已经写过一次了，主要是叙事，主观思想和情绪很重，不幸因为刷机没备份，丢失了。这一次，将从内心出发，还原心路历程，好的坏的想法，尽量还原。</p><p>事情从在利楚林总找我谈话开始，快年末了，我还在每天机械的维护POS项目，那天晚上下班后在公司学习，林总找我聊天，当时我毫无准备，也没有认真思考过将来的计划与发展。他说了很多很多他的经历、想法，我感受到了真诚，也因此对他充满了尊敬和理解，我非常喜欢他，带我们聚餐、旅游、运动，没有架子，对技术很重视，没有办公室政治，唯一的缺点就是他为工作几乎付出了所有精力，所以后端的加班情况非常恐怖，这也是我离职的主要原因。我提出了想做全栈的想法（程序员应该都想吧），因此开始接触了后端的任务，我心怀期待，但并没有喜欢的情绪，应该是视野有限，在利楚后端比移动端更受重视，所以也觉得后端比现在的好。很顺利，我模仿的很快，虽然各种工具用的不一样，他们的相对落后，但是很快能理解基础的逻辑，再加上对sql略微熟悉，所以数据库也能基本使用。一切在一天加班到深夜的晚上发生了变化，我等到了接近3点大家才一起下班，林总11点走了之后，办公室里开始充斥着抱怨，抱怨公司，抱怨现在的工作，我也在抱怨，好像很喜欢讨论这个话题，仿佛被洗脑了，感觉这样下去公司一刻也呆不了了。之后他们，似乎所有人都觉得我出去闯荡一下更好，我自己也把这句话挂在嘴边，虽然现在看来结果是对的，但当时的我，根本没有自己的思想，没有思考过为什么，要得到什么，要怎么做。我不知道上海、杭州、北京、深圳…他们到底有什么区别，他们肯定比现在要好吧。</p><p>就这样年后我火速离职了，曾经觉得一天都离不开的工作，没了我一样在正常运转。去更好的地方是我一开始的目标，在武汉投递简历基本石沉大海，虽然面试的几家都很顺利的通过，但工资、公司环境和我期待的都相去甚远。就这样时间一天天流逝，投递到上海、北京、杭州的简历回应袅袅，在家中无所事事的时候，面对金三银四的招聘信息，面对同事不断的刺激，焦虑在我的内心一节节攀升。</p><p>机会总算来了，在小一届的校友内推下，我通过小作业进入了扇贝的面试阶段，扇贝位于南京的一处软件园，我满怀着期待，坐上开往南京的动车（车票很便宜160），还没到面试约定时间，我沿着干净的柏油路，参观了旁边的苏宁总部，途牛等等好多公司，正值午饭期间，路上年轻人来来往往，我似乎感受到了这种氛围，他们多好啊，薪酬丰富，说不定也像我一样来自五湖四海，在这里做着喜欢的事情，想加入他们的强烈渴望充斥我的脑海。路上还看到了一处高档别墅里面盛开的樱花，这些印象到现在都很深刻。开始面试了，前台姐姐好像因为刚刚下午的原因看起来有点疲惫，带我到楼上的会议室里，贴心的送上了一瓶矿泉水，非常非常感谢，我边填资料，边等待面试官。资料单上需要填写很多详细资料，在之前的面试中，涉及到家庭信息和隐私的，我一律不填，但这一次，我很渴望加入，每一处空格我都认真填上。填写资料的时候，窗外传来隐约的笑声，透过窗户看到他们的员工正在楼顶上户外活动，真好。面试官来了，两位，年轻，礼貌，一位拿着记事本记录，一位端着一台15寸的最新Mac，感受到了尊重。面试表现非常一般，很多基础知识掌握的都不好，基本上都是书上的，我也看过一遍，可能是因为我接触的点还比较多，他们问了很多简历上一些有趣的细节，就这样经历了两轮技术，一轮HR面，HR亲切的将我送下楼。至此，我内心里充满了期待，感觉有机会加入。</p><p>当天下午我怀着愉快的心情回到了武汉，开始等待结果。等待的几天里我越来越焦虑，三天是期限，第三天下午的时候，我到南湖帮助处理交换机和网络问题，解决完问题后就接到了HR的电话，通过了！！！8k、15薪、六险一金、体检、每天7点之前下班，问我什么时候可以入职，那天已经是周四，我便约定下周一，她告诉我offer还要等待最后的审批，让我等待邮件。经过一个月求职的折磨，我已经急切的想要和家人朋友分享这个信息。这个工资相当于之前的两倍了，我告诉了室友、爸爸妈妈、哥哥姐姐、同事，他们都很高兴，妈妈已经开始帮我准备行李了，所有的焦虑好像在这一刻化为乌有。但是，我从天堂跌到了地狱，第二天下午HR打电话给我，告知还要审核…我非常非常失望，愤怒。是的不知道是愤怒还是恼怒，这一次扇贝的面试，从内推简历通过小作业开始，到最后告诉我没通过，花费了接近20天，期间拒绝了武汉的offer，没有投递外地的简历。我异常的失落和愤怒了，感觉他们效率低下，每一个阶段的流程都要等到最后一天才告知我结果，甚至是我主动联系。而我，失去了这次宝贵的机会，失去了20天的时间，积攒了20天的焦虑和不安。</p><p>距离离职时间（2.29）已经过去快一个月了，马上又是清明节，在亲人，朋友面前我开始感到羞愧，过节明明有时间，也不想回老家去。接下来的一周里，我投遍了武汉的公司，收到面试机会的公司也越来越垃圾，好像失去了目标。没有办法，我只能被迫开始投递外地的公司，收到的回应开始多了起来，北京的居多，但我心里明白，必须要到北京参加面试才行。不断的刷着别人北漂的经历，我终于鼓起勇气了。我知道最差的情况，就是承担一周的房租+来回车票，大约2000元。就这样我怀着忐忑的心情来到了北京，之后的事情没想到却异常顺利。</p><p>最不想回忆、思考的部分是，自从扇贝的拒绝之后，我开始不信任招聘里所有的承诺，来到北京之后，快速发放的offer我一直都不敢完全接受，我的内心里好像一直在告诫自己，不要高兴的太早，这一切你随时都有可能失去。所以，我租房的时候小心翼翼，联系家里寄送东西的时候小心翼翼，花钱的时候更小心翼翼，甚至身份证上那张跟现在完全不像的照片都让我怀疑自己，上班的时候，我全力集中精神，害怕工作能力不被认可。还好家人的支持、同事的友好，让现在十分顺利。</p><p>一天天认真的工作，我慢慢踏实下来，明白了工作能力，技术水平才是竞争力的核心，可能是刚刚工作不久，求职的结果高低起伏差距甚大，但我相信，一步步踩下的脚印会让我收获应得的结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来北京快一个月了，刚开始每个周末都很忙，找房子、体检、回家、公司出游，没想到今天（2018-05-12）居然是第一天闲下来回忆、思考、记录的时候。&lt;/p&gt;
&lt;p&gt;刚到北京，因为对于未知的城市心怀忐忑，所以提前做了些功课，住房上几乎没带来任何困扰，加上地图软件，出行也很顺利。
      
    
    </summary>
    
      <category term="经历" scheme="https://haohaozaici.github.io/categories/%E7%BB%8F%E5%8E%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Android音频焦点与声音重叠</title>
    <link href="https://haohaozaici.github.io/2018/04/24/Android%20Sound%20overlap/"/>
    <id>https://haohaozaici.github.io/2018/04/24/Android Sound overlap/</id>
    <published>2018-04-24T11:22:02.000Z</published>
    <updated>2018-04-24T11:27:23.818Z</updated>
    
    <content type="html"><![CDATA[<p>音视频播放在手机日常使用中非常频繁，当我们听着音乐刷着微博时，看到有趣的视频点击开始播放，音乐自动暂停，退出视频时音乐又自动恢复了播放(如果没有自动恢复的话，比如QQ音乐就会提示是否设置中断后继续播放)。</p><p><img src="https://img.mukewang.com/5aded21b0001ab9210801920.png" width="240" alt="中断后继续播放"></p><p>这一系列流畅自然的操作不是理所应当的吗~当然如果处理不好的话就会出现声音重叠，音频焦点长期被占用的问题，下面我们来看看具体的功能逻辑。</p><p>音频焦点相关的讲解参考以下文章</p><blockquote><p><a href="https://www.jianshu.com/p/5d8d7b677690" target="_blank" rel="noopener">Android音频焦点详解</a><br><a href="https://developer.android.com/guide/topics/media-apps/audio-focus.html" target="_blank" rel="noopener">Managing Audio Focus</a></p></blockquote><h2 id="Managing-Audio-Focus"><a href="#Managing-Audio-Focus" class="headerlink" title="Managing Audio Focus"></a>Managing Audio Focus</h2><p>不同的APP可以同时播放音频，系统会将他们混合在一起，但为了避免同时播放，Android提供了<strong>audio focus</strong>机制来合理使用音频播放资源。同一时间只能有一个APP获取音频焦点，当需要播放音频时，应该立即请求音频焦点，同样的，在你的APP获取到音频焦点后，其他APP也可以抢占音频焦点，这时你的APP就需要暂停播放或降低声音。音频焦点是合作类型的，APP拥有完全自主的控制权，系统无法阻止，但应用应该遵守音频焦点的指导规则。</p><p>好的音频APP在播放时应该遵守以下规则：</p><ul><li>开始播放后立即调用<code>requestAudioFocus()</code>方法，并验证返回值为<code>AUDIOFOCUS_REQUEST_GRANTED</code></li><li>当其他app占用音频焦点时，暂停或停止播放，或者降低声音</li><li>当播放停止时，放弃音频焦点</li></ul><p>在不同的Android版本下，需要使用不同的方法来处理音频焦点：</p><ul><li><em>API level 8</em>以后，使用<code>requestAudioFocus()</code>和<code>abandonAudioFocus()</code>方法，并注册<code>AudioManager.OnAudioFocusChangeListener</code>接收回调。</li><li><em>API level 21</em>以后，需要使用<code>AudioAttributes</code>来描述播放音频的类型。</li><li><p><em>API level 26</em>以后，需要使用<code>AudioFocusRequest</code>参数，它携带了音频的context和相关功能，系统会根据这些自动管理音频焦点。</p><h3 id="Android8-0以前"><a href="#Android8-0以前" class="headerlink" title="Android8.0以前"></a>Android8.0以前</h3><p>参考官方文档获取焦点的方法如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Request audio focus for playback</span></span><br><span class="line"><span class="keyword">int</span> result = am.requestAudioFocus(afChangeListener,</span><br><span class="line">        <span class="comment">// Use the music stream.</span></span><br><span class="line">        AudioManager.STREAM_MUSIC,</span><br><span class="line">        <span class="comment">// Request permanent focus.</span></span><br><span class="line">        AudioManager.AUDIOFOCUS_GAIN);</span><br></pre></td></tr></table></figure><p>但在听音乐的时候播放音频或视频，依旧出现了重叠的声音，实际上有效的做法是这样的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面两个常量参数试过很多 都无效，最终反编译了其他app才搞定，汗~  </span></span><br><span class="line"><span class="keyword">int</span> requestFocusResult = mAudioManager.requestAudioFocus(</span><br><span class="line">        mAudioFocusChangeListener,</span><br><span class="line">        AudioManager.STREAM_MUSIC,</span><br><span class="line">        AudioManager.AUDIOFOCUS_GAIN_TRANSIENT);</span><br></pre></td></tr></table></figure></p><p>具体参考文章<a href="https://blog.csdn.net/SYIF88/article/details/68064866" target="_blank" rel="noopener">Android MediaPlayer音频焦点问题，抢占声道</a></p><p>最后在对应的播放状态下获取和释放音频焦点。</p><h3 id="Android8-0之后"><a href="#Android8-0之后" class="headerlink" title="Android8.0之后"></a>Android8.0之后</h3><p>和之前一样，Android8.0中也使用了<code>requestAudioFocus()</code>来请求音频焦点，不一样的是，使用<code>abandonAudioFocusRequest()</code>释放音频焦点，并且请求和释放都需要传入同一个<code>AudioFocusRequest</code>实例。使用<code>AudioFocusRequest.Builder</code>来创建，具体实现代码参考官方文档<a href="https://developer.android.com/guide/topics/media-apps/audio-focus.html#audio-focus-8-0" target="_blank" rel="noopener">Audio focus in Android 8.0 and later</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mAudioFocusRequest = <span class="keyword">new</span> AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN)</span><br><span class="line">        .setAudioAttributes(<span class="keyword">new</span> AudioAttributes.Builder()</span><br><span class="line">                .setUsage(AudioAttributes.USAGE_MEDIA)</span><br><span class="line">                .setContentType(AudioAttributes.CONTENT_TYPE_MOVIE)</span><br><span class="line">                .build())</span><br><span class="line">        .setAcceptsDelayedFocusGain(<span class="keyword">true</span>)</span><br><span class="line">        .setOnAudioFocusChangeListener(mAudioFocusChangeListener)</span><br><span class="line">        .build();</span><br><span class="line"><span class="comment">//请求音频焦点      </span></span><br><span class="line">requestFocusResult = mAudioManager.requestAudioFocus(mAudioFocusRequest);</span><br><span class="line"><span class="comment">//释放音频焦点</span></span><br><span class="line">abandonFocusResult = mAudioManager.abandonAudioFocusRequest(mAudioFocusRequest);</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>Android8.0中其他APP使用<code>AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK</code>参数获取焦点时，将不会回调本APP的<code>onAudioFocusChange()</code>方法。</li><li>焦点延迟获取，当焦点被其他APP<strong>“锁”</strong>住时，<code>requestAudioFocus()</code>会返回<code>AUDIOFOCUS_REQUEST_FAILED</code>，比如正在打电话时，焦点就会被锁住。如果使用了<code>setAcceptsDelayedFocusGain(true)</code>方法，请求将会返回<code>AUDIOFOCUS_REQUEST_DELAYED</code>，在锁解除后，系统会继续处理未完成的焦点请求，并回调<code>onAudioFocusChange()</code>方法。</li></ul><h2 id="处理音频焦点变化"><a href="#处理音频焦点变化" class="headerlink" title="处理音频焦点变化"></a>处理音频焦点变化</h2><p>了解相应的请求、释放方法后，还需要进一步处理音频焦点变化问题，也就是优化跟其他APP或者是系统APP合作的过程。主要是处理<code>onAudioFocusChange</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AudioManager.OnAudioFocusChangeListener mAudioFocusChange = <span class="keyword">new</span> AudioManager.OnAudioFocusChangeListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAudioFocusChange</span><span class="params">(<span class="keyword">int</span> focusChange)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (focusChange)&#123;</span><br><span class="line">                <span class="keyword">case</span> AudioManager.AUDIOFOCUS_GAIN:</span><br><span class="line">                    <span class="comment">//当其他应用申请焦点之后又释放焦点会触发此回调</span></span><br><span class="line">                    <span class="comment">//可重新播放音乐</span></span><br><span class="line">                    Log.d(TAG, <span class="string">"AUDIOFOCUS_GAIN"</span>);</span><br><span class="line">                    start();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS:</span><br><span class="line">                    <span class="comment">//长时间丢失焦点,当其他应用申请的焦点为AUDIOFOCUS_GAIN时，</span></span><br><span class="line">                    <span class="comment">//会触发此回调事件，例如播放QQ音乐，网易云音乐等</span></span><br><span class="line">                    <span class="comment">//通常需要暂停音乐播放，若没有暂停播放就会出现和其他音乐同时输出声音</span></span><br><span class="line">                    Log.d(TAG, <span class="string">"AUDIOFOCUS_LOSS"</span>);</span><br><span class="line">                    stop();</span><br><span class="line">                    <span class="comment">//释放焦点，该方法可根据需要来决定是否调用</span></span><br><span class="line">                    <span class="comment">//若焦点释放掉之后，将不会再自动获得</span></span><br><span class="line">                    mAudioManager.abandonAudioFocus(mAudioFocusChange);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:</span><br><span class="line">                    <span class="comment">//短暂性丢失焦点，当其他应用申请AUDIOFOCUS_GAIN_TRANSIENT或AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE时，</span></span><br><span class="line">                    <span class="comment">//会触发此回调事件，例如播放短视频，拨打电话等。</span></span><br><span class="line">                    <span class="comment">//通常需要暂停音乐播放</span></span><br><span class="line">                    stop();</span><br><span class="line">                    Log.d(TAG, <span class="string">"AUDIOFOCUS_LOSS_TRANSIENT"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:</span><br><span class="line">                    <span class="comment">//短暂性丢失焦点并作降音处理</span></span><br><span class="line">                    Log.d(TAG, <span class="string">"AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>音频相关的API常常让人疑惑，明明已经根据注释的描述和官方文档中的方法实现了，却达不到预期的效果。还有就是随着Android更新的推送速度越来越快，更新普及率也水涨船高，高版本API随时在发生变化，适配时需要注意这些细节，以及进行完善的测试。</p><p>工具类参见<a href="https://gist.github.com/haohaozaici/baaa022e6ea5f61f37112135fe1cac07" target="_blank" rel="noopener">AudioFocusManager</a></p><h4 id="未完成内容"><a href="#未完成内容" class="headerlink" title="未完成内容"></a>未完成内容</h4><p>源码简单分析</p><p>在不同机型中进行测试</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;音视频播放在手机日常使用中非常频繁，当我们听着音乐刷着微博时，看到有趣的视频点击开始播放，音乐自动暂停，退出视频时音乐又自动恢复了播放(如果没有自动恢复的话，比如QQ音乐就会提示是否设置中断后继续播放)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.mukew
      
    
    </summary>
    
      <category term="Android" scheme="https://haohaozaici.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android视频播放 ijkplayer</title>
    <link href="https://haohaozaici.github.io/2018/04/24/Android-video-player/"/>
    <id>https://haohaozaici.github.io/2018/04/24/Android-video-player/</id>
    <published>2018-04-24T11:22:02.000Z</published>
    <updated>2018-05-12T07:37:37.561Z</updated>
    
    <content type="html"><![CDATA[<p>MediaCodec 硬解<br>OpenSLES 硬件音频加速  默认关闭最好</p><p>渲染器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MediaCodec 硬解&lt;br&gt;OpenSLES 硬件音频加速  默认关闭最好&lt;/p&gt;
&lt;p&gt;渲染器&lt;/p&gt;

      
    
    </summary>
    
      <category term="Android" scheme="https://haohaozaici.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>ARouter</title>
    <link href="https://haohaozaici.github.io/2018/04/23/ARouter/"/>
    <id>https://haohaozaici.github.io/2018/04/23/ARouter/</id>
    <published>2018-04-23T06:09:25.000Z</published>
    <updated>2018-04-23T09:53:32.910Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ARouter典型应用"><a href="#ARouter典型应用" class="headerlink" title="ARouter典型应用"></a>ARouter典型应用</h2><ol><li>从外部URL映射到内部页面，以及参数传递与解析</li><li>跨模块页面跳转，模块间解耦</li><li>拦截跳转过程，处理登陆、埋点等逻辑</li><li>跨模块API调用，通过控制反转来做组件解耦</li></ol><h2 id="ARouter拦截器"><a href="#ARouter拦截器" class="headerlink" title="ARouter拦截器"></a>ARouter拦截器</h2><h3 id="面向切面编程"><a href="#面向切面编程" class="headerlink" title="面向切面编程"></a>面向切面编程</h3><p>面向切面编程（AOP是Aspect Oriented Program的首字母缩写） ，我们知道，面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用。      但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来。    也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。       一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ARouter典型应用&quot;&gt;&lt;a href=&quot;#ARouter典型应用&quot; class=&quot;headerlink&quot; title=&quot;ARouter典型应用&quot;&gt;&lt;/a&gt;ARouter典型应用&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;从外部URL映射到内部页面，以及参数传递与解析&lt;/li&gt;
      
    
    </summary>
    
      <category term="Android" scheme="https://haohaozaici.github.io/categories/Android/"/>
    
      <category term="组件化" scheme="https://haohaozaici.github.io/categories/Android/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>2017年终总结</title>
    <link href="https://haohaozaici.github.io/2018/01/14/2017-summary/"/>
    <id>https://haohaozaici.github.io/2018/01/14/2017-summary/</id>
    <published>2018-01-13T18:20:23.000Z</published>
    <updated>2018-04-20T02:04:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>没想到还是要写年终总结了。。。<br>此刻正在我的小桌子上，用键盘和mac写下这篇年终总结。。<br>时间: 2018-01-14 00:24:09</p></blockquote><p>第一次写年终总结有点懵。。。不过刚刚看了一集生活大爆炸中的内容感触很深，Sheldon被问及最近在研究什么的时候，不知道怎么回答，只能用愤怒来掩饰。</p><p>掩饰什么呢？懈怠了吗？</p><p>肯定不是啦，Sheldon怎么会是懒惰的人呢。原来是因为开始研究暗物质，但最近一无所获，有点迷失。经过这么一问，加上penny的「倾听」和「配合」，Sheldon突然发现自己最喜欢的还是弦理论，研究暗物质可能只是因大家都在讨论，看起来很cool而已。</p><p>是啊，很多喊得热火朝天，趋之若鹜的东西，最终反而会迷失了自己。</p><p>Leonard和amy在回忆小时候的科学实验，找到共同话题，开心的不得了；<br><br>Howard和rajesh又一起组建了乐队，berni发现Howard是真的喜欢之后也默默同意，虽然最后唱的悲剧了。。。haha<br><br>Sheldon也在弦理论中找到新的思路</p><p>他们都在做自己喜欢的事，热爱的东西。无论结果好坏，却愿意付出真正的行动与热情。</p><p>这一切，让我想起了还在东一食堂的时候，高中学习累的不行，周末下午在家里躺在床上睡着了，快吃饭的时候，妈妈喊我也不想起来，突然电视里在放虚拟现实的内容，他们开始讨论这个，隐约听见有人问我。。。然后我就感觉到大脑异常的兴奋，开始向他们介绍和解释VR，但当时还是迷糊状态。。。眼睛都睁不开。或许这就是热情，喜欢吧。（现在已经没那么感兴趣了。。。zz）</p><p>以上也是我现在的困惑，工作中找不到重心，也找不到成就感。</p><p>有点跑偏了。。。回归正题，一年都干了些什么呢</p><h2 id="年初的目标"><a href="#年初的目标" class="headerlink" title="年初的目标"></a>年初的目标</h2><p>大概就是「工作」、「想买的xxx」、「礼物」、加上某个不存在的东西…哈哈。</p><p>想买的电子产品都买啦~ Mac、耳机、键盘。最满意的是「键盘」，使用率最高，也符合预期。今年应该会考虑换个手机 +「AirPods」。</p><p>礼物的话，爸爸的眼镜、「mi note3」，哥哥的iPad的支援了一半，还差两个不知道送啥。。。</p><p>工作基本上是满足的，学习状态、同事关系、部门活动都很不错。</p><p>不存在的就不说了。。。</p><h2 id="学习上的成长"><a href="#学习上的成长" class="headerlink" title="学习上的成长"></a>学习上的成长</h2><p>开发经验的积累，开始注意理财</p><h3 id="开发经验"><a href="#开发经验" class="headerlink" title="开发经验"></a>开发经验</h3><p>今年真是写了几个大bug，造成了一些比较严重的后果。。。最大的感受应该是<code>思路的严谨</code>，对于所有预期的异常情况都需要处理，喜欢drakeet的比喻「绝不会让咖啡洒在Mac上」。知道水会造成严重的伤害，就绝不会让它靠近。不考虑异常是不负责任。</p><p>意识到：学习一门新的语言或者是接触新的领域 = 语言基础（语言特性） + API + 实践经验（踩坑）</p><p>今年的技术积累大概就是这张图了吧。。。都在书签里了</p><p><img src="http://ww1.sinaimg.cn/large/a328671cgy1fnfi1u1k9nj210j145n5l.jpg" alt="Android书签"></p><p>也不知道该总结什么。。。虽然感觉学习了很多，但有太多的不足。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Java基础</span><br><span class="line">数据结构和算法</span><br><span class="line">网络</span><br><span class="line">Android View相关</span><br><span class="line">Android架构</span><br><span class="line"></span><br><span class="line">web</span><br><span class="line">server</span><br></pre></td></tr></table></figure><p>不过经过了生产环境的实践，已经逐渐意识到不足的部分，也开始有计划的学习。</p><p>感觉2017年学习的知识很多，甚至有些杂乱，其中主要的原因应该是没有总结、积累，实践也稍显不足。利用保存书签来记录看来是有些幼稚了。。。</p><p>已经意识到「临时工作区」、「灵感」、「实践记录」、「阶段性总结」、「文章」的区别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;没想到还是要写年终总结了。。。&lt;br&gt;此刻正在我的小桌子上，用键盘和mac写下这篇年终总结。。&lt;br&gt;时间: 2018-01-14 00:24:09&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一次写年终总结有点懵。。。不过刚刚看了一集生活大爆
      
    
    </summary>
    
      <category term="总结" scheme="https://haohaozaici.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>创建和销毁对象</title>
    <link href="https://haohaozaici.github.io/2017/12/19/create-and-destroy-objects/"/>
    <id>https://haohaozaici.github.io/2017/12/19/create-and-destroy-objects/</id>
    <published>2017-12-19T07:12:41.000Z</published>
    <updated>2017-12-29T15:17:35.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h2><h3 id="静态工厂方法代替构造器"><a href="#静态工厂方法代替构造器" class="headerlink" title="静态工厂方法代替构造器"></a>静态工厂方法代替构造器</h3><p>静态工厂方法与设计模式中的<code>工厂方法</code>不同。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li>静态工厂方法有名称，</li></ol><h3 id="遇到多个构造器参数时，使用构建器-Builder模式"><a href="#遇到多个构造器参数时，使用构建器-Builder模式" class="headerlink" title="遇到多个构造器参数时，使用构建器-Builder模式"></a>遇到多个构造器参数时，使用构建器-Builder模式</h3><h4 id="1-使用构造方法创建对象"><a href="#1-使用构造方法创建对象" class="headerlink" title="1.使用构造方法创建对象"></a>1.使用构造方法创建对象</h4><p>重叠构造器</p><h4 id="2-JavaBeans模式"><a href="#2-JavaBeans模式" class="headerlink" title="2.JavaBeans模式"></a>2.JavaBeans模式</h4><p>通过setter方法设置必要参数，拥有良好的可读性。<br><em>缺点</em>：构造过程中容易被改变，处于不一致的状态。</p><h4 id="3-Builder模式"><a href="#3-Builder模式" class="headerlink" title="3.Builder模式"></a>3.Builder模式</h4><p>通过公开的Builder内部类，私有的构造方法，构造必传参数和可选参数。Builder模式模拟了具名的可选参数，可以加强约束条件，在对象域中进行检验。可以在编译时进行异常检查。 </p><p><em>缺点</em>：特殊情况下额外的性能开销，冗长。<br><em>适用情况</em>：多个参数(大于4个)，需要比JavaBeans模式更加安全的情况。</p><p>参见 <code>Notification</code> 或 <code>Alertdialog</code>类。</p><h3 id="用私有构造器或者枚举类型强化singleton属性"><a href="#用私有构造器或者枚举类型强化singleton属性" class="headerlink" title="用私有构造器或者枚举类型强化singleton属性"></a>用私有构造器或者枚举类型强化singleton属性</h3><p>为了防止反射调用私有构造方法、反序列化时创建新的实例，直接使用 <code>包含单个元素的枚举类型</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Elvis&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h3><p>39条 应该创建新对象时，不要重用现有对象<br>创建不必要的对象只会影响程序的风格和性能，没有实施保护性拷贝将会导致潜在的错误和安全漏洞。</p><h3 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h3><p><code>内存泄露</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建和销毁对象&quot;&gt;&lt;a href=&quot;#创建和销毁对象&quot; class=&quot;headerlink&quot; title=&quot;创建和销毁对象&quot;&gt;&lt;/a&gt;创建和销毁对象&lt;/h2&gt;&lt;h3 id=&quot;静态工厂方法代替构造器&quot;&gt;&lt;a href=&quot;#静态工厂方法代替构造器&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Java" scheme="https://haohaozaici.github.io/categories/Java/"/>
    
      <category term="Effective Java" scheme="https://haohaozaici.github.io/categories/Java/Effective-Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java Servlet</title>
    <link href="https://haohaozaici.github.io/2017/12/19/java_servlet/"/>
    <id>https://haohaozaici.github.io/2017/12/19/java_servlet/</id>
    <published>2017-12-19T07:12:41.000Z</published>
    <updated>2018-01-11T03:14:07.241Z</updated>
    
    <content type="html"><![CDATA[<p>Java Servlet</p><h2 id="Http-Servlet"><a href="#Http-Servlet" class="headerlink" title="Http Servlet"></a>Http Servlet</h2><p>处理http请求</p><h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><ol><li>URL重写</li><li>隐藏域</li><li>Cookies</li><li>HttpSession对象</li></ol><h2 id="JSP-JavaServer-Page"><a href="#JSP-JavaServer-Page" class="headerlink" title="JSP (JavaServer Page)"></a>JSP (JavaServer Page)</h2><h2 id="JSP-标签、listener、"><a href="#JSP-标签、listener、" class="headerlink" title="JSP 标签、listener、"></a>JSP 标签、listener、</h2><h2 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h2><h2 id="异步处理、异步监听"><a href="#异步处理、异步监听" class="headerlink" title="异步处理、异步监听"></a>异步处理、异步监听</h2><p>区分耗时任务与异步处理</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>声明性安全</p><ol><li>对称加密</li><li>RSA非对称加密</li></ol><p>通过<code>HTTPS</code>和<code>安全证书</code>构建安全通道，<code>SSL</code>再通过对称加密高速传输信息，<code>MD5</code>校验数据准确性和完整性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java Servlet&lt;/p&gt;
&lt;h2 id=&quot;Http-Servlet&quot;&gt;&lt;a href=&quot;#Http-Servlet&quot; class=&quot;headerlink&quot; title=&quot;Http Servlet&quot;&gt;&lt;/a&gt;Http Servlet&lt;/h2&gt;&lt;p&gt;处理http请求&lt;/
      
    
    </summary>
    
      <category term="server" scheme="https://haohaozaici.github.io/categories/server/"/>
    
      <category term="Servlet" scheme="https://haohaozaici.github.io/categories/server/Servlet/"/>
    
    
  </entry>
  
  <entry>
    <title>Android自定义锁屏页</title>
    <link href="https://haohaozaici.github.io/2017/12/13/custom-lock-screen/"/>
    <id>https://haohaozaici.github.io/2017/12/13/custom-lock-screen/</id>
    <published>2017-12-13T12:24:07.000Z</published>
    <updated>2017-12-13T12:39:17.034Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>自定义锁屏页类似于QQ音乐在锁屏、亮屏后显示完全自定义的锁屏内容。简单来说就是在锁屏之后收到锁屏广播，启动自定义锁屏Activity，同时取消系统锁屏（有密码时无法关闭），模拟滑动解锁，不是系统级的行为。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;自定义锁屏页类似于QQ音乐在锁屏、亮屏后显示完全自定义的锁屏内容。简单来说就是在锁屏之后收到锁屏广播，启动自定义锁屏Activity，同时取消系统锁屏（有密码时无法关闭），模拟滑动解锁，不是系统级的行为。&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
      <category term="Android" scheme="https://haohaozaici.github.io/categories/Android/"/>
    
      <category term="View" scheme="https://haohaozaici.github.io/categories/Android/View/"/>
    
      <category term="自定义锁屏" scheme="https://haohaozaici.github.io/categories/Android/View/%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%81%E5%B1%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Mifare 1k S50卡</title>
    <link href="https://haohaozaici.github.io/2017/12/13/M1%20card/"/>
    <id>https://haohaozaici.github.io/2017/12/13/M1 card/</id>
    <published>2017-12-13T08:41:43.000Z</published>
    <updated>2018-04-20T02:05:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>背景：最近的项目中涉及到读写M1卡，之前完全没接触过一脸懵逼，却没意识到，生活中常用的公交卡、门禁卡、开水卡、会员卡等等大多数都是M1类的射频卡，如Mifare 1k S50系列。熟悉了相关知识后，发现原理如此简单，感谢开源也因此能做很多方便的事情了。记录一下，面对陌生的事物不要害怕，了解熟悉，探索乐趣。</p></blockquote><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="M1卡"><a href="#M1卡" class="headerlink" title="M1卡"></a>M1卡</h3><p>M1卡结构</p><div style="align: center"><img src="/img/m1card.webp" alt="M1卡结构"> </div><p>从上面可以看到，<code>扇区0 块0</code>固化了厂家代码，32位16进制数，一般作为<code>ID</code>使用。</p><p>每一个扇区的块3用于保存<code>KEY A,存取控制,KEY B</code>，除了扇区0的块0之外的其他的<code>块0~块2</code>都用于存储数据。<code>KEY A</code>不可读、可写，<code>KEY B</code>可读可写.</p><p>一般的门禁卡中，不存储任何数据，门禁系统只读取卡ID，学校里使用的开水卡，一般是离线使用，卡的余额或者使用次数是存储在卡中的，使用时进行读写。在武汉通中，存储了卡余额，储值、消费记录，具体的余额存储在服务器上。所以理论上可以模拟卡ID来模拟门禁卡，或者是读取修改水卡值来修改卡。</p><p>读写卡工具<a href="https://play.google.com/store/apps/details?id=de.syss.MifareClassicTool" target="_blank" rel="noopener">MIFARE Classic Tool</a>, <a href="https://github.com/ikarus23/MifareClassicTool" target="_blank" rel="noopener">MifareClassicTool - GitHub</a></p><p>模拟卡工具<a href="https://play.google.com/store/apps/details?id=com.yuanwofei.cardemulator" target="_blank" rel="noopener">NFC卡模拟</a></p><h4 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h4><p><a href="https://www.null17.com/blog/coding/NFC/20151019-nfc-mod/" target="_blank" rel="noopener">Mifare 1k S50 卡的简单探讨与破解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;背景：最近的项目中涉及到读写M1卡，之前完全没接触过一脸懵逼，却没意识到，生活中常用的公交卡、门禁卡、开水卡、会员卡等等大多数都是M1类的射频卡，如Mifare 1k S50系列。熟悉了相关知识后，发现原理如此简单，感谢开源也因此能做很多方便的事情
      
    
    </summary>
    
      <category term="生活" scheme="https://haohaozaici.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="乱七八糟的技巧" scheme="https://haohaozaici.github.io/categories/%E7%94%9F%E6%B4%BB/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
</feed>
