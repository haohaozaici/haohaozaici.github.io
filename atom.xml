<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浩浩的被窝</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://haohaozaici.github.io/"/>
  <updated>2018-08-01T11:55:04.941Z</updated>
  <id>https://haohaozaici.github.io/</id>
  
  <author>
    <name>haohaozaici</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「播放器」Android视频开发介绍</title>
    <link href="https://haohaozaici.github.io/2018/08/01/Android-video-player/"/>
    <id>https://haohaozaici.github.io/2018/08/01/Android-video-player/</id>
    <published>2018-08-01T10:05:07.000Z</published>
    <updated>2018-08-01T11:55:04.941Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>移动端流媒体随着各种视频app的火爆，以及移动流量的升级逐渐占据人们大量宝贵的时间。但是从开发小白的角度来看，这一直是个很有难度的开发领域，真正深度接触视频业务的app也不多，恰好有了浅度的需求，往往又会花费大量的时间了解、踩坑。<strong>「播放器」系列文章的目的，就是想完成一个「还可以的」实践</strong>，读完文章也能达到实践的程度。基于ijkplayer<br>这篇文章更多的是总体的介绍，会随着理解加深不断更新。</p></blockquote><h2 id="0-播放器基本原理"><a href="#0-播放器基本原理" class="headerlink" title="0 播放器基本原理"></a>0 播放器基本原理</h2><p>首先简单了解一下播放器的基本原理和结构。<br><img src="https://ws1.sinaimg.cn/large/a328671cly1ftues405nkj20da0buwga.jpg" alt="原理图"></p><p>主要包含以下几个步骤：</p><ul><li>数据接收(数据获取、解协议)</li><li>解封装(demux)</li><li>解码</li><li>音视频同步（图中没有）</li><li>输出</li></ul><p>解封装：将多个轨道的数据分解出来，比如一个mp4格式的文件解封装后输出H.264编码的视频流、aac编码的音频流<br>解码：将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据</p><p>结合上面的结构来看，客户端的视频开发主要包含了：<strong>视频源、播放器、业务场景</strong>几个部分，下面逐个进行分析。</p><h2 id="1-视频源"><a href="#1-视频源" class="headerlink" title="1 视频源"></a>1 视频源</h2><p>视频源决定了<strong>传输协议、封装格式、编码类型</strong>，影响着播放器内核的选择、支持格式的拓展，以及加解密。一般来说播放器开发时视频源都是已经确定了的，我目前使用的视频源主要是HLS（m3u8 + ts），部分使用MP4封装，H.264 AAC编码，ijkplayer和ExoPlayer都支持良好。</p><ul><li>传输协议：hls，crypto加密</li><li>封装格式：ts切片</li><li>编码类型：H.264 AAC</li></ul><h3 id="M3U8视频源的加解密"><a href="#M3U8视频源的加解密" class="headerlink" title="M3U8视频源的加解密"></a>M3U8视频源的加解密</h3><p>视频源的加解密环节也相当重要，项目中m3u8文件和hxk key都进行了加密，需要通过接口获取并解密，标准的hls协议并不支持，其中m3u8文件经过解密后可直接使用，但hxk文件是在播放器内部实现hls协议时处理的，如果不修改native代码的话，就需要自定义hxk文件获取的过程。加解密的过程会单独开文章分析。</p><p>视频源也可以叫<code>DataSource、MediaSource</code>，包含了众多的分类，如果想要详细了解可以参考exoplayer的实现。</p><h2 id="2-播放器"><a href="#2-播放器" class="headerlink" title="2 播放器"></a>2 播放器</h2><p>播放器要完成获取视频流、解码、输出到屏幕，最后还要提供丰富的功能，这一系列的操作主要由<strong>MediaPlayer、SurfaceView、Controller和相关功能模块</strong>组成，下面逐一介绍。</p><ul><li>MediaPlayer：负责音视频流的获取、解码、输出、状态控制。</li><li>SurfaceView：负责解码后视频帧的显示（大小、比例、方向等）。如<code>SurfaceView、TextureView、GLSurfaceView</code>，项目中主要使用TextureView</li><li>Controller：播放器相关的功能控制。进度条、手势操作、播放速度、画面显示比例、屏幕锁等</li><li>其他功能：如音频焦点、屏幕常亮、后台播放、旋转、状态栏控制等</li></ul><h3 id="MediaPlayer"><a href="#MediaPlayer" class="headerlink" title="MediaPlayer"></a>MediaPlayer</h3><p>对于MediaPlayer来说，以下能力非常关键：</p><ul><li>网络能力：支持各种预期的协议，如完整的支持hls各种特性，有良好的网络能力，如各种拉流的控制、容错</li><li>解码能力：能够支持预期的格式（点播时，视频格式通常都是确定的几种），不能（不适合）硬解时提供软解</li><li>兼容性：在各种设备上的解码能力和解码策略</li><li>功能特性：播放速度（变速不变调）、精准seek、max-fps、缓冲区大小（基于FFmpeg）</li><li>信息反馈：返回准确丰富的状态信息、错误信息</li></ul><p>MediaPlayer的能力是播放器的基础，这个环节ijkplayer等都已经实现（网络功能直接集成在内部），我们主要是理解相关api的效果和如何使用。除此之外，通过接口，我们还可以使用不同的mp，不过不同的mp功能特性差别很大，实际项目中还是要使用综合考虑最优秀的。<br><img src="https://ws1.sinaimg.cn/large/a328671cly1ftues48fc1j20ie0aqaht.jpg" alt="media player"></p><h3 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a>Surface</h3><p>接下来是视频的显示，常用的主要是<code>SurfaceView、TextureView</code>两种，如果要添加特效、滤镜之类的则需要用到opengl。<br>对于视频的显示来说，以下能力非常关键：</p><ul><li>切换前后台的流畅度（在有些设备上Surface会被销毁重建）</li><li>对软硬解的兼容（比如软解+TextureView，重复使用TextureView会出现被锁住的情况）</li><li>旋转、缩放、平移<br>综合来看大家最终都选择了TextureView，同样的也可以使用接口来使用不同的surface<br><img src="https://ws1.sinaimg.cn/large/a328671cly1ftues48frbj20mt09g10x.jpg" alt="surface"></li></ul><p>SurfaceView和TextureView的比较已经有了很丰富的资料，这里简单介绍下在视频播放中主要的差别：</p><ul><li>SurfaceView的实现是在屏幕上“挖洞”，在Android N以下版本界面移动时会有很严重的黑边</li><li>SurfaceView播放效率略高于TextureView</li><li>TextureView可以使用view的各种方法，比如说matrix</li></ul><p>到这里VideoView就诞生了，mediaplayer + surface组合成了VideoView核心部分，和音频播放不同，mediaplayer 和 surface之间既独立又充满联系，他们之间的配合和影响后面单独开文章分析。</p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>复习一下，Controller负责播放器相关的功能控制，如进度条、手势操作、播放速度、画面显示比例、屏幕锁、切换清晰度等。也就是这个画面。<br><img src="https://ws1.sinaimg.cn/large/a328671cly1ftues4ydlkj21hc0u0qv5.jpg" alt="Controller-shot"></p><p>针对视频播放，系统提供了<code>MediaController</code>类给我们使用，但是自定义性差，还非常丑。。。不过却提供了很好的与VideoView一起协作的示例，完全可以copy一份，然后根据需求修改。针对横屏和竖屏一般会有两套Controller，所以这里我们也使用接口，既满足和VideoView的交互，又可以随时替换不同的实现。<br><img src="https://ws1.sinaimg.cn/large/a328671cly1ftuew2ekjvj20mk09adns.jpg" alt="Controller"></p><p>Controller已经是我们需要开发的核心部分了，比如手势控制、沉浸式下显示popup window等，可以单开一篇来介绍，这里就不细说，也可以在demo中查看效果和具体实现。</p><h3 id="丰富的功能"><a href="#丰富的功能" class="headerlink" title="丰富的功能"></a>丰富的功能</h3><p>只使用VideoView进行播放的场景估计只有广告了^_^，所以除了基础的控制功能之外，我们还要提供丰富的功能来提升使用体验，比如音频焦点、屏幕常亮、后台播放、旋转、悬浮窗、网络状态切换、状态栏控制，这一部分大多数需要与播放器的状态关联，同时较少或者几乎没有涉及到业务逻辑，也是开发的核心部分。与上面一样，很多细节都可以单开一篇来介绍，后续会逐渐完善。</p><p>至此可以看到播放器的部分和业务的交集很小，很容易整理成lib，将与UI无关的部分抽象出来，与UI、业务依赖多的部分也可以提供默认的实现以供参考。</p><h2 id="3-业务场景"><a href="#3-业务场景" class="headerlink" title="3 业务场景"></a>3 业务场景</h2><p>上面的内容好像将播放器几乎都涵盖了，但实际上缺少了非常重要的一个环节，<strong>业务场景</strong>。我非常认同这个的观点，我们要做懂技术，也懂行业、懂业务的人。<br><img src="https://ws1.sinaimg.cn/large/a328671cly1ftues4047nj20x007edhf.jpg" alt="业务"></p><p>所以呢，这个部分我们会简单讨论一下当前热门的视频应用和他们实现的效果，然后我们进行仿写。<br>业务范围：</p><ul><li>单视频点播：参考APP：bilibili、爱奇艺，特点：弹幕、播放详情页面、后台播放、播放详情页面、播放列表</li><li>离线播放</li><li>feed流：参考APP：bilibili weibo 网易云音乐</li><li>短视频</li><li>小窗播放：参考APP：youtube，特点：小窗口view、画中画</li><li>直播：参考APP：bilibili，特点：直播、悬浮窗</li></ul><p>此外还有一个特别重要部分：视频编辑（还包括直播推流、特效等），因为暂时没有接触，这部分不会涉及。</p><p>敬请期待~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;移动端流媒体随着各种视频app的火爆，以及移动流量的升级逐渐占据人们大量宝贵的时间。但是从开发小白的角度来看，这一直是个很有难度的开发领域，真正深度接触视频业务的app也不多，恰好有了浅度的需求，往往又会花费大量的时间了解、踩坑。&lt;strong&gt;「
      
    
    </summary>
    
      <category term="Android" scheme="https://haohaozaici.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>ConstraintLayout「最全总结」</title>
    <link href="https://haohaozaici.github.io/2018/07/11/ConstraintLayout/"/>
    <id>https://haohaozaici.github.io/2018/07/11/ConstraintLayout/</id>
    <published>2018-07-11T06:14:50.000Z</published>
    <updated>2018-07-12T03:25:31.879Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>现在大家几乎都使用过ConstraintLayout，但与经常使用的布局相比，可能会面临不熟悉CL的API或者是逐渐增加的新特性，还有可能因为对CL具体行为的理解模糊而导致误用，这篇文章的目的更多的是，<strong>全面总结ConstraintLayout的用法和实际行为特性，并不断更新</strong></p></blockquote><p>基于ConstraintLayout 1.1，当前2.0版本处于测试阶段<br>参考文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI1NjEwMTM4OA==&amp;mid=2651232651&amp;idx=1&amp;sn=9ea7beb5c280cd05d192cd3df072a745&amp;chksm=f1d9e4e8c6ae6dfe3aafc910cfd2785249d777a998521047127c5beac2c4657bdd7b6c2a43ac&amp;mpshare=1&amp;scene=23&amp;srcid=0608A4Q2cmC8SaMeykxP1klT%23rd" target="_blank" rel="noopener">ConstraintLayout入门指南</a></p><h2 id="为什么要引入ConstraintLayout"><a href="#为什么要引入ConstraintLayout" class="headerlink" title="为什么要引入ConstraintLayout"></a>为什么要引入ConstraintLayout</h2><ul><li><strong>减少布局层级</strong>：常用的布局划分成了几个不同的类型，要组合不同的功能需要通过嵌套的形式实现，比如想要按比例布局就要使用layout_weight属性，想要使用layout_weight属性就要使用LinearLayout（以下简称LL）或者TableLayout，然后你在原先同级的每个布局外再嵌套一层布局以使用layout_weight。</li><li><strong>更多的布局需求</strong>：要实现固定宽高比、百分比布局，灵活控制大小等更高阶的布局需求，原先的各类布局方式都不能很好的支持，可能需要通过Java代码，在运行中二次实现。</li><li>想要通过ConstraintLayout来 <strong>优化性能</strong>，<del>可能并不明显</del></li><li>亦或者你只是想尝试下这款Andorid官方力推的新布局，看看它有什么新特性。</li></ul><p>引入lib:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//确保SDK Tools中已经下载了ConstraintLayout的支持库：</span></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">'com.android.support.constraint:constraint-layout:1.1.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>开始之前，我们应该意识到在布局文件中Layout主要职责是什么，<strong>控制widgets的位置和大小</strong>。下面将从这两个方向出发，看看ConstraintLayout是怎么做的。</p><h2 id="1-控制位置"><a href="#1-控制位置" class="headerlink" title="1. 控制位置"></a>1. 控制位置</h2><p>layout中的view都有四个方向<code>left(start), right(end), top, bottom</code>，通过这些方向在两个view之间建立约束来实现基础的位置控制，相对于RelativeLayout，RL中所有的属性CL中都有与之对应的项目，稍加熟悉即可完成转换：</p><p><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbyw9rj212c0z4af4.jpg" alt="cl - rl"></p><p>相对于父布局的相对布局属性，CL的规则是：将父布局当做一个id=”parent”的对象来对待：</p><p><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nc04bdj213o16wwle.jpg" alt="cl parent - rl parent"></p><h3 id="1-1-Margins"><a href="#1-1-Margins" class="headerlink" title="1.1 Margins"></a>1.1 Margins</h3><p>设置普通的margin：<br><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbrn7yj20fy0dot9q.jpg" width="320" alt="margin"></p><h3 id="1-2-visibility-对约束的影响"><a href="#1-2-visibility-对约束的影响" class="headerlink" title="1.2 visibility 对约束的影响"></a>1.2 visibility 对约束的影响</h3><p>特殊的情况是：<strong>连接到visibility为GONE的view时的margin</strong>，在ConstraintLayout中，当widgets被设置<strong>View.GONE</strong>时进行了特殊处理。</p><ul><li>根据布局的传递，设置为GONE的view相当于大小被设置为0(实际上是被设置成了一个点)</li><li>如果他们已经跟其他的组件产生了约束关系，约束关系还是会存在，但是所有的margin都会变成0<br><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbvh3uj20pa0dygml.jpg" alt="Visibility Behavior"></li><li>也可以使用goneMargin来<strong>保持预期的边距</strong><!-- ![margin gone](https://ws1.sinaimg.cn/large/a328671cly1ft63nbnva9j20ee0dagmk.jpg) --><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbnva9j20ee0dagmk.jpg" width="320" alt="margin gone"></li></ul><p>这种特殊的处理，可以在你临时的把view设置为GONE时，不破坏布局结构。</p><h3 id="1-3-居中和偏移"><a href="#1-3-居中和偏移" class="headerlink" title="1.3 居中和偏移"></a>1.3 居中和偏移</h3><p>居中的设置参考之前于RelativeLayout的对应关系，CL增加了偏移属性，使用偏移可以更好的处理屏幕大小改变时的情景。<br><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbngqij20nm08gdgc.jpg" alt="center"><br><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbnttlj21340cot9z.jpg" alt="bias"></p><p>布局中设置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.constraint.ConstraintLayout ...&gt;</span><br><span class="line">    &lt;Button android:id=<span class="string">"@+id/button"</span> ...</span><br><span class="line">        app:layout_constraintHorizontal_bias=<span class="string">"0.3"</span></span><br><span class="line">        app:layout_constraintLeft_toLeftOf=<span class="string">"parent"</span></span><br><span class="line">        app:layout_constraintRight_toRightOf=<span class="string">"parent/&gt;</span></span><br><span class="line"><span class="string">&lt;/&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="1-4-圆形的位置"><a href="#1-4-圆形的位置" class="headerlink" title="1.4 圆形的位置"></a>1.4 圆形的位置</h3><p><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbyao7j21600tyq7z.jpg" alt="circle"><br>使用圆形约束，在创建圆形的菜单时非常有用<br><img src="https://cdn-images-1.medium.com/max/1600/1*dkCMb35o4HN7SVX8S1N3ig.gif" alt="circle menu"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button android:id=<span class="string">"@+id/buttonA"</span> ... /&gt;</span><br><span class="line">&lt;Button android:id=<span class="string">"@+id/buttonB"</span> ...</span><br><span class="line">    app:layout_constraintCircle=<span class="string">"@+id/buttonA"</span></span><br><span class="line">    app:layout_constraintCircleRadius=<span class="string">"100dp"</span></span><br><span class="line">    app:layout_constraintCircleAngle=<span class="string">"45"</span> /&gt;</span><br></pre></td></tr></table></figure><h2 id="2-控制尺寸-大小"><a href="#2-控制尺寸-大小" class="headerlink" title="2. 控制尺寸(大小)"></a>2. 控制尺寸(大小)</h2><h3 id="2-1-给ConstraintLayout自己添加大小限制"><a href="#2-1-给ConstraintLayout自己添加大小限制" class="headerlink" title="2.1 给ConstraintLayout自己添加大小限制"></a>2.1 给ConstraintLayout自己添加大小限制</h3><p>当ConstraintLayout的大小设置为<strong>WRAP_CONTENT</strong>时，可以很方便的设置自己的最大宽高<br><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbvcurj20pw08sdh1.jpg" width="600" alt="max min"><br><!-- ![max min](https://ws1.sinaimg.cn/large/a328671cly1ft63nbvcurj20pw08sdh1.jpg) --></p><h3 id="2-2-Widgets的尺寸-大小-约束"><a href="#2-2-Widgets的尺寸-大小-约束" class="headerlink" title="2.2 Widgets的尺寸(大小)约束"></a>2.2 Widgets的尺寸(大小)约束</h3><p>和我们在常用的布局中设置宽高一样，控制Widgets的宽度和高度一共有3种方式：</p><ul><li><strong>固定的大小</strong>，如123dp</li><li><strong>WRAP_CONTENT</strong> 自适应</li><li><strong>0dp</strong>，等于<strong>MATCH_CONSTRAINT</strong>，类似于match_parent，会利用所有可用的空间。注意，不建议使用match_parent</li></ul><p><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbpx54j20oc0heta2.jpg" alt="dimension-constraints"></p><h3 id="2-3-WRAP-CONTENT-强制约束"><a href="#2-3-WRAP-CONTENT-强制约束" class="headerlink" title="2.3 WRAP_CONTENT 强制约束"></a>2.3 WRAP_CONTENT 强制约束</h3><p>默认情况下，设置为WRAP_CONTENT的组件不会限制他们的大小，有时会导致超出约束条件的情况，如果需要强制他们满足约束条件的话，使用下面的强制约束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constrainedWidth=&quot;true|false&quot;</span><br><span class="line">app:layout_constrainedHeight=&quot;true|false&quot;</span><br></pre></td></tr></table></figure></p><h3 id="2-4-MATCH-CONSTRAINT-大小控制"><a href="#2-4-MATCH-CONSTRAINT-大小控制" class="headerlink" title="2.4 MATCH_CONSTRAINT 大小控制"></a>2.4 MATCH_CONSTRAINT 大小控制</h3><p>默认情况下，MATCH_CONSTRAINT 会利用所有可用的空间，通过下面的设置，可以自定义具体的行为</p><ul><li><code>layout_constraintWidth_min</code> and <code>layout_constraintHeight_min</code></li><li><code>layout_constraintWidth_max</code> and <code>layout_constraintHeight_max</code></li><li><code>layout_constraintWidth_percent</code> and <code>layout_constraintHeight_percent</code></li><li>使用百分比大小时，对应方向的大小必须设置为 MATCH_CONSTRAINT</li></ul><h3 id="2-5-使用比例"><a href="#2-5-使用比例" class="headerlink" title="2.5 使用比例"></a>2.5 使用比例</h3><p>使用比例有两种情况，而且必须至少有一条边被设置为0dp：</p><ul><li>如果只有一条边被设置为0dp，设置比例时，将参考另外一条已经确定尺寸的边</li><li>如果两条边都被设置为0dp，那么会在满足比例的条件下，设置为最大尺寸</li><li>同样的支持直接设置<code>layout_constraintWidth_percent</code>和<code>layout_constraintHeight_percent</code>来使用百分比控制相对于parent的比例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">    android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_height=<span class="string">"0dp"</span></span><br><span class="line">    app:layout_constraintDimensionRatio=<span class="string">"1.6"</span> /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">    android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_height=<span class="string">"0dp"</span></span><br><span class="line">    app:layout_constraintDimensionRatio=<span class="string">"1:1"</span> /&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">    android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">    android:layout_height=<span class="string">"0dp"</span></span><br><span class="line">    app:layout_constraintBottom_toBottomOf=<span class="string">"parent"</span></span><br><span class="line">    app:layout_constraintDimensionRatio=<span class="string">"H,16:9"</span></span><br><span class="line">    app:layout_constraintTop_toTopOf=<span class="string">"parent"</span> /&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-6-Chains"><a href="#2-6-Chains" class="headerlink" title="2.6 Chains"></a>2.6 Chains</h3><p>Chains能自定义在同一轴线上view的位置和大小，首先我们来创建一条链，当widgets之间在同一个方向上相互连接(相互约束)时，链就形成了。</p><p><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbnpdwj20nq094jry.jpg" alt="chain"></p><h4 id="2-6-1-链的head"><a href="#2-6-1-链的head" class="headerlink" title="2.6.1 链的head"></a>2.6.1 链的head</h4><p>水平方向chain最左边的控件和垂直方向chain最顶部的控件被成为<code>head chain</code>。通过对head chain添加<code>chainStyle</code>属性，可以设置该条chain在水平或垂直方向上的chainStyle</p><p><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbnl5yj20r407ggm6.jpg" alt="chain head"></p><h4 id="2-6-2-Chain-Style"><a href="#2-6-2-Chain-Style" class="headerlink" title="2.6.2 Chain Style"></a>2.6.2 Chain Style</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout_constraintHorizontal_chainStyle</span><br><span class="line">layout_constraintVertical_chainStyle</span><br></pre></td></tr></table></figure><p>chainStyle属性一共有三种：spread、spread_inside、packed。再配合其他属性，最终可以组成五种chain style：<br><img src="https://ws1.sinaimg.cn/large/a328671cly1ft63nbwsmtj21360kgdjl.jpg" alt="chainStyle"></p><p>其他四种chain style的设置和效果都比较简单，重点介绍下<strong>Weighted Chain</strong>。</p><ul><li>默认的spread模式，每个元素获得同样的空间，如果一个元素使用了0dp，将会占用剩下的所有可用空间</li><li><code>layout_constraintHorizontal_weight</code>和<code>layout_constraintVertical_weight</code>可以用来控制同样设置为0dp的控件的比例</li><li>Weighted Chain中的控件也允许在chain方向上使用wrap_content自适应控件宽/高，且布局时<strong>优先满足设置为wrap_content的控件</strong>，相当于优先满足设置了指定宽高的控件</li><li>当设置了margin时，margin生效的同时weight的比例不变，链上的控件实际占有布局会被压缩</li></ul><h2 id="3-不可见的辅助工具"><a href="#3-不可见的辅助工具" class="headerlink" title="3. 不可见的辅助工具"></a>3. 不可见的辅助工具</h2><h3 id="Guideline"><a href="#Guideline" class="headerlink" title="Guideline"></a>Guideline</h3><h3 id="barrier"><a href="#barrier" class="headerlink" title="barrier"></a>barrier</h3><h3 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h3><h2 id="4-用代码的方式操作"><a href="#4-用代码的方式操作" class="headerlink" title="4. 用代码的方式操作"></a>4. 用代码的方式操作</h2><h3 id="ps-选择优化类型"><a href="#ps-选择优化类型" class="headerlink" title="ps. 选择优化类型"></a>ps. 选择优化类型</h3><p>Package Index:<br>android.support.constraint<br>android.support.constraint.helper<br>android.support.constraint.motion<br>android.support.constraint.utils</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;现在大家几乎都使用过ConstraintLayout，但与经常使用的布局相比，可能会面临不熟悉CL的API或者是逐渐增加的新特性，还有可能因为对CL具体行为的理解模糊而导致误用，这篇文章的目的更多的是，&lt;strong&gt;全面总结ConstraintL
      
    
    </summary>
    
      <category term="Android" scheme="https://haohaozaici.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>「播放器」处理界面旋转</title>
    <link href="https://haohaozaici.github.io/2018/06/11/player-orientation/"/>
    <id>https://haohaozaici.github.io/2018/06/11/player-orientation/</id>
    <published>2018-06-11T11:49:06.000Z</published>
    <updated>2018-06-12T02:43:35.541Z</updated>
    
    <content type="html"><![CDATA[<p>屏幕旋转是开发播放器过程中大家都会实现的基础功能，简单的说，就是视频播放画面跟随手机的方向旋转，<br>达到比较好的用户体验。但是细节往往决定成败┐(ﾟ～ﾟ)┌。我主动点击了全屏按钮屏幕会不会自己又转回来了？<br>两个方向横屏的情况点击回到竖屏处理的是不是正确的？blablabla…今天就好好把这一切捋清楚&lt;(￣︶￣)&gt;</p><blockquote><p>这篇文章的目的是：<strong>如果你对屏幕旋转逻辑不够清晰，还对屏幕旋转的功能细节不够满意的话，一起来将整个逻辑思考清楚吧。</strong></p></blockquote><h2 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a>基础回顾</h2><ul><li>通过<code>activity.setRequestedOrientation(@ActivityInfo.ScreenOrientation)</code>方法实现控制界面的方向</li><li>通过<code>OrientationEventListener(activity)</code>来监听屏幕方向(角度)的变化</li></ul><p>就这么简单，就这一个方法和一个监听器。旁白君：这么简单还讲毛线哇 (⊙ˍ⊙)，散了散了…！！！大家慢走，<br>的确就这两个东东，但还要组合4个方向，两个操作，两个状态，还有balabala… 旁白君：有人装神弄鬼啦，大家快走！。</p><p>哈哈，言归正传~这些状态和操作一开始组合起来真的把我弄晕了，不过冷静下来思考之后，回归了简单。</p><h2 id="情景分析"><a href="#情景分析" class="headerlink" title="情景分析"></a>情景分析</h2><p>首先看看手机方向示意图：</p><p><img src="https://ww1.sinaimg.cn/large/a328671cly1fs7iv2gkuwj20eg0eowg8.jpg" alt="img1"></p><p>为什么会弄晕我，大家来看看下面的细节，由浅入深：</p><ul><li>屏幕跟着手机旋转</li><li>在竖直方向点击横屏后，屏幕方向保持横向，不会自动转回来（同时也适用于横向的情况）</li><li>反向横屏的时候，点击竖屏，应该回到正向竖屏。反向竖屏的时候，点击横屏应该回到”正向”横屏。<br>（保证都能回到正向竖屏，同时保持协调）</li><li>在2和3的条件下，比如在竖直方向点击横屏后，屏幕方向保持横向，然后手机屏幕旋转到横向后，<br>再旋转到竖向时，屏幕应该跟随手机旋转到竖向。（相当于旋转到期望状态后，限制就自动解除）</li><li>在以上逻辑的前提下，旋转屏幕，手机应正常保持跟随旋转。（只限制应该限制的方向）</li></ul><p>没这么复杂啊，你是不是在糊弄我？。。。咳咳，真的不是我太纠结，追求完美是吧。<br>那么这些逻辑哪里复杂了？哪些条件又存在冲突呢。</p><p><strong>矛盾的点</strong>：</p><ul><li>「横屏、反向横屏」，「竖屏、反向竖屏」时，点击恢复按钮都需要都需要恢复到”正向”状态，且旋转后不能立刻恢复。</li><li>限制条件启动后，除了限制旋转的方向外，手机应正常保持跟随旋转</li><li>限制条件启动后，在旋转到期望状态后，解除限制</li></ul><p>这里横向的”正方向”不重要，顺时针和逆时针都行。矛盾的关键就是：</p><ul><li>正向时点击产生的限制与手机应正常保持跟随旋转</li><li>反向时点击产生的限制与手机应正常保持跟随旋转</li><li>限制与解除限制</li></ul><h2 id="正确的思路"><a href="#正确的思路" class="headerlink" title="正确的思路"></a>正确的思路</h2><p>为了保证不先把我自己弄晕，直接来看正确的思路。o(￣▽￣)ｄ</p><p>切记不能跟着条件一个个满足，这就会进入矛盾的漩涡，解决了这个对立的那个又不满足了。</p><p>处理旋转逻辑的思路：</p><ul><li>准确的知道当前方向（当前方向不能作为标志保存，必须实时获取）</li><li>保存点击时的方向，提供限制</li><li>旋转到非限制方向时，解除限制</li></ul><p>这就好办了，首先我们完成最基础的，跟随手机的角度旋转屏幕：<br><img src="https://ww1.sinaimg.cn/large/a328671cly1fs7iv2gs7xj20lz0bpq5c.jpg" alt="img2"></p><p>再加上点击后屏幕旋转到竖(横)向正方向的功能：<br><img src="https://ww1.sinaimg.cn/large/a328671cly1fs7iv2gu1sj20ja07iwg9.jpg" alt="img3"></p><p>注意开启功能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orientationEventListener.enable();</span><br></pre></td></tr></table></figure></p><p>这个时候我们会发现问题，没有满足这个条件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在竖直方向点击横屏后，屏幕方向保持横向，不会自动转回来（同时也适用于横向的情况）</span><br></pre></td></tr></table></figure></p><p>记住原来的教训：<strong>不能跟着条件一个个满足</strong>。问题的根本是我们要提供限制，并且在旋转到非限制方向时，解除限制。限制是什么，是我们不能旋转回原来的方向，所以我们记录下了点击时的方向：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mOldScreenRotation = activity.getWindowManager().getDefaultDisplay().getRotation();</span><br></pre></td></tr></table></figure></p><p>那什么时候解除限制呢，旋转到非原始方向时就解除限制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">mScreenRotation = activity.getWindowManager().getDefaultDisplay().getRotation();</span><br><span class="line"><span class="comment">// 自动竖屏</span></span><br><span class="line"><span class="keyword">if</span> (((rotation &gt;= <span class="number">0</span>) &amp;&amp; (rotation &lt;= <span class="number">15</span>)) || (rotation &gt;= <span class="number">345</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mOldScreenRotation != Surface.ROTATION_0) &#123;</span><br><span class="line">        <span class="comment">//解除限制</span></span><br><span class="line">        mOldScreenRotation = -<span class="number">1</span>; <span class="comment">//-1不代表任何方向</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mScreenRotation == Surface.ROTATION_0 || (mOldScreenRotation != -<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">//当前的角度和屏幕方向一致，不处理</span></span><br><span class="line">        <span class="comment">//没有旋转到非原始方向，被限制</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自动反向横屏</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (rotation &gt; <span class="number">75</span> &amp;&amp; rotation &lt; <span class="number">105</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mOldScreenRotation != Surface.ROTATION_270) &#123;</span><br><span class="line">        mOldScreenRotation = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mScreenRotation == Surface.ROTATION_270 || (mOldScreenRotation != -<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自动反向竖屏</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (rotation &gt; <span class="number">165</span> &amp;&amp; rotation &lt; <span class="number">195</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mOldScreenRotation != Surface.ROTATION_180) &#123;</span><br><span class="line">        mOldScreenRotation = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mScreenRotation == Surface.ROTATION_180 || mOldScreenRotation != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自动横屏</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (((rotation &gt;= <span class="number">255</span>) &amp;&amp; (rotation &lt;= <span class="number">285</span>))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mOldScreenRotation != Surface.ROTATION_90) &#123;</span><br><span class="line">        mOldScreenRotation = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mScreenRotation == Surface.ROTATION_90 || (mOldScreenRotation != -<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意<code>Surface.ROTATION_270</code>和<code>onOrientationChanged(int rotation)</code>的角度正好是相反的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;屏幕旋转是开发播放器过程中大家都会实现的基础功能，简单的说，就是视频播放画面跟随手机的方向旋转，&lt;br&gt;达到比较好的用户体验。但是细节往往决定成败┐(ﾟ～ﾟ)┌。我主动点击了全屏按钮屏幕会不会自己又转回来了？&lt;br&gt;两个方向横屏的情况点击回到竖屏处理的是不是正确的？blab
      
    
    </summary>
    
      <category term="播放器" scheme="https://haohaozaici.github.io/categories/%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>「播放器」Mac上编译ijkplayer so支持HTTPS</title>
    <link href="https://haohaozaici.github.io/2018/06/07/build-ijkplayer/"/>
    <id>https://haohaozaici.github.io/2018/06/07/build-ijkplayer/</id>
    <published>2018-06-07T08:02:19.000Z</published>
    <updated>2018-07-11T12:29:44.559Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>当项目中使用ijkplayer，而且还需要播放HTTPS链接的视频时，就比较蛋疼了 (￣.￣)，ijkplayer默认不支持HTTPS播放，但提供了编译OpenSSL的选项，可以自己编译so文件支持HTTPS播放。这篇文章的目的是<strong>引导不熟悉的人完成整个编译过程，提醒过程中的注意事项，还有各种选项的解释</strong>。</p></blockquote><h2 id="我的编译环境"><a href="#我的编译环境" class="headerlink" title="我的编译环境"></a>我的编译环境</h2><p>VMware + Ubuntu编译环境也可以参考，基本上只有命令不同，homebrew的安装这里不再赘述。非常不建议在Windows环境下编译！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mac 10.13.2</span><br><span class="line">iTerm2 + zsh</span><br><span class="line">HomeBrew</span><br><span class="line">NDK r10e</span><br><span class="line"></span><br><span class="line">NDK + 编译所有so大概需要10GB空间</span><br></pre></td></tr></table></figure></p><p>相关链接:</p><ul><li><a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="noopener">Bilibili/ijkplayer</a></li><li><a href="https://www.jianshu.com/p/bd289e25d272" target="_blank" rel="noopener">IJKPlayer编译so支持HTTPS的踩坑历程</a></li><li><a href="https://blog.csdn.net/coder_pig/article/details/79134625" target="_blank" rel="noopener">ijkplayer编译so库真没那么难</a></li></ul><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><h3 id="安装Git与yasm"><a href="#安装Git与yasm" class="headerlink" title="安装Git与yasm"></a>安装Git与yasm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br><span class="line">brew install yasm</span><br></pre></td></tr></table></figure><h3 id="配置SDK、NDK"><a href="#配置SDK、NDK" class="headerlink" title="配置SDK、NDK"></a>配置SDK、NDK</h3><p>SDK都会有，NDK一般没有下载，建议去官网下载:<a href="https://developer.android.google.cn/ndk/downloads/older_releases" target="_blank" rel="noopener">https://developer.android.google.cn/ndk/downloads/older_releases</a></p><p>需要注意的是最好下载官方lib使用的<strong>NDK r10e</strong>，使用其他版本的将无法编译。具体原因可以参考<a href="https://github.com/Bilibili/ijkplayer/issues/2752" target="_blank" rel="noopener">这篇issue</a></p><p>SDK、NDK和准备完成后，在<code>.bash_profile</code>, 或者是<code>.zshrc</code>中添加配置。(<code>Command + shift + .</code> 显示隐藏文件)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 注意替换为自己的文件路径</span><br><span class="line">export ANDROID_SDK=/Users/haoyuan/Library/Android/sdk</span><br><span class="line">export PATH=$ANDROID_SDK/platform-tools:$PATH</span><br><span class="line">export PATH=$ANDROID_SDK/tools:$PATH</span><br><span class="line">export ANDROID_NDK=/Users/haoyuan/Library/Android/android-ndk-r10e</span><br><span class="line">export PATH=$ANDROID_NDK:$PATH</span><br></pre></td></tr></table></figure><p>添加完成后，保存文件，然后<code>source .bash_profile</code>等相关文件，或者<strong>直接重启终端</strong>，通过 <code>ndk-build -v</code> 检查是否生效</p><p><img src="https://ww1.sinaimg.cn/large/a328671cly1fs2p78ggb9j20ug084dpy.jpg" alt="img"></p><h3 id="clone-ijkplayer源码"><a href="#clone-ijkplayer源码" class="headerlink" title="clone ijkplayer源码"></a>clone ijkplayer源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Bilibili/ijkplayer.git ijkplayer-android</span><br><span class="line">cd ijkplayer-android</span><br><span class="line">git checkout -B latest k0.8.8</span><br></pre></td></tr></table></figure><h2 id="2-编译之前"><a href="#2-编译之前" class="headerlink" title="2. 编译之前"></a>2. 编译之前</h2><h3 id="编译前选择你的配置"><a href="#编译前选择你的配置" class="headerlink" title="编译前选择你的配置"></a>编译前选择你的配置</h3><p>选择自动化编译时的一些配置选项，比如支持的协议，音视频类型等，官方给我们提供了三个模板。</p><p>可以打开config/目录下config/module.sh看看，enable启用，disable禁用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module-default.sh</span><br><span class="line">module-lite-hevc.sh</span><br><span class="line">module-lite.sh</span><br></pre></td></tr></table></figure></p><p><img src="https://ww1.sinaimg.cn/large/a328671cly1fs2p78eh8lj20yc0xqwir.jpg" alt="img"></p><p>官方默认建议选择的是 <code>module-lite.sh</code>，可以根据自己的需求选择<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd config</span><br><span class="line">rm module.sh</span><br><span class="line">ln -s module-lite.sh module.sh</span><br></pre></td></tr></table></figure></p><p>如果要选择<code>module-default.sh</code>的话，可能会编译失败，可以参考<a href="https://github.com/Bilibili/ijkplayer/issues/4043" target="_blank" rel="noopener">这篇issue</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">仔细阅读module-lite.h 原来在最下面有一行配置：</span><br><span class="line">export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --disable-linux-perf&quot;</span><br><span class="line">把这行复制到module-default.sh 的最后面就可以了</span><br></pre></td></tr></table></figure></p><p>在编译配置中可以增减需要的模块，选择需要支持的<strong>封装格式、编解码类型、协议</strong>能有效减小so库的体积。可以参考<a href="https://github.com/CarGuo/GSYVideoPlayer/blob/master/doc/DECODERS.md" target="_blank" rel="noopener">CarGuo/GSYVideoPlayer DECODERS.md</a></p><h2 id="3-开始编译ヽ-｀⌒´-ﾉ"><a href="#3-开始编译ヽ-｀⌒´-ﾉ" class="headerlink" title="3. 开始编译ヽ(｀⌒´)ﾉ"></a>3. 开始编译ヽ(｀⌒´)ﾉ</h2><h3 id="执行初始化"><a href="#执行初始化" class="headerlink" title="执行初始化"></a>执行初始化</h3><p>初始化会下载各种包，尽量选择在良好的网络环境下╮(￣▽￣)╭<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">./init-android.sh</span><br></pre></td></tr></table></figure></p><p>初始化OpenSSL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./init-android-openssl.sh</span><br></pre></td></tr></table></figure></p><h3 id="编译OpenSSL和FFmpeg"><a href="#编译OpenSSL和FFmpeg" class="headerlink" title="编译OpenSSL和FFmpeg"></a>编译OpenSSL和FFmpeg</h3><p>首先清除一波<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd android/contrib</span><br><span class="line">./compile-openssl.sh clean</span><br><span class="line">./compile-ffmpeg.sh clean</span><br></pre></td></tr></table></figure></p><p>编译OpenSSL：可以选择不同版本，全量编译耗时更长，但最好选择全量编译，编译完成后再根据需求选择要使用的包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./compile-openssl.sh all</span><br></pre></td></tr></table></figure></p><p>编译FFmpeg，同样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./compile-ffmpeg.sh all</span><br><span class="line"></span><br><span class="line">// 如果要选择特定的架构: ./compile-ffmpeg.sh armv7a | armv5</span><br></pre></td></tr></table></figure></p><p>最后编译ijkplayer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./compile-ijk.sh all</span><br></pre></td></tr></table></figure></p><p>经过漫长的等待终于完成了以上编译过程\（￣︶￣）/，在目录中生成了ijkplayer的工程<br><img src="https://ww1.sinaimg.cn/large/a328671cly1fs2p78dwkmj20hq09vac5.jpg" alt="IMG"></p><h2 id="4-导入项目"><a href="#4-导入项目" class="headerlink" title="4. 导入项目"></a>4. 导入项目</h2><p>原有的项目一般是这样配置的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;tv.danmaku.ijk.media:ijkplayer-java:&apos; + gradle.ijkplayer_java</span><br><span class="line">implementation &apos;tv.danmaku.ijk.media:ijkplayer-armv7a:&apos; + gradle.ijkplayer_java</span><br></pre></td></tr></table></figure></p><p>如果只需要修改so库的话，<strong>删除掉第二行对so库的引用，将自己编译好的so文件复制到项目的libs文件夹中</strong>。</p><p>别忘了在gradle中配置，要不然会报错找不到so库<br><img src="https://ww1.sinaimg.cn/large/a328671cly1fs2p78cr4dj209602vgll.jpg" alt="IMG"></p><p>还可以在release包中设置abi过滤<br><img src="https://ww1.sinaimg.cn/large/a328671cly1fs2p78dgn4j20l50cgwfu.jpg" alt="IMG"></p><p>最后大功告成啦\(^o^)/</p><p>尾巴…</p><p>如果项目中同时使用了HTTP和HTTPS的视频源的话，要注意如果视频源刚好是相同域名，会导致播放失败，这是由于dns缓存造成的，解决办法参考<a href="https://github.com/CarGuo/GSYVideoPlayer/issues/1175" target="_blank" rel="noopener">这篇issue</a><br>初始化<code>IjkMediaPlayer</code>时，设置清除<code>dns cache</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;dns_cache_clear&quot;, 1</span><br><span class="line"></span><br><span class="line">//还要注意开启相关支持的协议</span><br><span class="line">IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;protocol_whitelist&quot;, </span><br><span class="line">&quot;async,cache,crypto,file,http,https,ijkhttphook,ijkinject,</span><br><span class="line">ijklivehook,ijklongurl,ijksegment,ijktcphook,</span><br><span class="line">pipe,rtp,tcp,tls,udp,ijkurlhook,data&quot;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;当项目中使用ijkplayer，而且还需要播放HTTPS链接的视频时，就比较蛋疼了 (￣.￣)，ijkplayer默认不支持HTTPS播放，但提供了编译OpenSSL的选项，可以自己编译so文件支持HTTPS播放。这篇文章的目的是&lt;strong&gt;引
      
    
    </summary>
    
      <category term="Android" scheme="https://haohaozaici.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>「播放器」Android音频焦点</title>
    <link href="https://haohaozaici.github.io/2018/04/24/Android%20Sound%20overlap/"/>
    <id>https://haohaozaici.github.io/2018/04/24/Android Sound overlap/</id>
    <published>2018-04-24T11:22:02.000Z</published>
    <updated>2018-08-01T11:44:32.987Z</updated>
    
    <content type="html"><![CDATA[<p>音视频播放在手机日常使用中非常频繁，当我们听着音乐刷着微博时，看到有趣的视频点击开始播放，音乐自动暂停，退出视频时音乐又自动恢复了播放(如果没有自动恢复的话，比如QQ音乐就会提示是否设置中断后继续播放)。</p><p><img src="https://img.mukewang.com/5aded21b0001ab9210801920.png" width="240" alt="中断后继续播放"></p><p>这一系列流畅自然的操作不是理所应当的吗~当然如果处理不好的话就会出现声音重叠，音频焦点长期被占用的问题，下面我们来看看具体的功能逻辑。</p><p>音频焦点相关的讲解参考以下文章</p><blockquote><p><a href="https://www.jianshu.com/p/5d8d7b677690" target="_blank" rel="noopener">Android音频焦点详解</a><br><a href="https://developer.android.com/guide/topics/media-apps/audio-focus.html" target="_blank" rel="noopener">Managing Audio Focus</a></p></blockquote><h2 id="Managing-Audio-Focus"><a href="#Managing-Audio-Focus" class="headerlink" title="Managing Audio Focus"></a>Managing Audio Focus</h2><p>不同的APP可以同时播放音频，系统会将他们混合在一起，但为了避免同时播放，Android提供了<strong>audio focus</strong>机制来合理使用音频播放资源。同一时间只能有一个APP获取音频焦点，当需要播放音频时，应该立即请求音频焦点，同样的，在你的APP获取到音频焦点后，其他APP也可以抢占音频焦点，这时你的APP就需要暂停播放或降低声音。音频焦点是合作类型的，APP拥有完全自主的控制权，系统无法阻止，但应用应该遵守音频焦点的指导规则。</p><p>好的音频APP在播放时应该遵守以下规则：</p><ul><li>开始播放后立即调用<code>requestAudioFocus()</code>方法，并验证返回值为<code>AUDIOFOCUS_REQUEST_GRANTED</code></li><li>当其他app占用音频焦点时，暂停或停止播放，或者降低声音</li><li>当播放停止时，放弃音频焦点</li></ul><p>在不同的Android版本下，需要使用不同的方法来处理音频焦点：</p><ul><li><em>API level 8</em>以后，使用<code>requestAudioFocus()</code>和<code>abandonAudioFocus()</code>方法，并注册<code>AudioManager.OnAudioFocusChangeListener</code>接收回调。</li><li><em>API level 21</em>以后，需要使用<code>AudioAttributes</code>来描述播放音频的类型。</li><li><p><em>API level 26</em>以后，需要使用<code>AudioFocusRequest</code>参数，它携带了音频的context和相关功能，系统会根据这些自动管理音频焦点。</p><h3 id="Android8-0以前"><a href="#Android8-0以前" class="headerlink" title="Android8.0以前"></a>Android8.0以前</h3><p>参考官方文档获取焦点的方法如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Request audio focus for playback</span></span><br><span class="line"><span class="keyword">int</span> result = am.requestAudioFocus(afChangeListener,</span><br><span class="line">        <span class="comment">// Use the music stream.</span></span><br><span class="line">        AudioManager.STREAM_MUSIC,</span><br><span class="line">        <span class="comment">// Request permanent focus.</span></span><br><span class="line">        AudioManager.AUDIOFOCUS_GAIN);</span><br></pre></td></tr></table></figure><p>但在听音乐的时候播放音频或视频，依旧出现了重叠的声音，实际上有效的做法是这样的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面两个常量参数试过很多 都无效，最终反编译了其他app才搞定，汗~  </span></span><br><span class="line"><span class="keyword">int</span> requestFocusResult = mAudioManager.requestAudioFocus(</span><br><span class="line">        mAudioFocusChangeListener,</span><br><span class="line">        AudioManager.STREAM_MUSIC,</span><br><span class="line">        AudioManager.AUDIOFOCUS_GAIN_TRANSIENT);</span><br></pre></td></tr></table></figure></p><p>具体参考文章<a href="https://blog.csdn.net/SYIF88/article/details/68064866" target="_blank" rel="noopener">Android MediaPlayer音频焦点问题，抢占声道</a></p><p>最后在对应的播放状态下获取和释放音频焦点。</p><h3 id="Android8-0之后"><a href="#Android8-0之后" class="headerlink" title="Android8.0之后"></a>Android8.0之后</h3><p>和之前一样，Android8.0中也使用了<code>requestAudioFocus()</code>来请求音频焦点，不一样的是，使用<code>abandonAudioFocusRequest()</code>释放音频焦点，并且请求和释放都需要传入同一个<code>AudioFocusRequest</code>实例。使用<code>AudioFocusRequest.Builder</code>来创建，具体实现代码参考官方文档<a href="https://developer.android.com/guide/topics/media-apps/audio-focus.html#audio-focus-8-0" target="_blank" rel="noopener">Audio focus in Android 8.0 and later</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mAudioFocusRequest = <span class="keyword">new</span> AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN)</span><br><span class="line">        .setAudioAttributes(<span class="keyword">new</span> AudioAttributes.Builder()</span><br><span class="line">                .setUsage(AudioAttributes.USAGE_MEDIA)</span><br><span class="line">                .setContentType(AudioAttributes.CONTENT_TYPE_MOVIE)</span><br><span class="line">                .build())</span><br><span class="line">        .setAcceptsDelayedFocusGain(<span class="keyword">true</span>)</span><br><span class="line">        .setOnAudioFocusChangeListener(mAudioFocusChangeListener)</span><br><span class="line">        .build();</span><br><span class="line"><span class="comment">//请求音频焦点      </span></span><br><span class="line">requestFocusResult = mAudioManager.requestAudioFocus(mAudioFocusRequest);</span><br><span class="line"><span class="comment">//释放音频焦点</span></span><br><span class="line">abandonFocusResult = mAudioManager.abandonAudioFocusRequest(mAudioFocusRequest);</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>Android8.0中其他APP使用<code>AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK</code>参数获取焦点时，将不会回调本APP的<code>onAudioFocusChange()</code>方法。</li><li>焦点延迟获取，当焦点被其他APP<strong>“锁”</strong>住时，<code>requestAudioFocus()</code>会返回<code>AUDIOFOCUS_REQUEST_FAILED</code>，比如正在打电话时，焦点就会被锁住。如果使用了<code>setAcceptsDelayedFocusGain(true)</code>方法，请求将会返回<code>AUDIOFOCUS_REQUEST_DELAYED</code>，在锁解除后，系统会继续处理未完成的焦点请求，并回调<code>onAudioFocusChange()</code>方法。</li></ul><h2 id="处理音频焦点变化"><a href="#处理音频焦点变化" class="headerlink" title="处理音频焦点变化"></a>处理音频焦点变化</h2><p>了解相应的请求、释放方法后，还需要进一步处理音频焦点变化问题，也就是优化跟其他APP或者是系统APP合作的过程。主要是处理<code>onAudioFocusChange</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AudioManager.OnAudioFocusChangeListener mAudioFocusChange = <span class="keyword">new</span> AudioManager.OnAudioFocusChangeListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAudioFocusChange</span><span class="params">(<span class="keyword">int</span> focusChange)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (focusChange)&#123;</span><br><span class="line">                <span class="keyword">case</span> AudioManager.AUDIOFOCUS_GAIN:</span><br><span class="line">                    <span class="comment">//当其他应用申请焦点之后又释放焦点会触发此回调</span></span><br><span class="line">                    <span class="comment">//可重新播放音乐</span></span><br><span class="line">                    Log.d(TAG, <span class="string">"AUDIOFOCUS_GAIN"</span>);</span><br><span class="line">                    start();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS:</span><br><span class="line">                    <span class="comment">//长时间丢失焦点,当其他应用申请的焦点为AUDIOFOCUS_GAIN时，</span></span><br><span class="line">                    <span class="comment">//会触发此回调事件，例如播放QQ音乐，网易云音乐等</span></span><br><span class="line">                    <span class="comment">//通常需要暂停音乐播放，若没有暂停播放就会出现和其他音乐同时输出声音</span></span><br><span class="line">                    Log.d(TAG, <span class="string">"AUDIOFOCUS_LOSS"</span>);</span><br><span class="line">                    stop();</span><br><span class="line">                    <span class="comment">//释放焦点，该方法可根据需要来决定是否调用</span></span><br><span class="line">                    <span class="comment">//若焦点释放掉之后，将不会再自动获得</span></span><br><span class="line">                    mAudioManager.abandonAudioFocus(mAudioFocusChange);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:</span><br><span class="line">                    <span class="comment">//短暂性丢失焦点，当其他应用申请AUDIOFOCUS_GAIN_TRANSIENT或AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE时，</span></span><br><span class="line">                    <span class="comment">//会触发此回调事件，例如播放短视频，拨打电话等。</span></span><br><span class="line">                    <span class="comment">//通常需要暂停音乐播放</span></span><br><span class="line">                    stop();</span><br><span class="line">                    Log.d(TAG, <span class="string">"AUDIOFOCUS_LOSS_TRANSIENT"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:</span><br><span class="line">                    <span class="comment">//短暂性丢失焦点并作降音处理</span></span><br><span class="line">                    Log.d(TAG, <span class="string">"AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>音频相关的API常常让人疑惑，明明已经根据注释的描述和官方文档中的方法实现了，却达不到预期的效果。还有就是随着Android更新的推送速度越来越快，更新普及率也水涨船高，高版本API随时在发生变化，适配时需要注意这些细节，以及进行完善的测试。</p><p>工具类参见<a href="https://gist.github.com/haohaozaici/baaa022e6ea5f61f37112135fe1cac07" target="_blank" rel="noopener">AudioFocusManager</a></p><h4 id="未完成内容"><a href="#未完成内容" class="headerlink" title="未完成内容"></a>未完成内容</h4><p>源码简单分析</p><p>在不同机型中进行测试</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;音视频播放在手机日常使用中非常频繁，当我们听着音乐刷着微博时，看到有趣的视频点击开始播放，音乐自动暂停，退出视频时音乐又自动恢复了播放(如果没有自动恢复的话，比如QQ音乐就会提示是否设置中断后继续播放)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.mukew
      
    
    </summary>
    
      <category term="Android" scheme="https://haohaozaici.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>创建和销毁对象</title>
    <link href="https://haohaozaici.github.io/2017/12/19/create-and-destroy-objects/"/>
    <id>https://haohaozaici.github.io/2017/12/19/create-and-destroy-objects/</id>
    <published>2017-12-19T07:12:41.000Z</published>
    <updated>2017-12-29T15:17:35.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h2><h3 id="静态工厂方法代替构造器"><a href="#静态工厂方法代替构造器" class="headerlink" title="静态工厂方法代替构造器"></a>静态工厂方法代替构造器</h3><p>静态工厂方法与设计模式中的<code>工厂方法</code>不同。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li>静态工厂方法有名称，</li></ol><h3 id="遇到多个构造器参数时，使用构建器-Builder模式"><a href="#遇到多个构造器参数时，使用构建器-Builder模式" class="headerlink" title="遇到多个构造器参数时，使用构建器-Builder模式"></a>遇到多个构造器参数时，使用构建器-Builder模式</h3><h4 id="1-使用构造方法创建对象"><a href="#1-使用构造方法创建对象" class="headerlink" title="1.使用构造方法创建对象"></a>1.使用构造方法创建对象</h4><p>重叠构造器</p><h4 id="2-JavaBeans模式"><a href="#2-JavaBeans模式" class="headerlink" title="2.JavaBeans模式"></a>2.JavaBeans模式</h4><p>通过setter方法设置必要参数，拥有良好的可读性。<br><em>缺点</em>：构造过程中容易被改变，处于不一致的状态。</p><h4 id="3-Builder模式"><a href="#3-Builder模式" class="headerlink" title="3.Builder模式"></a>3.Builder模式</h4><p>通过公开的Builder内部类，私有的构造方法，构造必传参数和可选参数。Builder模式模拟了具名的可选参数，可以加强约束条件，在对象域中进行检验。可以在编译时进行异常检查。 </p><p><em>缺点</em>：特殊情况下额外的性能开销，冗长。<br><em>适用情况</em>：多个参数(大于4个)，需要比JavaBeans模式更加安全的情况。</p><p>参见 <code>Notification</code> 或 <code>Alertdialog</code>类。</p><h3 id="用私有构造器或者枚举类型强化singleton属性"><a href="#用私有构造器或者枚举类型强化singleton属性" class="headerlink" title="用私有构造器或者枚举类型强化singleton属性"></a>用私有构造器或者枚举类型强化singleton属性</h3><p>为了防止反射调用私有构造方法、反序列化时创建新的实例，直接使用 <code>包含单个元素的枚举类型</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Elvis&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h3><p>39条 应该创建新对象时，不要重用现有对象<br>创建不必要的对象只会影响程序的风格和性能，没有实施保护性拷贝将会导致潜在的错误和安全漏洞。</p><h3 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h3><p><code>内存泄露</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建和销毁对象&quot;&gt;&lt;a href=&quot;#创建和销毁对象&quot; class=&quot;headerlink&quot; title=&quot;创建和销毁对象&quot;&gt;&lt;/a&gt;创建和销毁对象&lt;/h2&gt;&lt;h3 id=&quot;静态工厂方法代替构造器&quot;&gt;&lt;a href=&quot;#静态工厂方法代替构造器&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Java" scheme="https://haohaozaici.github.io/categories/Java/"/>
    
      <category term="Effective Java" scheme="https://haohaozaici.github.io/categories/Java/Effective-Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Mifare 1k S50卡</title>
    <link href="https://haohaozaici.github.io/2017/12/13/M1%20card/"/>
    <id>https://haohaozaici.github.io/2017/12/13/M1 card/</id>
    <published>2017-12-13T08:41:43.000Z</published>
    <updated>2018-04-20T02:05:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>背景：最近的项目中涉及到读写M1卡，之前完全没接触过一脸懵逼，却没意识到，生活中常用的公交卡、门禁卡、开水卡、会员卡等等大多数都是M1类的射频卡，如Mifare 1k S50系列。熟悉了相关知识后，发现原理如此简单，感谢开源也因此能做很多方便的事情了。记录一下，面对陌生的事物不要害怕，了解熟悉，探索乐趣。</p></blockquote><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="M1卡"><a href="#M1卡" class="headerlink" title="M1卡"></a>M1卡</h3><p>M1卡结构</p><div style="align: center"><img src="/img/m1card.webp" alt="M1卡结构"> </div><p>从上面可以看到，<code>扇区0 块0</code>固化了厂家代码，32位16进制数，一般作为<code>ID</code>使用。</p><p>每一个扇区的块3用于保存<code>KEY A,存取控制,KEY B</code>，除了扇区0的块0之外的其他的<code>块0~块2</code>都用于存储数据。<code>KEY A</code>不可读、可写，<code>KEY B</code>可读可写.</p><p>一般的门禁卡中，不存储任何数据，门禁系统只读取卡ID，学校里使用的开水卡，一般是离线使用，卡的余额或者使用次数是存储在卡中的，使用时进行读写。在武汉通中，存储了卡余额，储值、消费记录，具体的余额存储在服务器上。所以理论上可以模拟卡ID来模拟门禁卡，或者是读取修改水卡值来修改卡。</p><p>读写卡工具<a href="https://play.google.com/store/apps/details?id=de.syss.MifareClassicTool" target="_blank" rel="noopener">MIFARE Classic Tool</a>, <a href="https://github.com/ikarus23/MifareClassicTool" target="_blank" rel="noopener">MifareClassicTool - GitHub</a></p><p>模拟卡工具<a href="https://play.google.com/store/apps/details?id=com.yuanwofei.cardemulator" target="_blank" rel="noopener">NFC卡模拟</a></p><h4 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h4><p><a href="https://www.null17.com/blog/coding/NFC/20151019-nfc-mod/" target="_blank" rel="noopener">Mifare 1k S50 卡的简单探讨与破解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;背景：最近的项目中涉及到读写M1卡，之前完全没接触过一脸懵逼，却没意识到，生活中常用的公交卡、门禁卡、开水卡、会员卡等等大多数都是M1类的射频卡，如Mifare 1k S50系列。熟悉了相关知识后，发现原理如此简单，感谢开源也因此能做很多方便的事情
      
    
    </summary>
    
      <category term="生活" scheme="https://haohaozaici.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="乱七八糟的技巧" scheme="https://haohaozaici.github.io/categories/%E7%94%9F%E6%B4%BB/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
</feed>
